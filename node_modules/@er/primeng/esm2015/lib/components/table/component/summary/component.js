/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, Input } from '@angular/core';
import { BaseComponent } from '@er/core';
import { AggMethodsProps } from '@er/types';
import { CommonsUtils } from '@er/utils';
import { PngTableComponent } from '../table/component';
export class PngTableSummaryComponent extends BaseComponent {
    /**
     * @param {?} pngTable
     * @param {?} cd
     */
    constructor(pngTable, cd) {
        super();
        this.pngTable = pngTable;
        this.cd = cd;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.aggValues) {
            if (changes.aggValues.currentValue) {
                this.colAggValues = {};
                Object.keys(changes.aggValues.currentValue)
                    .forEach(key => {
                    /** @type {?} */
                    let name = key;
                    if (key.indexOf('-') > 0) {
                        name = key.substr(0, key.indexOf('-'));
                    }
                    /** @type {?} */
                    const type = key.substr(key.indexOf('-') + 1);
                    /** @type {?} */
                    let values = this.colAggValues[name];
                    if (!values) {
                        values = [];
                        this.colAggValues[name] = values;
                    }
                    /** @type {?} */
                    const agg = {};
                    agg['type'] = AggMethodsProps[type] && AggMethodsProps[type].label;
                    if (CommonsUtils.isArray(this.aggValues[key])) {
                        agg['values'] = this.aggValues[key];
                    }
                    else {
                        agg['value'] = this.aggValues[key];
                    }
                    values.push(agg);
                });
            }
            else {
                this.colAggValues = undefined;
            }
            this.cd.detectChanges();
        }
    }
    /**
     * @param {?} column
     * @return {?}
     */
    cellClass(column) {
        return CommonsUtils.getValue(column.aggCellClass, column);
    }
    /**
     * @param {?} column
     * @return {?}
     */
    cellStyle(column) {
        return CommonsUtils.getValue(column.aggCellStyle, column);
    }
}
PngTableSummaryComponent.decorators = [
    { type: Component, args: [{
                selector: '[png-table-summary]',
                template: `
    <ng-container *ngIf="customerTpl;else default">
      <ng-container *ngTemplateOutlet="customerTpl;context:{$implicit:aggValues,columns:columns,context:pngTable}"></ng-container>
    </ng-container>
    <ng-template #default>
      <th *ngIf="pngTable.$props.$ext.rowExpandable" class="col-expandable col-summary"></th>
      <th *ngIf="pngTable.$props.$ext.hasRowCheckbox" class="col-checkbox col-summary"></th>
      <th *ngIf="pngTable.$props.$ext.hasRowRadioButton" class="col-radio col-summary"></th>
      <ng-container *ngIf="colAggValues">
        <th *ngFor="let col of columns" [width]="col.width" class="text-right col-summary col-summary-{{col.key}}">
          <ng-container *ngFor="let agg of colAggValues[col.key]">
            <ng-container *ngIf="agg.value">
              <div [ngClass]="cellClass(col)" style="font-size: 0.8em"
                   [ngStyle]="cellStyle(col)">{{agg.type}}: {{agg.value | floor: 2}}
              </div>
            </ng-container>
            <ng-container *ngIf="agg.values">
              <div [ngClass]="cellClass(col)" style="font-size: 0.8em"
                   [ngStyle]="cellStyle(col)"> {{agg.type}}:
              </div>
              <ul>
                <ng-container *ngFor="let data of agg.values">
                  <li class="border-bottom"><span class="">{{data.label}}:</span><span class="badge badge-pill btn-info">{{data.value}}</span></li>
                </ng-container>
              </ul>
            </ng-container>
          </ng-container>
        </th>
      </ng-container>
    </ng-template>

  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
PngTableSummaryComponent.ctorParameters = () => [
    { type: PngTableComponent },
    { type: ChangeDetectorRef }
];
PngTableSummaryComponent.propDecorators = {
    columns: [{ type: Input }],
    aggValues: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    PngTableSummaryComponent.prototype.columns;
    /** @type {?} */
    PngTableSummaryComponent.prototype.aggValues;
    /** @type {?} */
    PngTableSummaryComponent.prototype.colAggValues;
    /** @type {?} */
    PngTableSummaryComponent.prototype.pngTable;
    /**
     * @type {?}
     * @protected
     */
    PngTableSummaryComponent.prototype.cd;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGVyL3ByaW1lbmcvIiwic291cmNlcyI6WyJsaWIvY29tcG9uZW50cy90YWJsZS9jb21wb25lbnQvc3VtbWFyeS9jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBQyx1QkFBdUIsRUFBRSxpQkFBaUIsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUEyQixNQUFNLGVBQWUsQ0FBQztBQUNySCxPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0sVUFBVSxDQUFDO0FBQ3ZDLE9BQU8sRUFBQyxlQUFlLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDMUMsT0FBTyxFQUFDLFlBQVksRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUV2QyxPQUFPLEVBQUMsaUJBQWlCLEVBQUMsTUFBTSxvQkFBb0IsQ0FBQztBQXNDckQsTUFBTSxPQUFPLHdCQUF5QixTQUFRLGFBQWE7Ozs7O0lBUXpELFlBQW1CLFFBQTJCLEVBQVksRUFBcUI7UUFDN0UsS0FBSyxFQUFFLENBQUM7UUFEUyxhQUFRLEdBQVIsUUFBUSxDQUFtQjtRQUFZLE9BQUUsR0FBRixFQUFFLENBQW1CO0lBRS9FLENBQUM7Ozs7O0lBRUQsV0FBVyxDQUFDLE9BQXNCO1FBQ2hDLElBQUksT0FBTyxDQUFDLFNBQVMsRUFBRTtZQUNyQixJQUFJLE9BQU8sQ0FBQyxTQUFTLENBQUMsWUFBWSxFQUFFO2dCQUNsQyxJQUFJLENBQUMsWUFBWSxHQUFHLEVBQUUsQ0FBQztnQkFDdkIsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQztxQkFDeEMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFOzt3QkFDVCxJQUFJLEdBQUcsR0FBRztvQkFDZCxJQUFJLEdBQUcsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFO3dCQUN4QixJQUFJLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO3FCQUN4Qzs7MEJBQ0ssSUFBSSxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7O3dCQUN6QyxNQUFNLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUM7b0JBQ3BDLElBQUksQ0FBQyxNQUFNLEVBQUU7d0JBQ1gsTUFBTSxHQUFHLEVBQUUsQ0FBQzt3QkFDWixJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxHQUFHLE1BQU0sQ0FBQztxQkFDbEM7OzBCQUNLLEdBQUcsR0FBRyxFQUFFO29CQUNkLEdBQUcsQ0FBQyxNQUFNLENBQUMsR0FBRyxlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksZUFBZSxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQztvQkFDbkUsSUFBSSxZQUFZLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTt3QkFDN0MsR0FBRyxDQUFDLFFBQVEsQ0FBQyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUM7cUJBQ3JDO3lCQUFNO3dCQUNMLEdBQUcsQ0FBQyxPQUFPLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDO3FCQUNwQztvQkFDRCxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUNuQixDQUFDLENBQUMsQ0FBQzthQUNOO2lCQUFNO2dCQUNMLElBQUksQ0FBQyxZQUFZLEdBQUcsU0FBUyxDQUFDO2FBQy9CO1lBQ0QsSUFBSSxDQUFDLEVBQUUsQ0FBQyxhQUFhLEVBQUUsQ0FBQztTQUN6QjtJQUNILENBQUM7Ozs7O0lBRUQsU0FBUyxDQUFDLE1BQU07UUFDZCxPQUFPLFlBQVksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFlBQVksRUFBRSxNQUFNLENBQUMsQ0FBQztJQUM1RCxDQUFDOzs7OztJQUVELFNBQVMsQ0FBQyxNQUFNO1FBQ2QsT0FBTyxZQUFZLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxZQUFZLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDNUQsQ0FBQzs7O1lBdEZGLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUscUJBQXFCO2dCQUMvQixRQUFRLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0ErQlQ7Z0JBQ0QsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07YUFDaEQ7Ozs7WUFyQ08saUJBQWlCO1lBTFEsaUJBQWlCOzs7c0JBNkMvQyxLQUFLO3dCQUVMLEtBQUs7Ozs7SUFGTiwyQ0FBc0M7O0lBRXRDLDZDQUF5Qjs7SUFFekIsZ0RBQWlCOztJQUVMLDRDQUFrQzs7Ozs7SUFBRSxzQ0FBK0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0NoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcG9uZW50LCBJbnB1dCwgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2VzfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnQGVyL2NvcmUnO1xuaW1wb3J0IHtBZ2dNZXRob2RzUHJvcHN9IGZyb20gJ0Blci90eXBlcyc7XG5pbXBvcnQge0NvbW1vbnNVdGlsc30gZnJvbSAnQGVyL3V0aWxzJztcbmltcG9ydCB7UG5nVGFibGVDb2x1bW5Qcm9wc30gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHtQbmdUYWJsZUNvbXBvbmVudH0gZnJvbSAnLi4vdGFibGUvY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnW3BuZy10YWJsZS1zdW1tYXJ5XScsXG4gIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImN1c3RvbWVyVHBsO2Vsc2UgZGVmYXVsdFwiPlxuICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImN1c3RvbWVyVHBsO2NvbnRleHQ6eyRpbXBsaWNpdDphZ2dWYWx1ZXMsY29sdW1uczpjb2x1bW5zLGNvbnRleHQ6cG5nVGFibGV9XCI+PC9uZy1jb250YWluZXI+XG4gICAgPC9uZy1jb250YWluZXI+XG4gICAgPG5nLXRlbXBsYXRlICNkZWZhdWx0PlxuICAgICAgPHRoICpuZ0lmPVwicG5nVGFibGUuJHByb3BzLiRleHQucm93RXhwYW5kYWJsZVwiIGNsYXNzPVwiY29sLWV4cGFuZGFibGUgY29sLXN1bW1hcnlcIj48L3RoPlxuICAgICAgPHRoICpuZ0lmPVwicG5nVGFibGUuJHByb3BzLiRleHQuaGFzUm93Q2hlY2tib3hcIiBjbGFzcz1cImNvbC1jaGVja2JveCBjb2wtc3VtbWFyeVwiPjwvdGg+XG4gICAgICA8dGggKm5nSWY9XCJwbmdUYWJsZS4kcHJvcHMuJGV4dC5oYXNSb3dSYWRpb0J1dHRvblwiIGNsYXNzPVwiY29sLXJhZGlvIGNvbC1zdW1tYXJ5XCI+PC90aD5cbiAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJjb2xBZ2dWYWx1ZXNcIj5cbiAgICAgICAgPHRoICpuZ0Zvcj1cImxldCBjb2wgb2YgY29sdW1uc1wiIFt3aWR0aF09XCJjb2wud2lkdGhcIiBjbGFzcz1cInRleHQtcmlnaHQgY29sLXN1bW1hcnkgY29sLXN1bW1hcnkte3tjb2wua2V5fX1cIj5cbiAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBhZ2cgb2YgY29sQWdnVmFsdWVzW2NvbC5rZXldXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiYWdnLnZhbHVlXCI+XG4gICAgICAgICAgICAgIDxkaXYgW25nQ2xhc3NdPVwiY2VsbENsYXNzKGNvbClcIiBzdHlsZT1cImZvbnQtc2l6ZTogMC44ZW1cIlxuICAgICAgICAgICAgICAgICAgIFtuZ1N0eWxlXT1cImNlbGxTdHlsZShjb2wpXCI+e3thZ2cudHlwZX19OiB7e2FnZy52YWx1ZSB8IGZsb29yOiAyfX1cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJhZ2cudmFsdWVzXCI+XG4gICAgICAgICAgICAgIDxkaXYgW25nQ2xhc3NdPVwiY2VsbENsYXNzKGNvbClcIiBzdHlsZT1cImZvbnQtc2l6ZTogMC44ZW1cIlxuICAgICAgICAgICAgICAgICAgIFtuZ1N0eWxlXT1cImNlbGxTdHlsZShjb2wpXCI+IHt7YWdnLnR5cGV9fTpcbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBkYXRhIG9mIGFnZy52YWx1ZXNcIj5cbiAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cImJvcmRlci1ib3R0b21cIj48c3BhbiBjbGFzcz1cIlwiPnt7ZGF0YS5sYWJlbH19Ojwvc3Bhbj48c3BhbiBjbGFzcz1cImJhZGdlIGJhZGdlLXBpbGwgYnRuLWluZm9cIj57e2RhdGEudmFsdWV9fTwvc3Bhbj48L2xpPlxuICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvdGg+XG4gICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8L25nLXRlbXBsYXRlPlxuXG4gIGAsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIFBuZ1RhYmxlU3VtbWFyeUNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMge1xuXG4gIEBJbnB1dCgpIGNvbHVtbnM6IFBuZ1RhYmxlQ29sdW1uUHJvcHM7XG5cbiAgQElucHV0KCkgYWdnVmFsdWVzOiB7fVtdO1xuXG4gIGNvbEFnZ1ZhbHVlczoge307XG5cbiAgY29uc3RydWN0b3IocHVibGljIHBuZ1RhYmxlOiBQbmdUYWJsZUNvbXBvbmVudCwgcHJvdGVjdGVkIGNkOiBDaGFuZ2VEZXRlY3RvclJlZikge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgaWYgKGNoYW5nZXMuYWdnVmFsdWVzKSB7XG4gICAgICBpZiAoY2hhbmdlcy5hZ2dWYWx1ZXMuY3VycmVudFZhbHVlKSB7XG4gICAgICAgIHRoaXMuY29sQWdnVmFsdWVzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKGNoYW5nZXMuYWdnVmFsdWVzLmN1cnJlbnRWYWx1ZSlcbiAgICAgICAgICAuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBrZXk7XG4gICAgICAgICAgICBpZiAoa2V5LmluZGV4T2YoJy0nKSA+IDApIHtcbiAgICAgICAgICAgICAgbmFtZSA9IGtleS5zdWJzdHIoMCwga2V5LmluZGV4T2YoJy0nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eXBlID0ga2V5LnN1YnN0cihrZXkuaW5kZXhPZignLScpICsgMSk7XG4gICAgICAgICAgICBsZXQgdmFsdWVzID0gdGhpcy5jb2xBZ2dWYWx1ZXNbbmFtZV07XG4gICAgICAgICAgICBpZiAoIXZhbHVlcykge1xuICAgICAgICAgICAgICB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgdGhpcy5jb2xBZ2dWYWx1ZXNbbmFtZV0gPSB2YWx1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhZ2cgPSB7fTtcbiAgICAgICAgICAgIGFnZ1sndHlwZSddID0gQWdnTWV0aG9kc1Byb3BzW3R5cGVdICYmIEFnZ01ldGhvZHNQcm9wc1t0eXBlXS5sYWJlbDtcbiAgICAgICAgICAgIGlmIChDb21tb25zVXRpbHMuaXNBcnJheSh0aGlzLmFnZ1ZhbHVlc1trZXldKSkge1xuICAgICAgICAgICAgICBhZ2dbJ3ZhbHVlcyddID0gdGhpcy5hZ2dWYWx1ZXNba2V5XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFnZ1sndmFsdWUnXSA9IHRoaXMuYWdnVmFsdWVzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChhZ2cpO1xuICAgICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb2xBZ2dWYWx1ZXMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB0aGlzLmNkLmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG4gIH1cblxuICBjZWxsQ2xhc3MoY29sdW1uKSB7XG4gICAgcmV0dXJuIENvbW1vbnNVdGlscy5nZXRWYWx1ZShjb2x1bW4uYWdnQ2VsbENsYXNzLCBjb2x1bW4pO1xuICB9XG5cbiAgY2VsbFN0eWxlKGNvbHVtbikge1xuICAgIHJldHVybiBDb21tb25zVXRpbHMuZ2V0VmFsdWUoY29sdW1uLmFnZ0NlbGxTdHlsZSwgY29sdW1uKTtcbiAgfVxufVxuIl19