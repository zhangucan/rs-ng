/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, Input, TemplateRef, ViewChild } from '@angular/core';
import { BaseComponent } from '@er/core';
import { CommonsUtils } from '@er/utils';
import { TableCheckbox } from 'primeng/table';
import { PngTableComponent } from '../table/component';
export class PngTableBodyRowComponent extends BaseComponent {
    /**
     * @param {?} pngTable
     * @param {?} cd
     */
    constructor(pngTable, cd) {
        super();
        this.pngTable = pngTable;
        this.cd = cd;
    }
    /**
     * @return {?}
     */
    get rowContext() {
        return {
            columns: this.columns,
            row: this.row,
            rowIndex: this.rowIndex,
            expanded: this.expanded,
            context: this.pngTable
        };
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.chk) {
            this.$subscriptions = this.chk.tableService.selectionSource$.subscribe(() => {
                this.cd.detectChanges();
            });
        }
    }
    /**
     * @param {?} col
     * @return {?}
     */
    colContext(col) {
        return Object.assign({}, this.rowContext, col);
    }
    /**
     * @param {?} col
     * @return {?}
     */
    getColStyleClass(col) {
        return CommonsUtils.getValue(col.styleClass, this.colContext(col));
    }
    /**
     * @param {?} col
     * @return {?}
     */
    getColStyle(col) {
        return CommonsUtils.getValue(col.style, this.colContext(col));
    }
}
PngTableBodyRowComponent.decorators = [
    { type: Component, args: [{
                selector: '[png-table-body-row]',
                template: `
    <ng-container *ngIf="customerTpl;else default">
      <ng-container *ngTemplateOutlet="customerTpl;context:rowContext"></ng-container>
    </ng-container>
    <ng-template #default>
      <tr *ngIf="rowHeaderTpl">
        <ng-container *ngTemplateOutlet="rowHeaderTpl;context:rowContext"></ng-container>
      </tr>
      <td *ngIf="pngTable.$props.$ext.rowExpandable" class="col-expandable">
        <a href="#" [pRowToggler]="row">
          <i [ngClass]="expanded ? 'pi pi-chevron-down' : 'pi pi-chevron-right'"></i>
        </a>
      </td>
      <td *ngIf="pngTable.$props.$ext.hasRowCheckbox" class="col-checkbox">
        <p-tableCheckbox #chk [value]="row"></p-tableCheckbox>
      </td>
      <td *ngIf="pngTable.$props.$ext.hasRowRadioButton" class="col-radio">
        <p-tableRadioButton [value]="row"></p-tableRadioButton>
      </td>
      <ng-container *ngFor="let col of columns">
        <td png-table-body-cell class="col-data col-data-{{col.key}}"
            [ngClass]="getColStyleClass(col)"
            [ngStyle]="getColStyle(col)"
            [customerTpl]="cellTpl"
            [column]="col"
            [row]="row"
            [rowIndex]="rowIndex"
            [dataCellTpl]="dataCellTpl"
        >
        </td>
      </ng-container>
      <tr *ngIf="rowFooterTpl">
        <ng-container *ngTemplateOutlet="rowFooterTpl;context:rowContext"></ng-container>
      </tr>
    </ng-template>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
PngTableBodyRowComponent.ctorParameters = () => [
    { type: PngTableComponent },
    { type: ChangeDetectorRef }
];
PngTableBodyRowComponent.propDecorators = {
    columns: [{ type: Input }],
    row: [{ type: Input }],
    rowIndex: [{ type: Input }],
    expanded: [{ type: Input }],
    rowHeaderTpl: [{ type: Input }],
    rowFooterTpl: [{ type: Input }],
    cellTpl: [{ type: Input }],
    dataCellTpl: [{ type: Input }],
    chk: [{ type: ViewChild, args: ['chk',] }]
};
if (false) {
    /** @type {?} */
    PngTableBodyRowComponent.prototype.columns;
    /** @type {?} */
    PngTableBodyRowComponent.prototype.row;
    /** @type {?} */
    PngTableBodyRowComponent.prototype.rowIndex;
    /** @type {?} */
    PngTableBodyRowComponent.prototype.expanded;
    /** @type {?} */
    PngTableBodyRowComponent.prototype.rowHeaderTpl;
    /** @type {?} */
    PngTableBodyRowComponent.prototype.rowFooterTpl;
    /** @type {?} */
    PngTableBodyRowComponent.prototype.cellTpl;
    /** @type {?} */
    PngTableBodyRowComponent.prototype.dataCellTpl;
    /** @type {?} */
    PngTableBodyRowComponent.prototype.chk;
    /** @type {?} */
    PngTableBodyRowComponent.prototype.pngTable;
    /**
     * @type {?}
     * @private
     */
    PngTableBodyRowComponent.prototype.cd;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGVyL3ByaW1lbmcvIiwic291cmNlcyI6WyJsaWIvY29tcG9uZW50cy90YWJsZS9jb21wb25lbnQvYm9keS1yb3cvY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQWdCLHVCQUF1QixFQUFFLGlCQUFpQixFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsV0FBVyxFQUFFLFNBQVMsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUNsSSxPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0sVUFBVSxDQUFDO0FBQ3ZDLE9BQU8sRUFBQyxZQUFZLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDdkMsT0FBTyxFQUFDLGFBQWEsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUU1QyxPQUFPLEVBQUMsaUJBQWlCLEVBQUMsTUFBTSxvQkFBb0IsQ0FBQztBQTJDckQsTUFBTSxPQUFPLHdCQUF5QixTQUFRLGFBQWE7Ozs7O0lBb0J6RCxZQUFtQixRQUEyQixFQUFVLEVBQXFCO1FBQzNFLEtBQUssRUFBRSxDQUFDO1FBRFMsYUFBUSxHQUFSLFFBQVEsQ0FBbUI7UUFBVSxPQUFFLEdBQUYsRUFBRSxDQUFtQjtJQUU3RSxDQUFDOzs7O0lBRUQsSUFBSSxVQUFVO1FBQ1osT0FBTztZQUNMLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTztZQUNyQixHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUc7WUFDYixRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVE7WUFDdkIsUUFBUSxFQUFFLElBQUksQ0FBQyxRQUFRO1lBQ3ZCLE9BQU8sRUFBRSxJQUFJLENBQUMsUUFBUTtTQUN2QixDQUFDO0lBQ0osQ0FBQzs7OztJQUVELGVBQWU7UUFDYixJQUFJLElBQUksQ0FBQyxHQUFHLEVBQUU7WUFDWixJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUU7Z0JBQzFFLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxFQUFFLENBQUM7WUFDMUIsQ0FBQyxDQUFDLENBQUM7U0FDSjtJQUNILENBQUM7Ozs7O0lBRUQsVUFBVSxDQUFDLEdBQUc7UUFDWix5QkFDSyxJQUFJLENBQUMsVUFBVSxFQUNmLEdBQUcsRUFDTjtJQUNKLENBQUM7Ozs7O0lBRUQsZ0JBQWdCLENBQUMsR0FBRztRQUNsQixPQUFPLFlBQVksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDckUsQ0FBQzs7Ozs7SUFFRCxXQUFXLENBQUMsR0FBRztRQUNiLE9BQU8sWUFBWSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUNoRSxDQUFDOzs7WUFoR0YsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxzQkFBc0I7Z0JBQ2hDLFFBQVEsRUFBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FtQ1Q7Z0JBQ0QsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07YUFDaEQ7Ozs7WUF6Q08saUJBQWlCO1lBTHVCLGlCQUFpQjs7O3NCQWtEOUQsS0FBSztrQkFFTCxLQUFLO3VCQUVMLEtBQUs7dUJBRUwsS0FBSzsyQkFFTCxLQUFLOzJCQUVMLEtBQUs7c0JBRUwsS0FBSzswQkFFTCxLQUFLO2tCQUVMLFNBQVMsU0FBQyxLQUFLOzs7O0lBaEJoQiwyQ0FBd0M7O0lBRXhDLHVDQUFtQjs7SUFFbkIsNENBQTBCOztJQUUxQiw0Q0FBMkI7O0lBRTNCLGdEQUF3Qzs7SUFFeEMsZ0RBQXdDOztJQUV4QywyQ0FBbUM7O0lBRW5DLCtDQUF1Qzs7SUFFdkMsdUNBQXFDOztJQUV6Qiw0Q0FBa0M7Ozs7O0lBQUUsc0NBQTZCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtBZnRlclZpZXdJbml0LCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ2hhbmdlRGV0ZWN0b3JSZWYsIENvbXBvbmVudCwgSW5wdXQsIFRlbXBsYXRlUmVmLCBWaWV3Q2hpbGR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICdAZXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbnNVdGlsc30gZnJvbSAnQGVyL3V0aWxzJztcbmltcG9ydCB7VGFibGVDaGVja2JveH0gZnJvbSAncHJpbWVuZy90YWJsZSc7XG5pbXBvcnQge1BuZ1RhYmxlQ29sdW1uUHJvcHN9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7UG5nVGFibGVDb21wb25lbnR9IGZyb20gJy4uL3RhYmxlL2NvbXBvbmVudCc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ1twbmctdGFibGUtYm9keS1yb3ddJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiY3VzdG9tZXJUcGw7ZWxzZSBkZWZhdWx0XCI+XG4gICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiY3VzdG9tZXJUcGw7Y29udGV4dDpyb3dDb250ZXh0XCI+PC9uZy1jb250YWluZXI+XG4gICAgPC9uZy1jb250YWluZXI+XG4gICAgPG5nLXRlbXBsYXRlICNkZWZhdWx0PlxuICAgICAgPHRyICpuZ0lmPVwicm93SGVhZGVyVHBsXCI+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJyb3dIZWFkZXJUcGw7Y29udGV4dDpyb3dDb250ZXh0XCI+PC9uZy1jb250YWluZXI+XG4gICAgICA8L3RyPlxuICAgICAgPHRkICpuZ0lmPVwicG5nVGFibGUuJHByb3BzLiRleHQucm93RXhwYW5kYWJsZVwiIGNsYXNzPVwiY29sLWV4cGFuZGFibGVcIj5cbiAgICAgICAgPGEgaHJlZj1cIiNcIiBbcFJvd1RvZ2dsZXJdPVwicm93XCI+XG4gICAgICAgICAgPGkgW25nQ2xhc3NdPVwiZXhwYW5kZWQgPyAncGkgcGktY2hldnJvbi1kb3duJyA6ICdwaSBwaS1jaGV2cm9uLXJpZ2h0J1wiPjwvaT5cbiAgICAgICAgPC9hPlxuICAgICAgPC90ZD5cbiAgICAgIDx0ZCAqbmdJZj1cInBuZ1RhYmxlLiRwcm9wcy4kZXh0Lmhhc1Jvd0NoZWNrYm94XCIgY2xhc3M9XCJjb2wtY2hlY2tib3hcIj5cbiAgICAgICAgPHAtdGFibGVDaGVja2JveCAjY2hrIFt2YWx1ZV09XCJyb3dcIj48L3AtdGFibGVDaGVja2JveD5cbiAgICAgIDwvdGQ+XG4gICAgICA8dGQgKm5nSWY9XCJwbmdUYWJsZS4kcHJvcHMuJGV4dC5oYXNSb3dSYWRpb0J1dHRvblwiIGNsYXNzPVwiY29sLXJhZGlvXCI+XG4gICAgICAgIDxwLXRhYmxlUmFkaW9CdXR0b24gW3ZhbHVlXT1cInJvd1wiPjwvcC10YWJsZVJhZGlvQnV0dG9uPlxuICAgICAgPC90ZD5cbiAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGNvbCBvZiBjb2x1bW5zXCI+XG4gICAgICAgIDx0ZCBwbmctdGFibGUtYm9keS1jZWxsIGNsYXNzPVwiY29sLWRhdGEgY29sLWRhdGEte3tjb2wua2V5fX1cIlxuICAgICAgICAgICAgW25nQ2xhc3NdPVwiZ2V0Q29sU3R5bGVDbGFzcyhjb2wpXCJcbiAgICAgICAgICAgIFtuZ1N0eWxlXT1cImdldENvbFN0eWxlKGNvbClcIlxuICAgICAgICAgICAgW2N1c3RvbWVyVHBsXT1cImNlbGxUcGxcIlxuICAgICAgICAgICAgW2NvbHVtbl09XCJjb2xcIlxuICAgICAgICAgICAgW3Jvd109XCJyb3dcIlxuICAgICAgICAgICAgW3Jvd0luZGV4XT1cInJvd0luZGV4XCJcbiAgICAgICAgICAgIFtkYXRhQ2VsbFRwbF09XCJkYXRhQ2VsbFRwbFwiXG4gICAgICAgID5cbiAgICAgICAgPC90ZD5cbiAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgPHRyICpuZ0lmPVwicm93Rm9vdGVyVHBsXCI+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJyb3dGb290ZXJUcGw7Y29udGV4dDpyb3dDb250ZXh0XCI+PC9uZy1jb250YWluZXI+XG4gICAgICA8L3RyPlxuICAgIDwvbmctdGVtcGxhdGU+XG4gIGAsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuXG5leHBvcnQgY2xhc3MgUG5nVGFibGVCb2R5Um93Q29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQge1xuXG4gIEBJbnB1dCgpIGNvbHVtbnM6IFBuZ1RhYmxlQ29sdW1uUHJvcHNbXTtcblxuICBASW5wdXQoKSByb3c6IHt9W107XG5cbiAgQElucHV0KCkgcm93SW5kZXg6IG51bWJlcjtcblxuICBASW5wdXQoKSBleHBhbmRlZDogYm9vbGVhbjtcblxuICBASW5wdXQoKSByb3dIZWFkZXJUcGw6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgQElucHV0KCkgcm93Rm9vdGVyVHBsOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gIEBJbnB1dCgpIGNlbGxUcGw6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgQElucHV0KCkgZGF0YUNlbGxUcGw6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgQFZpZXdDaGlsZCgnY2hrJykgY2hrOiBUYWJsZUNoZWNrYm94O1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBwbmdUYWJsZTogUG5nVGFibGVDb21wb25lbnQsIHByaXZhdGUgY2Q6IENoYW5nZURldGVjdG9yUmVmKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIGdldCByb3dDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb2x1bW5zOiB0aGlzLmNvbHVtbnMsXG4gICAgICByb3c6IHRoaXMucm93LFxuICAgICAgcm93SW5kZXg6IHRoaXMucm93SW5kZXgsXG4gICAgICBleHBhbmRlZDogdGhpcy5leHBhbmRlZCxcbiAgICAgIGNvbnRleHQ6IHRoaXMucG5nVGFibGVcbiAgICB9O1xuICB9XG5cbiAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNoaykge1xuICAgICAgdGhpcy4kc3Vic2NyaXB0aW9ucyA9IHRoaXMuY2hrLnRhYmxlU2VydmljZS5zZWxlY3Rpb25Tb3VyY2UkLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuY2QuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgY29sQ29udGV4dChjb2wpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udGhpcy5yb3dDb250ZXh0LFxuICAgICAgLi4uY29sXG4gICAgfTtcbiAgfVxuXG4gIGdldENvbFN0eWxlQ2xhc3MoY29sKSB7XG4gICAgcmV0dXJuIENvbW1vbnNVdGlscy5nZXRWYWx1ZShjb2wuc3R5bGVDbGFzcywgdGhpcy5jb2xDb250ZXh0KGNvbCkpO1xuICB9XG5cbiAgZ2V0Q29sU3R5bGUoY29sKSB7XG4gICAgcmV0dXJuIENvbW1vbnNVdGlscy5nZXRWYWx1ZShjb2wuc3R5bGUsIHRoaXMuY29sQ29udGV4dChjb2wpKTtcbiAgfVxufVxuIl19