import { ErCoreModule } from '@er/core';
import { Component, forwardRef, Inject, Injectable, NgModule, defineInjectable, inject } from '@angular/core';
import { Ng2ImgMaxService, Ng2ImgMaxModule } from 'ng2-img-max';
import { Subject } from 'rxjs';
import { Ng2ImgMaxService as Ng2ImgMaxService$1 } from 'ng2-img-max/dist/src/ng2-img-max.service';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ImageEditorComponent = /** @class */ (function () {
    function ImageEditorComponent() {
    }
    ImageEditorComponent.decorators = [
        { type: Component, args: [{
                    selector: 'er-image-editor',
                    template: ""
                }] }
    ];
    return ImageEditorComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ImgCropService = /** @class */ (function () {
    function ImgCropService(ng2ImgMaxService) {
        this.ng2ImgMaxService = ng2ImgMaxService;
    }
    /**
     * @param {?} file
     * @param {?} toWidth
     * @param {?} toHeight
     * @param {?=} startX
     * @param {?=} startY
     * @return {?}
     */
    ImgCropService.prototype.cropImage = /**
     * @param {?} file
     * @param {?} toWidth
     * @param {?} toHeight
     * @param {?=} startX
     * @param {?=} startY
     * @return {?}
     */
    function (file, toWidth, toHeight, startX, startY) {
        var _this = this;
        if (startX === void 0) { startX = 0; }
        if (startY === void 0) { startY = 0; }
        /** @type {?} */
        var croppedImageSubject = new Subject();
        if (file.type !== 'image/jpeg' && file.type !== 'image/png') {
            // END OF CROPPING
            setTimeout(function () {
                croppedImageSubject.error({
                    croppedFile: file,
                    reason: 'File provided is neither of type jpg nor of type png.',
                    error: 'INVALID_EXTENSION'
                });
            }, 0);
            return croppedImageSubject.asObservable();
        }
        /** @type {?} */
        var cvs = document.createElement('canvas');
        /** @type {?} */
        var ctx = cvs.getContext('2d');
        /** @type {?} */
        var img = new Image();
        img.onload = function () {
            _this.ng2ImgMaxService.getEXIFOrientedImage(img).then(function (orientedImg) {
                window.URL.revokeObjectURL(img.src);
                cvs.width = toWidth;
                cvs.height = toHeight;
                ctx.drawImage(orientedImg, startX, startY, toWidth, toHeight, 0, 0, toWidth, toHeight);
                /** @type {?} */
                var imageData = ctx.getImageData(0, 0, orientedImg.width, orientedImg.height);
                /** @type {?} */
                var useAlpha = true;
                if (file.type === 'image/jpeg' || (file.type === 'image/png' && !_this.isImgUsingAlpha(imageData))) {
                    // image without alpha
                    useAlpha = false;
                    ctx = cvs.getContext('2d', { 'alpha': false });
                    ctx.drawImage(orientedImg, startX, startY, toWidth, toHeight, 0, 0, toWidth, toHeight);
                }
                cvs.toBlob(function (blob) {
                    /** @type {?} */
                    var newFile = _this.generateResultFile(blob, file.name, file.type, new Date().getTime());
                    // END OF CROPPING
                    croppedImageSubject.next(newFile);
                }, useAlpha ? 'image/png' : 'image/jpeg');
            });
        };
        img.src = window.URL.createObjectURL(file);
        return croppedImageSubject.asObservable();
    };
    /**
     * @private
     * @param {?} imageData
     * @return {?}
     */
    ImgCropService.prototype.isImgUsingAlpha = /**
     * @private
     * @param {?} imageData
     * @return {?}
     */
    function (imageData) {
        for (var i = 0; i < imageData.data.length; i += 4) {
            if (imageData.data[i + 3] !== 255) {
                return true;
            }
        }
        return false;
    };
    /**
     * @private
     * @param {?} blob
     * @param {?} name
     * @param {?} type
     * @param {?} lastModified
     * @return {?}
     */
    ImgCropService.prototype.generateResultFile = /**
     * @private
     * @param {?} blob
     * @param {?} name
     * @param {?} type
     * @param {?} lastModified
     * @return {?}
     */
    function (blob, name, type, lastModified) {
        /** @type {?} */
        var resultFile = new Blob([blob], { type: type });
        return this.blobToFile(resultFile, name, lastModified);
    };
    /**
     * @private
     * @param {?} blob
     * @param {?} name
     * @param {?} lastModified
     * @return {?}
     */
    ImgCropService.prototype.blobToFile = /**
     * @private
     * @param {?} blob
     * @param {?} name
     * @param {?} lastModified
     * @return {?}
     */
    function (blob, name, lastModified) {
        /** @type {?} */
        var file = blob;
        file.name = name;
        file.lastModified = lastModified;
        // Cast to a File() type
        return (/** @type {?} */ (file));
    };
    ImgCropService.decorators = [
        { type: Injectable, args: [{ providedIn: 'root' },] }
    ];
    /** @nocollapse */
    ImgCropService.ctorParameters = function () { return [
        { type: Ng2ImgMaxService, decorators: [{ type: Inject, args: [forwardRef(function () { return Ng2ImgMaxService; }),] }] }
    ]; };
    /** @nocollapse */ ImgCropService.ngInjectableDef = defineInjectable({ factory: function ImgCropService_Factory() { return new ImgCropService(inject(Ng2ImgMaxService$1)); }, token: ImgCropService, providedIn: "root" });
    return ImgCropService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ImgResizeExactService = /** @class */ (function () {
    function ImgResizeExactService(ng2ImgMaxService, imgCropService) {
        this.ng2ImgMaxService = ng2ImgMaxService;
        this.imgCropService = imgCropService;
    }
    /**
     * @param {?} file
     * @param {?} toWidth
     * @param {?} toHeight
     * @param {?=} fillColor
     * @return {?}
     */
    ImgResizeExactService.prototype.resizeExactFill = /**
     * @param {?} file
     * @param {?} toWidth
     * @param {?} toHeight
     * @param {?=} fillColor
     * @return {?}
     */
    function (file, toWidth, toHeight, fillColor) {
        var _this = this;
        /** @type {?} */
        var resizedImageSubject = new Subject();
        if (file.type !== 'image/jpeg' && file.type !== 'image/png') {
            setTimeout(function () {
                resizedImageSubject.error({
                    resizedFile: file,
                    reason: 'File provided is neither of type jpg nor of type png.',
                    error: 'INVALID_EXTENSION'
                });
            }, 0);
            return resizedImageSubject.asObservable();
        }
        /** @type {?} */
        var img = new Image();
        img.onload = function () {
            _this.ng2ImgMaxService.getEXIFOrientedImage(img).then(function (orientedImg) {
                window.URL.revokeObjectURL(img.src);
                /** @type {?} */
                var imgRatio = orientedImg.width / orientedImg.height;
                /** @type {?} */
                var resizedRatio = toWidth / toHeight;
                /* ratio > 1 means width > height */
                /* setting one parameter of ng2ImgMaxService very high will ensure that the resizing will fit the other provided parameter */
                /** @type {?} */
                var resizeHeight = 100000;
                /** @type {?} */
                var resizeWidth = 100000;
                if (imgRatio > resizedRatio) {
                    /* the original height is smaller than the resized height as in ratio, therefore we have to resize to width, then fill to the height */
                    resizeWidth = toWidth;
                }
                else if (imgRatio <= resizedRatio) {
                    /* the original height is bigger than the resized height as in ratio, therefore we can resize to height, then fill to the width */
                    resizeHeight = toHeight;
                }
                _this.ng2ImgMaxService.resize([file], resizeWidth, resizeHeight).subscribe(function (resizeResult) {
                    /* To fill the image based on the center, we calculate where the img needs to be positioned to be centered*/
                    /** @type {?} */
                    var startX = 0;
                    /** @type {?} */
                    var startY = 0;
                    /* one side is already resized exactly to the desired size, now fill the other side */
                    if (resizeWidth === 100000) {
                        /* resized to height -> as we fill to the width, we have to set startX */
                        /** @type {?} */
                        var newImgWidth = orientedImg.width / (orientedImg.height / toHeight);
                        startX = (newImgWidth - toWidth) / 2;
                    }
                    else if (resizeHeight === 100000) {
                        /* resized to width -> as we fill to the height, we have to set startY */
                        /** @type {?} */
                        var newImgHeight = orientedImg.height / (orientedImg.width / toWidth);
                        startY = (newImgHeight - toHeight) / 2;
                    }
                    /** @type {?} */
                    var img = new Image();
                    /** @type {?} */
                    var cvs = document.createElement('canvas');
                    /** @type {?} */
                    var ctx = cvs.getContext('2d');
                    img.onload = function () {
                        cvs.width = toWidth;
                        cvs.height = toHeight;
                        if (fillColor) {
                            ctx.fillStyle = fillColor;
                            ctx.fillRect(0, 0, toWidth, toHeight);
                        }
                        ctx.drawImage(img, startX, startY, toWidth, toHeight, 0, 0, toWidth, toHeight);
                        /** @type {?} */
                        var imageData = ctx.getImageData(0, 0, toWidth, toHeight);
                        /** @type {?} */
                        var useAlpha = true;
                        if (file.type === 'image/jpeg' || (file.type === 'image/png' && !_this.isImgUsingAlpha(imageData))) {
                            // image without alpha
                            useAlpha = false;
                            ctx = cvs.getContext('2d', { 'alpha': false });
                            if (fillColor) {
                                ctx.fillStyle = fillColor;
                                ctx.fillRect(0, 0, toWidth, toHeight);
                            }
                            ctx.drawImage(img, startX, startY, toWidth, toHeight, 0, 0, toWidth, toHeight);
                        }
                        cvs.toBlob(function (blob) {
                            window.URL.revokeObjectURL(img.src);
                            /** @type {?} */
                            var newFile = _this.generateResultFile(blob, file.name, file.type, new Date().getTime());
                            // END OF CROPPING
                            resizedImageSubject.next(newFile);
                        }, useAlpha ? 'image/png' : 'image/jpeg');
                    };
                    img.src = window.URL.createObjectURL(resizeResult);
                }, function (error) {
                    // something went wrong
                    resizedImageSubject.error(error);
                });
            });
        };
        img.src = window.URL.createObjectURL(file);
        return resizedImageSubject.asObservable();
    };
    /**
     * @param {?} file
     * @param {?} toWidth
     * @param {?} toHeight
     * @return {?}
     */
    ImgResizeExactService.prototype.resizeExactCrop = /**
     * @param {?} file
     * @param {?} toWidth
     * @param {?} toHeight
     * @return {?}
     */
    function (file, toWidth, toHeight) {
        var _this = this;
        /** @type {?} */
        var resizedImageSubject = new Subject();
        if (file.type !== 'image/jpeg' && file.type !== 'image/png') {
            setTimeout(function () {
                resizedImageSubject.error({
                    resizedFile: file,
                    reason: 'File provided is neither of type jpg nor of type png.',
                    error: 'INVALID_EXTENSION'
                });
            }, 0);
            return resizedImageSubject.asObservable();
        }
        /** @type {?} */
        var img = new Image();
        img.onload = function () {
            _this.ng2ImgMaxService.getEXIFOrientedImage(img).then(function (orientedImg) {
                window.URL.revokeObjectURL(img.src);
                /** @type {?} */
                var imgRatio = orientedImg.width / orientedImg.height;
                /** @type {?} */
                var resizedRatio = toWidth / toHeight;
                /* ratio > 1 means width > height */
                /* setting one parameter of ng2ImgMaxService very high will ensure that the resizing will fit the other provided parameter */
                /** @type {?} */
                var resizeHeight = 100000;
                /** @type {?} */
                var resizeWidth = 100000;
                /* To crop the image based on the center, so we will keep the most important part of the image, we calculate to crop from where to where */
                /** @type {?} */
                var startX = 0;
                /** @type {?} */
                var startY = 0;
                if (imgRatio > resizedRatio) {
                    /* the original height is smaller than the resized height as in ratio, therefore we have to resize to height, then crop to the width */
                    resizeHeight = toHeight;
                }
                else if (imgRatio <= resizedRatio) {
                    /* the original height is bigger than the resized height as in ratio, therefore we can resize to width, then crop to the height */
                    resizeWidth = toWidth;
                }
                _this.ng2ImgMaxService.resize([file], resizeWidth, resizeHeight).subscribe(function (resizeResult) {
                    /* one side is already resized exactly to the desired size, now crop the other side */
                    if (resizeWidth === 100000) {
                        /* resized to height -> as we crop to the width, we have to set startX */
                        /** @type {?} */
                        var newImgWidth = orientedImg.width / (orientedImg.height / toHeight);
                        startX = (newImgWidth - toWidth) / 2;
                    }
                    else if (resizeHeight === 100000) {
                        /* resized to width -> as we crop to the height, we have to set startY */
                        /** @type {?} */
                        var newImgHeight = orientedImg.height / (orientedImg.width / toWidth);
                        startY = (newImgHeight - toHeight) / 2;
                    }
                    _this.imgCropService.cropImage(resizeResult, toWidth, toHeight, startX, startY).subscribe(function (cropResult) {
                        // all good, result is a file
                        resizedImageSubject.next(cropResult);
                    }, function (error) {
                        // something went wrong
                        resizedImageSubject.error(error);
                    });
                }, function (error) {
                    // something went wrong
                    resizedImageSubject.error(error);
                });
            });
        };
        img.src = window.URL.createObjectURL(file);
        return resizedImageSubject.asObservable();
    };
    /**
     * @private
     * @param {?} imageData
     * @return {?}
     */
    ImgResizeExactService.prototype.isImgUsingAlpha = /**
     * @private
     * @param {?} imageData
     * @return {?}
     */
    function (imageData) {
        for (var i = 0; i < imageData.data.length; i += 4) {
            if (imageData.data[i + 3] !== 255) {
                return true;
            }
        }
        return false;
    };
    /**
     * @private
     * @param {?} blob
     * @param {?} name
     * @param {?} type
     * @param {?} lastModified
     * @return {?}
     */
    ImgResizeExactService.prototype.generateResultFile = /**
     * @private
     * @param {?} blob
     * @param {?} name
     * @param {?} type
     * @param {?} lastModified
     * @return {?}
     */
    function (blob, name, type, lastModified) {
        /** @type {?} */
        var resultFile = new Blob([blob], { type: type });
        return this.blobToFile(resultFile, name, lastModified);
    };
    /**
     * @private
     * @param {?} blob
     * @param {?} name
     * @param {?} lastModified
     * @return {?}
     */
    ImgResizeExactService.prototype.blobToFile = /**
     * @private
     * @param {?} blob
     * @param {?} name
     * @param {?} lastModified
     * @return {?}
     */
    function (blob, name, lastModified) {
        /** @type {?} */
        var file = blob;
        file.name = name;
        file.lastModified = lastModified;
        // Cast to a File() type
        return (/** @type {?} */ (file));
    };
    ImgResizeExactService.decorators = [
        { type: Injectable, args: [{ providedIn: 'root' },] }
    ];
    /** @nocollapse */
    ImgResizeExactService.ctorParameters = function () { return [
        { type: Ng2ImgMaxService, decorators: [{ type: Inject, args: [forwardRef(function () { return Ng2ImgMaxService; }),] }] },
        { type: ImgCropService, decorators: [{ type: Inject, args: [forwardRef(function () { return ImgCropService; }),] }] }
    ]; };
    /** @nocollapse */ ImgResizeExactService.ngInjectableDef = defineInjectable({ factory: function ImgResizeExactService_Factory() { return new ImgResizeExactService(inject(Ng2ImgMaxService$1), inject(ImgCropService)); }, token: ImgResizeExactService, providedIn: "root" });
    return ImgResizeExactService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ImageToolsService = /** @class */ (function () {
    function ImageToolsService(imgResizeExactService, ng2ImgMaxService, imgCropService) {
        this.imgResizeExactService = imgResizeExactService;
        this.ng2ImgMaxService = ng2ImgMaxService;
        this.imgCropService = imgCropService;
    }
    /**
     * @param {?} files
     * @param {?} maxSizeInMB
     * @param {?=} ignoreAlpha
     * @param {?=} logExecutionTime
     * @return {?}
     */
    ImageToolsService.prototype.compress = /**
     * @param {?} files
     * @param {?} maxSizeInMB
     * @param {?=} ignoreAlpha
     * @param {?=} logExecutionTime
     * @return {?}
     */
    function (files, maxSizeInMB, ignoreAlpha, logExecutionTime) {
        if (ignoreAlpha === void 0) { ignoreAlpha = false; }
        if (logExecutionTime === void 0) { logExecutionTime = false; }
        return this.ng2ImgMaxService.compress(files, maxSizeInMB, ignoreAlpha, logExecutionTime);
    };
    /**
     * @param {?} files
     * @param {?} maxWidth
     * @param {?} maxHeight
     * @param {?=} logExecutionTime
     * @return {?}
     */
    ImageToolsService.prototype.resize = /**
     * @param {?} files
     * @param {?} maxWidth
     * @param {?} maxHeight
     * @param {?=} logExecutionTime
     * @return {?}
     */
    function (files, maxWidth, maxHeight, logExecutionTime) {
        if (logExecutionTime === void 0) { logExecutionTime = false; }
        return this.ng2ImgMaxService.resize(files, maxWidth, maxHeight, logExecutionTime);
    };
    /**
     * @param {?} files
     * @param {?} toWidth
     * @param {?} toHeight
     * @param {?=} startX
     * @param {?=} startY
     * @return {?}
     */
    ImageToolsService.prototype.crop = /**
     * @param {?} files
     * @param {?} toWidth
     * @param {?} toHeight
     * @param {?=} startX
     * @param {?=} startY
     * @return {?}
     */
    function (files, toWidth, toHeight, startX, startY) {
        var _this = this;
        if (startX === void 0) { startX = 0; }
        if (startY === void 0) { startY = 0; }
        /** @type {?} */
        var croppedFileSubject = new Subject();
        files.forEach(function (file) {
            _this.cropImage(file, toWidth, toHeight, startX, startY).subscribe(function (value) {
                croppedFileSubject.next(value);
            }, function (error) {
                croppedFileSubject.error(error);
            });
        });
        return croppedFileSubject.asObservable();
    };
    /**
     * @param {?} files
     * @param {?} toWidth
     * @param {?} toHeight
     * @return {?}
     */
    ImageToolsService.prototype.resizeExactCrop = /**
     * @param {?} files
     * @param {?} toWidth
     * @param {?} toHeight
     * @return {?}
     */
    function (files, toWidth, toHeight) {
        var _this = this;
        /** @type {?} */
        var resizedFileSubject = new Subject();
        files.forEach(function (file) {
            _this.resizeExactCropImage(file, toWidth, toHeight).subscribe(function (value) {
                resizedFileSubject.next(value);
            }, function (error) {
                resizedFileSubject.error(error);
            });
        });
        return resizedFileSubject.asObservable();
    };
    /**
     * @param {?} files
     * @param {?} toWidth
     * @param {?} toHeight
     * @param {?=} fillColor
     * @return {?}
     */
    ImageToolsService.prototype.resizeExactFill = /**
     * @param {?} files
     * @param {?} toWidth
     * @param {?} toHeight
     * @param {?=} fillColor
     * @return {?}
     */
    function (files, toWidth, toHeight, fillColor) {
        var _this = this;
        /** @type {?} */
        var resizedFileSubject = new Subject();
        files.forEach(function (file) {
            _this.resizeExactFillImage(file, toWidth, toHeight, fillColor).subscribe(function (value) {
                resizedFileSubject.next(value);
            }, function (error) {
                resizedFileSubject.error(error);
            });
        });
        return resizedFileSubject.asObservable();
    };
    /**
     * @param {?} file
     * @param {?} toWidth
     * @param {?} toHeight
     * @param {?=} fillColor
     * @return {?}
     */
    ImageToolsService.prototype.resizeExactFillImage = /**
     * @param {?} file
     * @param {?} toWidth
     * @param {?} toHeight
     * @param {?=} fillColor
     * @return {?}
     */
    function (file, toWidth, toHeight, fillColor) {
        return this.imgResizeExactService.resizeExactFill(file, toWidth, toHeight, fillColor);
    };
    /**
     * @param {?} file
     * @param {?} toWidth
     * @param {?} toHeight
     * @return {?}
     */
    ImageToolsService.prototype.resizeExactCropImage = /**
     * @param {?} file
     * @param {?} toWidth
     * @param {?} toHeight
     * @return {?}
     */
    function (file, toWidth, toHeight) {
        return this.imgResizeExactService.resizeExactCrop(file, toWidth, toHeight);
    };
    /**
     * @param {?} file
     * @param {?} toWidth
     * @param {?} toHeight
     * @param {?=} startX
     * @param {?=} startY
     * @return {?}
     */
    ImageToolsService.prototype.cropImage = /**
     * @param {?} file
     * @param {?} toWidth
     * @param {?} toHeight
     * @param {?=} startX
     * @param {?=} startY
     * @return {?}
     */
    function (file, toWidth, toHeight, startX, startY) {
        if (startX === void 0) { startX = 0; }
        if (startY === void 0) { startY = 0; }
        return this.imgCropService.cropImage(file, toWidth, toHeight, startX, startY);
    };
    /**
     * @param {?} file
     * @param {?} maxSizeInMB
     * @param {?=} ignoreAlpha
     * @param {?=} logExecutionTime
     * @return {?}
     */
    ImageToolsService.prototype.compressImage = /**
     * @param {?} file
     * @param {?} maxSizeInMB
     * @param {?=} ignoreAlpha
     * @param {?=} logExecutionTime
     * @return {?}
     */
    function (file, maxSizeInMB, ignoreAlpha, logExecutionTime) {
        if (ignoreAlpha === void 0) { ignoreAlpha = false; }
        if (logExecutionTime === void 0) { logExecutionTime = false; }
        return this.ng2ImgMaxService.compressImage(file, maxSizeInMB, ignoreAlpha, logExecutionTime);
    };
    /**
     * @param {?} file
     * @param {?} maxWidth
     * @param {?} maxHeight
     * @param {?=} logExecutionTime
     * @return {?}
     */
    ImageToolsService.prototype.resizeImage = /**
     * @param {?} file
     * @param {?} maxWidth
     * @param {?} maxHeight
     * @param {?=} logExecutionTime
     * @return {?}
     */
    function (file, maxWidth, maxHeight, logExecutionTime) {
        if (logExecutionTime === void 0) { logExecutionTime = false; }
        return this.ng2ImgMaxService.resizeImage(file, maxWidth, maxHeight, logExecutionTime);
    };
    /**
     * @param {?} image
     * @return {?}
     */
    ImageToolsService.prototype.getEXIFOrientedImage = /**
     * @param {?} image
     * @return {?}
     */
    function (image) {
        return this.ng2ImgMaxService.getEXIFOrientedImage(image);
    };
    ImageToolsService.decorators = [
        { type: Injectable, args: [{ providedIn: 'root' },] }
    ];
    /** @nocollapse */
    ImageToolsService.ctorParameters = function () { return [
        { type: ImgResizeExactService, decorators: [{ type: Inject, args: [forwardRef(function () { return ImgResizeExactService; }),] }] },
        { type: Ng2ImgMaxService, decorators: [{ type: Inject, args: [forwardRef(function () { return Ng2ImgMaxService; }),] }] },
        { type: ImgCropService, decorators: [{ type: Inject, args: [forwardRef(function () { return ImgCropService; }),] }] }
    ]; };
    /** @nocollapse */ ImageToolsService.ngInjectableDef = defineInjectable({ factory: function ImageToolsService_Factory() { return new ImageToolsService(inject(ImgResizeExactService), inject(Ng2ImgMaxService$1), inject(ImgCropService)); }, token: ImageToolsService, providedIn: "root" });
    return ImageToolsService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ErImageEditorModule = /** @class */ (function () {
    function ErImageEditorModule() {
    }
    ErImageEditorModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        ErCoreModule,
                        Ng2ImgMaxModule
                    ],
                    declarations: [
                        ImageEditorComponent
                    ],
                    providers: [
                        { provide: ImgResizeExactService, useClass: ImgResizeExactService },
                        { provide: ImgCropService, useClass: ImgCropService },
                        { provide: ImageToolsService, useClass: ImageToolsService },
                        { provide: Ng2ImgMaxService, useClass: Ng2ImgMaxService }
                    ],
                    exports: [
                        ImageEditorComponent
                    ]
                },] }
    ];
    return ErImageEditorModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { ImageToolsService, ImgCropService, ImgResizeExactService, ErImageEditorModule, ImageEditorComponent as ɵa };

//# sourceMappingURL=er-share.js.map