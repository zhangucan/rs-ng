import { ErCoreModule } from '@er/core';
import { Component, forwardRef, Inject, Injectable, NgModule, defineInjectable, inject } from '@angular/core';
import { Ng2ImgMaxService, Ng2ImgMaxModule } from 'ng2-img-max';
import { Subject } from 'rxjs';
import { Ng2ImgMaxService as Ng2ImgMaxService$1 } from 'ng2-img-max/dist/src/ng2-img-max.service';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ImageEditorComponent {
}
ImageEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'er-image-editor',
                template: ``
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ImgCropService {
    /**
     * @param {?} ng2ImgMaxService
     */
    constructor(ng2ImgMaxService) {
        this.ng2ImgMaxService = ng2ImgMaxService;
    }
    /**
     * @param {?} file
     * @param {?} toWidth
     * @param {?} toHeight
     * @param {?=} startX
     * @param {?=} startY
     * @return {?}
     */
    cropImage(file, toWidth, toHeight, startX = 0, startY = 0) {
        /** @type {?} */
        const croppedImageSubject = new Subject();
        if (file.type !== 'image/jpeg' && file.type !== 'image/png') {
            // END OF CROPPING
            setTimeout(() => {
                croppedImageSubject.error({
                    croppedFile: file,
                    reason: 'File provided is neither of type jpg nor of type png.',
                    error: 'INVALID_EXTENSION'
                });
            }, 0);
            return croppedImageSubject.asObservable();
        }
        /** @type {?} */
        const cvs = document.createElement('canvas');
        /** @type {?} */
        let ctx = cvs.getContext('2d');
        /** @type {?} */
        const img = new Image();
        img.onload = () => {
            this.ng2ImgMaxService.getEXIFOrientedImage(img).then(orientedImg => {
                window.URL.revokeObjectURL(img.src);
                cvs.width = toWidth;
                cvs.height = toHeight;
                ctx.drawImage(orientedImg, startX, startY, toWidth, toHeight, 0, 0, toWidth, toHeight);
                /** @type {?} */
                const imageData = ctx.getImageData(0, 0, orientedImg.width, orientedImg.height);
                /** @type {?} */
                let useAlpha = true;
                if (file.type === 'image/jpeg' || (file.type === 'image/png' && !this.isImgUsingAlpha(imageData))) {
                    // image without alpha
                    useAlpha = false;
                    ctx = cvs.getContext('2d', { 'alpha': false });
                    ctx.drawImage(orientedImg, startX, startY, toWidth, toHeight, 0, 0, toWidth, toHeight);
                }
                cvs.toBlob((blob) => {
                    /** @type {?} */
                    const newFile = this.generateResultFile(blob, file.name, file.type, new Date().getTime());
                    // END OF CROPPING
                    croppedImageSubject.next(newFile);
                }, useAlpha ? 'image/png' : 'image/jpeg');
            });
        };
        img.src = window.URL.createObjectURL(file);
        return croppedImageSubject.asObservable();
    }
    /**
     * @private
     * @param {?} imageData
     * @return {?}
     */
    isImgUsingAlpha(imageData) {
        for (let i = 0; i < imageData.data.length; i += 4) {
            if (imageData.data[i + 3] !== 255) {
                return true;
            }
        }
        return false;
    }
    /**
     * @private
     * @param {?} blob
     * @param {?} name
     * @param {?} type
     * @param {?} lastModified
     * @return {?}
     */
    generateResultFile(blob, name, type, lastModified) {
        /** @type {?} */
        const resultFile = new Blob([blob], { type: type });
        return this.blobToFile(resultFile, name, lastModified);
    }
    /**
     * @private
     * @param {?} blob
     * @param {?} name
     * @param {?} lastModified
     * @return {?}
     */
    blobToFile(blob, name, lastModified) {
        /** @type {?} */
        const file = blob;
        file.name = name;
        file.lastModified = lastModified;
        // Cast to a File() type
        return (/** @type {?} */ (file));
    }
}
ImgCropService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
ImgCropService.ctorParameters = () => [
    { type: Ng2ImgMaxService, decorators: [{ type: Inject, args: [forwardRef(() => Ng2ImgMaxService),] }] }
];
/** @nocollapse */ ImgCropService.ngInjectableDef = defineInjectable({ factory: function ImgCropService_Factory() { return new ImgCropService(inject(Ng2ImgMaxService$1)); }, token: ImgCropService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ImgResizeExactService {
    /**
     * @param {?} ng2ImgMaxService
     * @param {?} imgCropService
     */
    constructor(ng2ImgMaxService, imgCropService) {
        this.ng2ImgMaxService = ng2ImgMaxService;
        this.imgCropService = imgCropService;
    }
    /**
     * @param {?} file
     * @param {?} toWidth
     * @param {?} toHeight
     * @param {?=} fillColor
     * @return {?}
     */
    resizeExactFill(file, toWidth, toHeight, fillColor) {
        /** @type {?} */
        const resizedImageSubject = new Subject();
        if (file.type !== 'image/jpeg' && file.type !== 'image/png') {
            setTimeout(() => {
                resizedImageSubject.error({
                    resizedFile: file,
                    reason: 'File provided is neither of type jpg nor of type png.',
                    error: 'INVALID_EXTENSION'
                });
            }, 0);
            return resizedImageSubject.asObservable();
        }
        /** @type {?} */
        const img = new Image();
        img.onload = () => {
            this.ng2ImgMaxService.getEXIFOrientedImage(img).then(orientedImg => {
                window.URL.revokeObjectURL(img.src);
                /** @type {?} */
                const imgRatio = orientedImg.width / orientedImg.height;
                /** @type {?} */
                const resizedRatio = toWidth / toHeight;
                /* ratio > 1 means width > height */
                /* setting one parameter of ng2ImgMaxService very high will ensure that the resizing will fit the other provided parameter */
                /** @type {?} */
                let resizeHeight = 100000;
                /** @type {?} */
                let resizeWidth = 100000;
                if (imgRatio > resizedRatio) {
                    /* the original height is smaller than the resized height as in ratio, therefore we have to resize to width, then fill to the height */
                    resizeWidth = toWidth;
                }
                else if (imgRatio <= resizedRatio) {
                    /* the original height is bigger than the resized height as in ratio, therefore we can resize to height, then fill to the width */
                    resizeHeight = toHeight;
                }
                this.ng2ImgMaxService.resize([file], resizeWidth, resizeHeight).subscribe((resizeResult) => {
                    /* To fill the image based on the center, we calculate where the img needs to be positioned to be centered*/
                    /** @type {?} */
                    let startX = 0;
                    /** @type {?} */
                    let startY = 0;
                    /* one side is already resized exactly to the desired size, now fill the other side */
                    if (resizeWidth === 100000) {
                        /* resized to height -> as we fill to the width, we have to set startX */
                        /** @type {?} */
                        const newImgWidth = orientedImg.width / (orientedImg.height / toHeight);
                        startX = (newImgWidth - toWidth) / 2;
                    }
                    else if (resizeHeight === 100000) {
                        /* resized to width -> as we fill to the height, we have to set startY */
                        /** @type {?} */
                        const newImgHeight = orientedImg.height / (orientedImg.width / toWidth);
                        startY = (newImgHeight - toHeight) / 2;
                    }
                    /** @type {?} */
                    const img = new Image();
                    /** @type {?} */
                    const cvs = document.createElement('canvas');
                    /** @type {?} */
                    let ctx = cvs.getContext('2d');
                    img.onload = () => {
                        cvs.width = toWidth;
                        cvs.height = toHeight;
                        if (fillColor) {
                            ctx.fillStyle = fillColor;
                            ctx.fillRect(0, 0, toWidth, toHeight);
                        }
                        ctx.drawImage(img, startX, startY, toWidth, toHeight, 0, 0, toWidth, toHeight);
                        /** @type {?} */
                        const imageData = ctx.getImageData(0, 0, toWidth, toHeight);
                        /** @type {?} */
                        let useAlpha = true;
                        if (file.type === 'image/jpeg' || (file.type === 'image/png' && !this.isImgUsingAlpha(imageData))) {
                            // image without alpha
                            useAlpha = false;
                            ctx = cvs.getContext('2d', { 'alpha': false });
                            if (fillColor) {
                                ctx.fillStyle = fillColor;
                                ctx.fillRect(0, 0, toWidth, toHeight);
                            }
                            ctx.drawImage(img, startX, startY, toWidth, toHeight, 0, 0, toWidth, toHeight);
                        }
                        cvs.toBlob((blob) => {
                            window.URL.revokeObjectURL(img.src);
                            /** @type {?} */
                            const newFile = this.generateResultFile(blob, file.name, file.type, new Date().getTime());
                            // END OF CROPPING
                            resizedImageSubject.next(newFile);
                        }, useAlpha ? 'image/png' : 'image/jpeg');
                    };
                    img.src = window.URL.createObjectURL(resizeResult);
                }, error => {
                    // something went wrong
                    resizedImageSubject.error(error);
                });
            });
        };
        img.src = window.URL.createObjectURL(file);
        return resizedImageSubject.asObservable();
    }
    /**
     * @param {?} file
     * @param {?} toWidth
     * @param {?} toHeight
     * @return {?}
     */
    resizeExactCrop(file, toWidth, toHeight) {
        /** @type {?} */
        const resizedImageSubject = new Subject();
        if (file.type !== 'image/jpeg' && file.type !== 'image/png') {
            setTimeout(() => {
                resizedImageSubject.error({
                    resizedFile: file,
                    reason: 'File provided is neither of type jpg nor of type png.',
                    error: 'INVALID_EXTENSION'
                });
            }, 0);
            return resizedImageSubject.asObservable();
        }
        /** @type {?} */
        const img = new Image();
        img.onload = () => {
            this.ng2ImgMaxService.getEXIFOrientedImage(img).then(orientedImg => {
                window.URL.revokeObjectURL(img.src);
                /** @type {?} */
                const imgRatio = orientedImg.width / orientedImg.height;
                /** @type {?} */
                const resizedRatio = toWidth / toHeight;
                /* ratio > 1 means width > height */
                /* setting one parameter of ng2ImgMaxService very high will ensure that the resizing will fit the other provided parameter */
                /** @type {?} */
                let resizeHeight = 100000;
                /** @type {?} */
                let resizeWidth = 100000;
                /* To crop the image based on the center, so we will keep the most important part of the image, we calculate to crop from where to where */
                /** @type {?} */
                let startX = 0;
                /** @type {?} */
                let startY = 0;
                if (imgRatio > resizedRatio) {
                    /* the original height is smaller than the resized height as in ratio, therefore we have to resize to height, then crop to the width */
                    resizeHeight = toHeight;
                }
                else if (imgRatio <= resizedRatio) {
                    /* the original height is bigger than the resized height as in ratio, therefore we can resize to width, then crop to the height */
                    resizeWidth = toWidth;
                }
                this.ng2ImgMaxService.resize([file], resizeWidth, resizeHeight).subscribe((resizeResult) => {
                    /* one side is already resized exactly to the desired size, now crop the other side */
                    if (resizeWidth === 100000) {
                        /* resized to height -> as we crop to the width, we have to set startX */
                        /** @type {?} */
                        const newImgWidth = orientedImg.width / (orientedImg.height / toHeight);
                        startX = (newImgWidth - toWidth) / 2;
                    }
                    else if (resizeHeight === 100000) {
                        /* resized to width -> as we crop to the height, we have to set startY */
                        /** @type {?} */
                        const newImgHeight = orientedImg.height / (orientedImg.width / toWidth);
                        startY = (newImgHeight - toHeight) / 2;
                    }
                    this.imgCropService.cropImage(resizeResult, toWidth, toHeight, startX, startY).subscribe((cropResult) => {
                        // all good, result is a file
                        resizedImageSubject.next(cropResult);
                    }, error => {
                        // something went wrong
                        resizedImageSubject.error(error);
                    });
                }, error => {
                    // something went wrong
                    resizedImageSubject.error(error);
                });
            });
        };
        img.src = window.URL.createObjectURL(file);
        return resizedImageSubject.asObservable();
    }
    /**
     * @private
     * @param {?} imageData
     * @return {?}
     */
    isImgUsingAlpha(imageData) {
        for (let i = 0; i < imageData.data.length; i += 4) {
            if (imageData.data[i + 3] !== 255) {
                return true;
            }
        }
        return false;
    }
    /**
     * @private
     * @param {?} blob
     * @param {?} name
     * @param {?} type
     * @param {?} lastModified
     * @return {?}
     */
    generateResultFile(blob, name, type, lastModified) {
        /** @type {?} */
        const resultFile = new Blob([blob], { type: type });
        return this.blobToFile(resultFile, name, lastModified);
    }
    /**
     * @private
     * @param {?} blob
     * @param {?} name
     * @param {?} lastModified
     * @return {?}
     */
    blobToFile(blob, name, lastModified) {
        /** @type {?} */
        const file = blob;
        file.name = name;
        file.lastModified = lastModified;
        // Cast to a File() type
        return (/** @type {?} */ (file));
    }
}
ImgResizeExactService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
ImgResizeExactService.ctorParameters = () => [
    { type: Ng2ImgMaxService, decorators: [{ type: Inject, args: [forwardRef(() => Ng2ImgMaxService),] }] },
    { type: ImgCropService, decorators: [{ type: Inject, args: [forwardRef(() => ImgCropService),] }] }
];
/** @nocollapse */ ImgResizeExactService.ngInjectableDef = defineInjectable({ factory: function ImgResizeExactService_Factory() { return new ImgResizeExactService(inject(Ng2ImgMaxService$1), inject(ImgCropService)); }, token: ImgResizeExactService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ImageToolsService {
    /**
     * @param {?} imgResizeExactService
     * @param {?} ng2ImgMaxService
     * @param {?} imgCropService
     */
    constructor(imgResizeExactService, ng2ImgMaxService, imgCropService) {
        this.imgResizeExactService = imgResizeExactService;
        this.ng2ImgMaxService = ng2ImgMaxService;
        this.imgCropService = imgCropService;
    }
    /**
     * @param {?} files
     * @param {?} maxSizeInMB
     * @param {?=} ignoreAlpha
     * @param {?=} logExecutionTime
     * @return {?}
     */
    compress(files, maxSizeInMB, ignoreAlpha = false, logExecutionTime = false) {
        return this.ng2ImgMaxService.compress(files, maxSizeInMB, ignoreAlpha, logExecutionTime);
    }
    /**
     * @param {?} files
     * @param {?} maxWidth
     * @param {?} maxHeight
     * @param {?=} logExecutionTime
     * @return {?}
     */
    resize(files, maxWidth, maxHeight, logExecutionTime = false) {
        return this.ng2ImgMaxService.resize(files, maxWidth, maxHeight, logExecutionTime);
    }
    /**
     * @param {?} files
     * @param {?} toWidth
     * @param {?} toHeight
     * @param {?=} startX
     * @param {?=} startY
     * @return {?}
     */
    crop(files, toWidth, toHeight, startX = 0, startY = 0) {
        /** @type {?} */
        const croppedFileSubject = new Subject();
        files.forEach((file) => {
            this.cropImage(file, toWidth, toHeight, startX, startY).subscribe((value) => {
                croppedFileSubject.next(value);
            }, error => {
                croppedFileSubject.error(error);
            });
        });
        return croppedFileSubject.asObservable();
    }
    /**
     * @param {?} files
     * @param {?} toWidth
     * @param {?} toHeight
     * @return {?}
     */
    resizeExactCrop(files, toWidth, toHeight) {
        /** @type {?} */
        const resizedFileSubject = new Subject();
        files.forEach((file) => {
            this.resizeExactCropImage(file, toWidth, toHeight).subscribe((value) => {
                resizedFileSubject.next(value);
            }, error => {
                resizedFileSubject.error(error);
            });
        });
        return resizedFileSubject.asObservable();
    }
    /**
     * @param {?} files
     * @param {?} toWidth
     * @param {?} toHeight
     * @param {?=} fillColor
     * @return {?}
     */
    resizeExactFill(files, toWidth, toHeight, fillColor) {
        /** @type {?} */
        const resizedFileSubject = new Subject();
        files.forEach((file) => {
            this.resizeExactFillImage(file, toWidth, toHeight, fillColor).subscribe((value) => {
                resizedFileSubject.next(value);
            }, error => {
                resizedFileSubject.error(error);
            });
        });
        return resizedFileSubject.asObservable();
    }
    /**
     * @param {?} file
     * @param {?} toWidth
     * @param {?} toHeight
     * @param {?=} fillColor
     * @return {?}
     */
    resizeExactFillImage(file, toWidth, toHeight, fillColor) {
        return this.imgResizeExactService.resizeExactFill(file, toWidth, toHeight, fillColor);
    }
    /**
     * @param {?} file
     * @param {?} toWidth
     * @param {?} toHeight
     * @return {?}
     */
    resizeExactCropImage(file, toWidth, toHeight) {
        return this.imgResizeExactService.resizeExactCrop(file, toWidth, toHeight);
    }
    /**
     * @param {?} file
     * @param {?} toWidth
     * @param {?} toHeight
     * @param {?=} startX
     * @param {?=} startY
     * @return {?}
     */
    cropImage(file, toWidth, toHeight, startX = 0, startY = 0) {
        return this.imgCropService.cropImage(file, toWidth, toHeight, startX, startY);
    }
    /**
     * @param {?} file
     * @param {?} maxSizeInMB
     * @param {?=} ignoreAlpha
     * @param {?=} logExecutionTime
     * @return {?}
     */
    compressImage(file, maxSizeInMB, ignoreAlpha = false, logExecutionTime = false) {
        return this.ng2ImgMaxService.compressImage(file, maxSizeInMB, ignoreAlpha, logExecutionTime);
    }
    /**
     * @param {?} file
     * @param {?} maxWidth
     * @param {?} maxHeight
     * @param {?=} logExecutionTime
     * @return {?}
     */
    resizeImage(file, maxWidth, maxHeight, logExecutionTime = false) {
        return this.ng2ImgMaxService.resizeImage(file, maxWidth, maxHeight, logExecutionTime);
    }
    /**
     * @param {?} image
     * @return {?}
     */
    getEXIFOrientedImage(image) {
        return this.ng2ImgMaxService.getEXIFOrientedImage(image);
    }
}
ImageToolsService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
ImageToolsService.ctorParameters = () => [
    { type: ImgResizeExactService, decorators: [{ type: Inject, args: [forwardRef(() => ImgResizeExactService),] }] },
    { type: Ng2ImgMaxService, decorators: [{ type: Inject, args: [forwardRef(() => Ng2ImgMaxService),] }] },
    { type: ImgCropService, decorators: [{ type: Inject, args: [forwardRef(() => ImgCropService),] }] }
];
/** @nocollapse */ ImageToolsService.ngInjectableDef = defineInjectable({ factory: function ImageToolsService_Factory() { return new ImageToolsService(inject(ImgResizeExactService), inject(Ng2ImgMaxService$1), inject(ImgCropService)); }, token: ImageToolsService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ErImageEditorModule {
}
ErImageEditorModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    ErCoreModule,
                    Ng2ImgMaxModule
                ],
                declarations: [
                    ImageEditorComponent
                ],
                providers: [
                    { provide: ImgResizeExactService, useClass: ImgResizeExactService },
                    { provide: ImgCropService, useClass: ImgCropService },
                    { provide: ImageToolsService, useClass: ImageToolsService },
                    { provide: Ng2ImgMaxService, useClass: Ng2ImgMaxService }
                ],
                exports: [
                    ImageEditorComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { ImageToolsService, ImgCropService, ImgResizeExactService, ErImageEditorModule, ImageEditorComponent as ɵa };

//# sourceMappingURL=er-share.js.map