/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { LocationStrategy, PathLocationStrategy } from '@angular/common';
import { Injectable, Injector, NgZone } from '@angular/core';
import { DomUtils } from '@er/utils';
import { LogService } from '../log/service';
import * as i0 from "@angular/core";
export class GlobalErrorHandler {
    /**
     * @param {?} injector
     * @param {?} zone
     */
    constructor(injector, zone) {
        this.injector = injector;
        this.zone = zone;
        this.logService = injector.get(LogService);
        this.location = injector.get(LocationStrategy);
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        /** @type {?} */
        const message = error.message ? error.message : error.toString();
        /** @type {?} */
        const url = this.location instanceof PathLocationStrategy
            ? this.location.path() : '';
        this.logService.error(this, message, url, DomUtils.resolveUserAgent());
    }
}
GlobalErrorHandler.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
GlobalErrorHandler.ctorParameters = () => [
    { type: Injector },
    { type: NgZone }
];
/** @nocollapse */ GlobalErrorHandler.ngInjectableDef = i0.defineInjectable({ factory: function GlobalErrorHandler_Factory() { return new GlobalErrorHandler(i0.inject(i0.INJECTOR), i0.inject(i0.NgZone)); }, token: GlobalErrorHandler, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    GlobalErrorHandler.prototype.logService;
    /**
     * @type {?}
     * @private
     */
    GlobalErrorHandler.prototype.location;
    /**
     * @type {?}
     * @private
     */
    GlobalErrorHandler.prototype.injector;
    /**
     * @type {?}
     * @private
     */
    GlobalErrorHandler.prototype.zone;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0Blci9jb3JlLyIsInNvdXJjZXMiOlsibGliL3NlcnZpY2VzL2Vycm9yL3NlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBQyxnQkFBZ0IsRUFBRSxvQkFBb0IsRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBQ3ZFLE9BQU8sRUFBZSxVQUFVLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUN6RSxPQUFPLEVBQUMsUUFBUSxFQUFDLE1BQU0sV0FBVyxDQUFDO0FBQ25DLE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQzs7QUFLMUMsTUFBTSxPQUFPLGtCQUFrQjs7Ozs7SUFLN0IsWUFBb0IsUUFBa0IsRUFDbEIsSUFBWTtRQURaLGFBQVEsR0FBUixRQUFRLENBQVU7UUFDbEIsU0FBSSxHQUFKLElBQUksQ0FBUTtRQUM5QixJQUFJLENBQUMsVUFBVSxHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDM0MsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLENBQUM7SUFDakQsQ0FBQzs7Ozs7SUFFRCxXQUFXLENBQUMsS0FBSzs7Y0FDVCxPQUFPLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRTs7Y0FDMUQsR0FBRyxHQUFHLElBQUksQ0FBQyxRQUFRLFlBQVksb0JBQW9CO1lBQ3ZELENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFO1FBQzdCLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsR0FBRyxFQUFFLFFBQVEsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLENBQUM7SUFDekUsQ0FBQzs7O1lBbkJGLFVBQVUsU0FBQztnQkFDVixVQUFVLEVBQUUsTUFBTTthQUNuQjs7OztZQU5pQyxRQUFRO1lBQUUsTUFBTTs7Ozs7Ozs7SUFTaEQsd0NBQStCOzs7OztJQUMvQixzQ0FBbUM7Ozs7O0lBRXZCLHNDQUEwQjs7Ozs7SUFDMUIsa0NBQW9CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtMb2NhdGlvblN0cmF0ZWd5LCBQYXRoTG9jYXRpb25TdHJhdGVneX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7RXJyb3JIYW5kbGVyLCBJbmplY3RhYmxlLCBJbmplY3RvciwgTmdab25lfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RG9tVXRpbHN9IGZyb20gJ0Blci91dGlscyc7XG5pbXBvcnQge0xvZ1NlcnZpY2V9IGZyb20gJy4uL2xvZy9zZXJ2aWNlJztcblxuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgR2xvYmFsRXJyb3JIYW5kbGVyIGltcGxlbWVudHMgRXJyb3JIYW5kbGVyIHtcblxuICBwcml2YXRlIGxvZ1NlcnZpY2U6IExvZ1NlcnZpY2U7XG4gIHByaXZhdGUgbG9jYXRpb246IExvY2F0aW9uU3RyYXRlZ3k7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBpbmplY3RvcjogSW5qZWN0b3IsXG4gICAgICAgICAgICAgIHByaXZhdGUgem9uZTogTmdab25lKSB7XG4gICAgdGhpcy5sb2dTZXJ2aWNlID0gaW5qZWN0b3IuZ2V0KExvZ1NlcnZpY2UpO1xuICAgIHRoaXMubG9jYXRpb24gPSBpbmplY3Rvci5nZXQoTG9jYXRpb25TdHJhdGVneSk7XG4gIH1cblxuICBoYW5kbGVFcnJvcihlcnJvcikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlID8gZXJyb3IubWVzc2FnZSA6IGVycm9yLnRvU3RyaW5nKCk7XG4gICAgY29uc3QgdXJsID0gdGhpcy5sb2NhdGlvbiBpbnN0YW5jZW9mIFBhdGhMb2NhdGlvblN0cmF0ZWd5XG4gICAgICA/IHRoaXMubG9jYXRpb24ucGF0aCgpIDogJyc7XG4gICAgdGhpcy5sb2dTZXJ2aWNlLmVycm9yKHRoaXMsIG1lc3NhZ2UsIHVybCwgRG9tVXRpbHMucmVzb2x2ZVVzZXJBZ2VudCgpKTtcbiAgfVxufVxuIl19