import { NgxPermissionsService, NgxRolesService } from 'ngx-permissions';
import { NgValidators } from '@er/validate';
import { BehaviorSubject as BehaviorSubject$1 } from 'rxjs/internal/BehaviorSubject';
import { Subject as Subject$1 } from 'rxjs/index';
import { Observable as Observable$1 } from 'rxjs/internal/Observable';
import JSONFormatter from 'json-formatter-js';
import { DomSanitizer, Title } from '@angular/platform-browser';
import 'reflect-metadata';
import { Subject, Subscription, of, BehaviorSubject, zip, Observable, timer, throwError, TimeoutError, EMPTY } from 'rxjs';
import { termQuery, prefixQuery, matchAllQuery, boolQuery } from 'elastic-builder';
import { Location, NgIf, LocationStrategy, PathLocationStrategy, CommonModule } from '@angular/common';
import { HttpClient, HttpEventType, HttpHeaders, HttpParams, HttpRequest, HttpErrorResponse, HttpResponse, HTTP_INTERCEPTORS, HttpClientModule } from '@angular/common/http';
import { EventEmitter, Directive, Input, TemplateRef, ContentChildren, ApplicationRef, Injectable, Component, Inject, InjectionToken, Optional, ChangeDetectionStrategy, ElementRef, Output, Renderer2, ViewContainerRef, HostListener, HostBinding, ChangeDetectorRef, Pipe, NgZone, forwardRef, KeyValueDiffers, SimpleChange, ViewChild, Compiler, ComponentFactoryResolver, NgModule, Injector, defineInjectable, inject, INJECTOR } from '@angular/core';
import { FormControl, FormGroup, FormBuilder, Validators, NG_VALIDATORS, NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';
import { ActivatedRoute, Router, NavigationCancel, NavigationEnd, NavigationError, NavigationStart, DefaultUrlSerializer, RouteReuseStrategy, RouterModule } from '@angular/router';
import { HttpContentType, HttpMethod, HttpRequestPayloadType, HttpResponseType, StateNames, LogLevel, NO_OP, ApiServerType, NotifyLevel, ContentType, THEME_COLORS, Order, DataAttr, DataType, RegPatterns, NotifyType, StompStates } from '@er/types';
import { CommonsUtils, CacheUtils, ConfigUtils, RxUtils, StatesUtils, DateUtils, DialogUtils, IdUtils, ContextUtils, EsUtils, DataItemUtils, JwtUtils, BrowserOsUtils, RegUtils, DomUtils, ColorUtils, IdCardUtils, TreeUtils } from '@er/utils';
import { StompConfig, StompService } from '@stomp/ng2-stompjs';
import { dynamicDirectiveDef, DynamicModule } from 'ng-dynamic-component';
import { NgPipesModule } from 'ngx-pipes';
import { catchError, filter, map, tap, takeUntil, first, switchMap, distinctUntilChanged, mapTo, scan, startWith, takeWhile, timeout, take } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BaseClass {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * provide auto unsubscribe support
 */
class Unsubscribe extends BaseClass {
    constructor() {
        super(...arguments);
        this.destroyed$ = new Subject();
        this._$subscriptions = [];
    }
    /**
     * @param {?} subscription
     * @return {?}
     */
    set $subscriptions(subscription) {
        this._$subscriptions.push(subscription);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.stopSubscribe();
        this._$subscriptions
            .filter(sub => sub)
            .map(sub => sub.unsubscribe());
        for (const prop in this) {
            if (this[prop]) {
                /** @type {?} */
                const m = this[prop];
                if (m && m instanceof Subscription) {
                    m.unsubscribe();
                }
            }
        }
    }
    /**
     * @return {?}
     */
    stopSubscribe() {
        this.destroyed$.next();
        this.destroyed$.complete();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * provide event emit support
 * @abstract
 */
class BaseDirective extends Unsubscribe {
    constructor() {
        super();
        this.animations = {};
        this.ctx = {
            $from: (/** @type {?} */ (this))
        };
    }
    /**
     * @return {?}
     */
    getContext() {
        /** @type {?} */
        let id;
        if (!this['$id'] && this['$props'] && this['$props'].$id) {
            id = this['$props'].$id;
            this['$id'] = id;
        }
        /** @type {?} */
        const context = {
            $from: (/** @type {?} */ (this))
        };
        return id ? Object.assign({ $id: id }, context) : context;
    }
    /**
     * @param {?=} event
     * @return {?}
     */
    getEventContext(event) {
        return Object.assign({}, this.getContext(), event || {});
    }
    /**
     * @param {?} eventName
     * @param {?} event
     * @return {?}
     */
    emitEvent(eventName, event) {
        /** @type {?} */
        let eventEmitter = this[eventName];
        if (!eventEmitter) {
            eventEmitter = new EventEmitter();
            this[eventName] = eventEmitter;
        }
        if (eventEmitter instanceof EventEmitter) {
            return eventEmitter.emit(this.getEventContext(event));
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    isFirstChanges(changes) {
        return Object.keys(changes).every(prop => changes[prop].isFirstChange());
    }
    /**
     * @param {?=} name
     * @return {?}
     */
    animate(name) {
        return !(this.animations[name] || false);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class BaseService extends Unsubscribe {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TypedTemplateDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
    /**
     * @return {?}
     */
    getType() {
        return this.type;
    }
}
TypedTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[erTypedTemplate]'
            },] }
];
/** @nocollapse */
TypedTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
TypedTemplateDirective.propDecorators = {
    type: [{ type: Input, args: ['erTypedTemplate',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * provide template & dynamic query support
 * @abstract
 */
class BaseComponent extends BaseDirective {
    constructor() {
        super(...arguments);
        this.templates = {};
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.typedTemplates && this.typedTemplates.length > 0) {
            this.typedTemplates.forEach((item) => {
                if (item.type) {
                    CommonsUtils.set(this.templates, item.type, item.template);
                }
                else {
                    this.templates['_'] = item.template;
                }
            });
        }
    }
    /**
     * @param {?} outputs
     * @param {?} eventName
     * @param {?} defaultHandler
     * @param {?} event
     * @return {?}
     */
    eventHandler(outputs, eventName, defaultHandler, event) {
        if (outputs && outputs[eventName]) {
            return outputs[eventName].call(this, event);
        }
        else {
            return defaultHandler(event);
        }
    }
    /**
     * @param {?=} name
     * @param {...?} defaultTpls
     * @return {?}
     */
    template(name, ...defaultTpls) {
        if (!name) {
            name = '_';
        }
        if (this.templates[name]) {
            return this.templates[name];
        }
        else if (defaultTpls.length > 0) {
            /** @type {?} */
            const tpls = CommonsUtils.filter(defaultTpls, defaultTpl => !!defaultTpl);
            if (tpls.length > 0) {
                return tpls[0];
            }
        }
        return undefined;
    }
    /**
     * @template C
     * @param {?} id
     * @return {?}
     */
    getComponentBySelectorId(id) {
        if (this.selectors) {
            /** @type {?} */
            const matched = this.selectors.toArray().filter(comp => comp.id === id);
            if (matched.length === 1) {
                return matched[0].hostComponent;
            }
        }
        return undefined;
    }
    /**
     * @param {?} name
     * @param {...?} defaultTpls
     * @return {?}
     */
    hasTemplate(name, ...defaultTpls) {
        return this.template(name, ...defaultTpls) !== undefined;
    }
    /**
     * @param {?} templates
     * @return {?}
     */
    hasChildren(templates) {
        return CommonsUtils.isJson(templates);
    }
    // empty hooks for dyna bind
    /**
     * @return {?}
     */
    ngAfterContentChecked() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this['__ngAfterViewInit'] = true;
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this['__ngOnInit'] = true;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
    }
}
BaseComponent.propDecorators = {
    customerTpl: [{ type: Input }],
    typedTemplates: [{ type: ContentChildren, args: [TypedTemplateDirective,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const cacheKey = '$rootInjectables';
/** @type {?} */
let viewContainerRef = null;
class DiUtils {
    /**
     * @template T
     * @param {?} token
     * @return {?}
     */
    static get(token) {
        /** @type {?} */
        let cached = CacheUtils.get(cacheKey, token);
        if (!cached) {
            if (!DiUtils.injector) {
                throw new Error('rootInjector 初始化失败');
            }
            cached = DiUtils.injector.get(token);
            if (cached) {
                CacheUtils.put(cacheKey, token, cached);
            }
        }
        return cached;
    }
    /**
     * @return {?}
     */
    static getRootViewContainerRef() {
        if (!viewContainerRef) {
            /** @type {?} */
            const applicationRef = DiUtils.get(ApplicationRef);
            /** @type {?} */
            const appInstance = applicationRef.components[0].instance;
            if (!appInstance.rootViewContainerRef) {
                /** @type {?} */
                const appName = applicationRef.componentTypes[0].name;
                throw new Error(`${appName} constructor中未定义rootViewContainerRef`);
            }
            viewContainerRef = appInstance.rootViewContainerRef;
        }
        return viewContainerRef;
    }
}
DiUtils.injector = null;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HttpUtils {
    /**
     * @return {?}
     */
    static getHttpClient() {
        if (!HttpUtils._httpClient) {
            HttpUtils._httpClient = DiUtils.get(HttpClient);
        }
        return HttpUtils._httpClient;
    }
    /**
     * @return {?}
     */
    static timeout() {
        if (HttpUtils._timeout) {
            HttpUtils._timeout = ConfigUtils.getConfig().httpTimeout || 5000;
        }
        return HttpUtils._timeout;
    }
    /**
     * @template T
     * @param {?} options
     * @return {?}
     */
    static request(options) {
        /** @type {?} */
        let httpRequestOptions;
        if (CommonsUtils.isString(options)) {
            httpRequestOptions = CommonsUtils.getObjWhenStr(options, 'uri');
        }
        else {
            httpRequestOptions = (/** @type {?} */ (options));
        }
        if (httpRequestOptions.stateName) {
            return StatesUtils.get(httpRequestOptions.stateName);
        }
        if (httpRequestOptions.onRequest) {
            /** @type {?} */
            const result = httpRequestOptions.onRequest(httpRequestOptions);
            if (result === false) {
                return;
            }
            httpRequestOptions = (/** @type {?} */ (result));
        }
        /** @type {?} */
        let url = httpRequestOptions.uri || '/';
        if (!url.startsWith('http') && url.indexOf('assets/') < 0) {
            if (!url.startsWith('/')) {
                url = '/' + url;
            }
            url = ConfigUtils.getConfig().api.servers[httpRequestOptions.serverType || ConfigUtils.getConfig().api.default].uri + url;
        }
        /** @type {?} */
        const requestOptions = {};
        requestOptions.observe = httpRequestOptions.observe || 'body';
        requestOptions.responseType = httpRequestOptions.responseType || HttpResponseType.JSON;
        requestOptions.headers = HttpUtils.getRequestHeader(httpRequestOptions);
        /** @type {?} */
        const method = httpRequestOptions.method || ((httpRequestOptions.body || httpRequestOptions.payload) ? HttpMethod.POST : HttpMethod.GET);
        if (httpRequestOptions.payload) {
            if (httpRequestOptions.payloadType === HttpRequestPayloadType.PARAMS) {
                httpRequestOptions.params = httpRequestOptions.payload;
            }
            else if (httpRequestOptions.payloadType === HttpRequestPayloadType.BODY) {
                httpRequestOptions.body = httpRequestOptions.payload;
            }
            else if (!method || httpRequestOptions.method === HttpMethod.GET) {
                httpRequestOptions.params = httpRequestOptions.payload;
            }
            else {
                httpRequestOptions.body = httpRequestOptions.payload;
            }
        }
        if (httpRequestOptions.params) {
            requestOptions.params = HttpUtils.getRequestParams(httpRequestOptions);
        }
        if (httpRequestOptions.body) {
            requestOptions.body = HttpUtils.getRequestBody(httpRequestOptions);
        }
        if (!httpRequestOptions.context) {
            httpRequestOptions.context = this; // use HttpUtils.request.call(this,...) to init context
        }
        return HttpUtils.getHttpClient().request(method, url, Object.assign({}, requestOptions, { observe: 'events' }))
            .pipe(RxUtils.retry(httpRequestOptions.retry, HttpUtils.timeout()), filter(event => event.type === HttpEventType.Sent || event.type === HttpEventType.Response), tap(event => {
            if (event.type === HttpEventType.Sent) {
                HttpUtils.updateHttpTagState(httpRequestOptions.tag, true, { url, opts: httpRequestOptions });
            }
        }), filter(event => event.type === HttpEventType.Response), map(event => {
            /** @type {?} */
            let response = event;
            if (!httpRequestOptions.observe || httpRequestOptions.observe === 'body') {
                response = event.body;
            }
            HttpUtils.updateHttpTagState(httpRequestOptions.tag, false, {
                status: 'success',
                httpRequestOptions
            });
            /** @type {?} */
            const resp = httpRequestOptions.onResponse
                ? httpRequestOptions.onResponse.call(httpRequestOptions.context, response, httpRequestOptions)
                : response;
            if (httpRequestOptions.stateName) {
                StatesUtils.update(httpRequestOptions.stateName, resp);
            }
            return resp;
        }), catchError((error) => {
            HttpUtils.updateHttpTagState(httpRequestOptions.tag, false, { status: 'error', error });
            if (httpRequestOptions.onError) {
                httpRequestOptions.onError.call(httpRequestOptions.context, error, httpRequestOptions);
            }
            return of('服务器请求失败，状态码:' + error.status);
        }));
    }
    /**
     * @private
     * @param {?} tag
     * @param {?} state
     * @param {?=} extra
     * @return {?}
     */
    static updateHttpTagState(tag, state, extra) {
        if (tag) {
            StatesUtils.create([StateNames.http, tag], Object.assign({ start: state }, extra));
        }
    }
    /**
     * @private
     * @param {?} options
     * @return {?}
     */
    static getRequestParams(options) {
        /** @type {?} */
        let params;
        if (typeof options.params === 'string') {
            params = new HttpParams({ fromString: options.params });
        }
        else {
            params = new HttpParams();
            for (const key in options.params) {
                if (key) {
                    if (options.params.hasOwnProperty(key) && (options.params[key] !== null || options.params[key] !== undefined)) {
                        params = params.append(key, CommonsUtils.toString(options.params[key]));
                    }
                }
            }
        }
        return params;
    }
    /**
     * @private
     * @param {?} options
     * @return {?}
     */
    static getRequestBody(options) {
        return options.body;
    }
    /**
     * @private
     * @param {?} options
     * @return {?}
     */
    static getRequestHeader(options) {
        /** @type {?} */
        let headers = new HttpHeaders();
        if (options.contentType) {
            headers = headers.append('Content-Type', options.contentType);
        }
        else {
            headers = headers.append('Content-Type', HttpContentType.JSON);
        }
        if (options.headers) {
            for (const key in options.headers) {
                if (key) {
                    headers = headers.append(key, options.headers[key]);
                }
            }
        }
        return headers;
    }
    /**
     * @param {?} file
     * @return {?}
     */
    upload(file) {
        /** @type {?} */
        const formdata = new FormData();
        formdata.append('file', file);
        /** @type {?} */
        const req = new HttpRequest('POST', `upload`, formdata, {
            reportProgress: true,
            responseType: 'text'
        });
        return HttpUtils.getHttpClient().request(req);
    }
}
HttpUtils._httpClient = null;
HttpUtils._timeout = 3000;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LogService {
    /**
     * @param {?} from
     * @param {?} message
     * @param {...?} context
     * @return {?}
     */
    debug(from, message, ...context) {
        if (!ConfigUtils.getConfig().isProduction
            && ConfigUtils.getConfig().log.enableApp
            && ConfigUtils.getConfig().log.level <= LogLevel.DEBUG) {
            if ((typeof from) !== 'string' && from.constructor) {
                from = from.constructor.name;
            }
            if (ConfigUtils.getConfig().log.blackLList.indexOf(from) < 0) {
                this.getLogger().log(`[${DateUtils.getFormattedTime()}] %c DEBUG `, 'color: white; background: green; font-size: 18px;', this.getLogData([from, message, ...context]));
            }
        }
    }
    /**
     * @param {?} from
     * @param {?} message
     * @param {...?} context
     * @return {?}
     */
    info(from, message, ...context) {
        if (ConfigUtils.getConfig().log.level <= LogLevel.INFO) {
            if (typeof from !== 'string' && from.constructor) {
                from = from.constructor.name;
            }
            if (ConfigUtils.getConfig().log.blackLList.indexOf(from) < 0) {
                this.getLogger().log(`[${DateUtils.getFormattedTime()}] %c INFO `, 'color: white; background: blue; font-size: 18px;', this.getLogData([from, message, ...context]));
            }
        }
    }
    /**
     * @param {?} messages
     * @return {?}
     */
    warn(messages) {
        if (ConfigUtils.getConfig().log.level <= LogLevel.WARN) {
            this.getLogger().log(`[${DateUtils.getFormattedTime()}] %c WARN `, 'color: white; background: blue; font-size: 18px;', this.getLogData(messages));
        }
    }
    /**
     * @param {?} from
     * @param {?} message
     * @param {...?} context
     * @return {?}
     */
    error(from, message, ...context) {
        DialogUtils.error('错误', message);
        if (ConfigUtils.getConfig().log.level <= LogLevel.ERROR) {
            this.getLogger().log(`[${DateUtils.getFormattedTime()}] %c ERROR `, 'color: white; background: red; font-size: 18px;', this.getLogData([from, message, ...context]));
            if (ConfigUtils.getConfig().log.httpPost) {
                if (CommonsUtils.isFunction(from)) {
                    from = from.constructor.name;
                }
                this.getHttpLogger().log(DateUtils.getFormattedDateTime(), this.getLogData([from, message]));
            }
        }
    }
    /**
     * @protected
     * @return {?}
     */
    getLogger() {
        return console;
    }
    /**
     * @protected
     * @return {?}
     */
    getHttpLogger() {
        return (/** @type {?} */ ({
            log: (message, ...optionalParams) => {
                HttpUtils.request(Object.assign({}, ConfigUtils.getConfig().logHttpOptions, { body: Object.assign({ message }, optionalParams) }));
            }
        }));
    }
    /**
     * @private
     * @param {?} messages
     * @return {?}
     */
    getLogData(messages) {
        return Object.assign({}, messages);
    }
}
LogService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ LogService.ngInjectableDef = defineInjectable({ factory: function LogService_Factory() { return new LogService(); }, token: LogService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LogUtils {
    /**
     * @param {?} from
     * @param {?} message
     * @param {...?} context
     * @return {?}
     */
    static debug(from, message, ...context) {
        LogUtils.getLogService().debug(from, message, context);
    }
    /**
     * @param {?} from
     * @param {?} message
     * @param {...?} context
     * @return {?}
     */
    static info(from, message, ...context) {
        LogUtils.getLogService().info(from, message, context);
    }
    /**
     * @param {?} messages
     * @return {?}
     */
    static warn(messages) {
        LogUtils.getLogService().warn(messages);
    }
    /**
     * @param {?} from
     * @param {?} message
     * @param {...?} context
     * @return {?}
     */
    static error(from, message, ...context) {
        LogUtils.getLogService().error(from, message, context);
    }
    /**
     * @private
     * @return {?}
     */
    static getLogService() {
        if (!LogUtils._logService) {
            LogUtils._logService = DiUtils.get(LogService);
        }
        return LogUtils._logService;
    }
}
LogUtils._logService = null;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ComponentUtils {
    /**
     * @param {?} compInstance
     * @param {?} props
     * @return {?}
     */
    static resolveProps(compInstance, props) {
        /** @type {?} */
        const result = {
            inputs: {},
            outputs: {}
        };
        if (compInstance && CommonsUtils.isJson(props)) {
            Object.keys(props).forEach(key => {
                if (compInstance[key] instanceof EventEmitter) {
                    result.outputs[key] = props[key];
                }
                else {
                    result.inputs[key] = props[key];
                }
            });
        }
        return result;
    }
    /**
     * @param {?} compInstance
     * @param {?} hooks
     * @param {?} constructor
     * @param {?} destructor
     * @return {?}
     */
    static bindLifeCycles(compInstance, hooks, constructor, destructor) {
        /** @type {?} */
        let originalLifeCycles;
        if (hooks) {
            originalLifeCycles = {};
            Object.keys(hooks).forEach(eventName => {
                /** @type {?} */
                const ngEventName = `ng${CommonsUtils.capitalize(eventName)}`;
                if (compInstance[`__${ngEventName}`] === true) {
                    ((/** @type {?} */ (hooks[eventName]))).call(compInstance, compInstance);
                }
                else {
                    /** @type {?} */
                    const original = constructor.prototype[ngEventName];
                    constructor.prototype[ngEventName] = function () {
                        CommonsUtils.isFunction(original) && original.apply(compInstance, arguments);
                        /** @type {?} */
                        const args = Array.prototype.slice.call(arguments);
                        ((/** @type {?} */ (hooks[eventName]))).call(compInstance, ...args, compInstance);
                    };
                    originalLifeCycles[ngEventName] = original;
                }
            });
            if (Object.keys(originalLifeCycles).length > 0) {
                /** @type {?} */
                const destroyLifeCycle = 'ngOnDestroy';
                constructor.prototype[destroyLifeCycle] = function () {
                    Object.keys(originalLifeCycles).forEach(lifeCycleName => {
                        constructor.prototype[lifeCycleName] = originalLifeCycles[lifeCycleName];
                    });
                    CommonsUtils.isFunction(destructor) && destructor.apply(compInstance);
                    constructor.prototype[destroyLifeCycle] = destructor;
                };
            }
        }
    }
    // static bindLifeCycles(compInstance, hooks) {
    //   if (!CommonsUtils.isEmpty(hooks)) {
    //     Object.keys(hooks).forEach(eventName => {
    //       const hookName = `ng${CommonsUtils.capitalize(eventName)}`;
    //       const original = compInstance.__proto__[hookName];
    //       compInstance.__proto__[hookName] = function () {
    //         CommonsUtils.isFunction(original) && original.apply(compInstance, arguments);
    //         const args = Array.prototype.slice.call(arguments);
    //         (<Function>hooks[eventName]).call(compInstance, ...args, compInstance);
    //       };
    //     });
    //   }
    // }
    /**
     * set component instance attributes and event from props object
     * @param {?} compInstance
     * @param {?} props
     * @param {?=} unSubscribe
     * @return {?}
     */
    static bind(compInstance, props, unSubscribe) {
        for (const prop in props) {
            if (prop === 'hooks') {
                /** @type {?} */
                const constructor = ComponentUtils.getConstructor(compInstance);
                /** @type {?} */
                const destructor = constructor.prototype['ngOnDestroy'];
                ComponentUtils.bindLifeCycles(compInstance, props[prop], constructor, destructor);
            }
            else if ((compInstance[prop] instanceof EventEmitter)) {
                ((/** @type {?} */ (compInstance[prop])))
                    .pipe(takeUntil(unSubscribe || compInstance['destroyed$']))
                    .subscribe(event => {
                    try {
                        if (CommonsUtils.isFunction(compInstance['getEventContext'])) {
                            event = compInstance.getEventContext(event);
                        }
                        props[prop].call(compInstance, event);
                    }
                    catch (e) {
                        LogUtils.error(compInstance, '操作失败', e);
                    }
                });
            }
            else {
                compInstance[prop] = props[prop];
            }
        }
    }
    /**
     * @param {?} compInstance
     * @param {?} methodName
     * @param {?} newFun
     * @param {?=} position
     * @return {?}
     */
    static reWriteMethod(compInstance, methodName, newFun, position = 'after') {
        /** @type {?} */
        const buildInFn = compInstance[methodName];
        Object.defineProperty(compInstance, methodName, {
            get: () => {
                return (args) => {
                    if (buildInFn && position === 'after') {
                        buildInFn.call(compInstance, args);
                    }
                    newFun.call(compInstance, args);
                    if (buildInFn && position === 'before') {
                        buildInFn.call(compInstance, args);
                    }
                };
            }
        });
    }
    /**
     * @param {?} viewContainer
     * @return {?}
     */
    static getHostComponentInst(viewContainer) {
        if (viewContainer) {
            /** @type {?} */
            const componentView = viewContainer['_data'].componentView;
            if (componentView) {
                return componentView.component;
            }
        }
        return null;
    }
    /**
     * @param {?} viewContainer
     * @return {?}
     */
    static getViewComponentRef(viewContainer) {
        if (viewContainer) {
            /** @type {?} */
            const view = viewContainer['_view'];
            if (view) {
                return view.component;
            }
        }
        return null;
    }
    /**
     * @param {?} component
     * @return {?}
     */
    static getConstructor(component) {
        return component.__proto__.constructor;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RouteUtils {
    /**
     * @return {?}
     */
    static getActiveRoute() {
        /** @type {?} */
        let route = DiUtils.get(ActivatedRoute);
        while (route.firstChild) {
            route = route.firstChild;
        }
        return route;
    }
    /**
     * @return {?}
     */
    static getActiveRouteData() {
        /** @type {?} */
        const route = RouteUtils.getActiveRoute();
        return route && route.snapshot.data;
    }
    /**
     * @param {?=} outletName
     * @param {?=} isRelative
     * @return {?}
     */
    static clearOutlet(outletName = 'primary', isRelative = false) {
        /** @type {?} */
        const extra = {};
        if (!isRelative) {
            extra['relativeTo'] = RouteUtils.getActiveRoute();
        }
        DiUtils.get(Router).navigate([{ outlets: { [outletName]: null } }], extra);
    }
    /**
     * @param {?} commands
     * @param {?=} paramsOrRelative
     * @param {?=} extras
     * @return {?}
     */
    static nav(commands, paramsOrRelative, extras) {
        if (CommonsUtils.isString(commands)) {
            commands = [commands];
        }
        if (!extras) {
            extras = (/** @type {?} */ ({}));
        }
        if (paramsOrRelative && Object.keys(paramsOrRelative).length > 0) {
            CommonsUtils.set((/** @type {?} */ (extras)), 'queryParams', paramsOrRelative);
        }
        if ((CommonsUtils.isString(commands) && !((/** @type {?} */ (commands))).startsWith('/'))
            || (paramsOrRelative === true)) {
            CommonsUtils.set((/** @type {?} */ (extras)), 'relativeTo', RouteUtils.getActiveRoute());
        }
        DiUtils.get(Router).navigate((/** @type {?} */ (commands)), extras);
    }
    /**
     * @return {?}
     */
    static back() {
        DiUtils.get(Location).back();
    }
    /**
     * @return {?}
     */
    static forward() {
        DiUtils.get(Location).forward();
    }
    /**
     * @return {?}
     */
    static refresh() {
        RouteUtils.navigate(StatesUtils.getValue(StateNames.nav)['url']);
    }
    /**
     * @param {?} url
     * @return {?}
     */
    static navigate(url) {
        if (url.startsWith('http')) {
            window.location.href = url;
        }
        else {
            DiUtils.get(Router).navigateByUrl(url);
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RouteBindComponent extends BaseComponent {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.$subscriptions = RouteUtils.getActiveRoute().url.subscribe(url => {
            /** @type {?} */
            let activeRoute = RouteUtils.getActiveRoute();
            if (!activeRoute) {
                return;
            }
            /** @type {?} */
            const data = CommonsUtils.copy(activeRoute.snapshot.data);
            /** @type {?} */
            const params = Object.assign({}, activeRoute.snapshot.params || {}, activeRoute.snapshot.queryParams || {});
            while (activeRoute && !activeRoute.snapshot.data['$props']) {
                activeRoute = activeRoute.parent;
            }
            /** @type {?} */
            const routeData = Object.assign({}, activeRoute.snapshot.data, data);
            /** @type {?} */
            let props = CommonsUtils.copy(routeData['$resolvedProps'] || routeData['$props']);
            if (data['$propsKey']) {
                props = CommonsUtils.get(props, data['$propsKey']);
            }
            Object.keys(data).forEach(key => {
                if (CommonsUtils.isFunction(data[key])) {
                    props[key] = ((/** @type {?} */ (data[key])))(props, params, data);
                }
                else if (CommonsUtils.isString(data[key]) && data[key].startsWith(':')) {
                    /** @type {?} */
                    const param = ((/** @type {?} */ (data[key]))).substring(1);
                    if (params[param]) {
                        props[key] = params[param];
                    }
                }
                else if (key !== '$propsKey' && key !== '$propsWrapperKey' && key !== '$props') {
                    props[key] = data[key];
                }
            });
            props['$routeParams'] = params;
            LogUtils.debug(this, '路由数据', routeData);
            props = this.beforeRoutePropsBind(props);
            ComponentUtils.bind(this, props);
            this.afterRoutePropsBind();
        });
    }
    /**
     * @param {?} props
     * @return {?}
     */
    beforeRoutePropsBind(props) {
        return props;
    }
    /**
     * @return {?}
     */
    afterRoutePropsBind() {
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ControlComponent extends BaseComponent {
    constructor() {
        super(...arguments);
        this.disabled = false;
        this.disabled$ = new BehaviorSubject(false);
        this.onTouched = NO_OP;
        this.onChange = NO_OP;
    }
    /**
     * @return {?}
     */
    get opacity() {
        return this.disabled ? 0.25 : 1;
    }
    /**
     * @return {?}
     */
    get cursor() {
        return this.disabled ? 'not-allowed' : 'default';
    }
    /**
     * @return {?}
     */
    get value() {
        return this.innerValue;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        if (!value || value !== this.innerValue) {
            /** @type {?} */
            const v = this.parser ? this.parser(value) : value;
            this.innerValue = v;
            this.onChange(v);
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.defaultValue) {
            this.innerValue = this.defaultValue;
        }
    }
    /**
     * @return {?}
     */
    updateTouch() {
        this.onTouched();
    }
    /**
     * @param {?} model
     * @return {?}
     */
    writeValue(model) {
        /** @type {?} */
        const v = this.formatter ? this.formatter(model) : model;
        if (v !== this.innerValue) {
            this.innerValue = v;
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this.disabled$.next(isDisabled);
    }
}
ControlComponent.propDecorators = {
    parser: [{ type: Input }],
    formatter: [{ type: Input }],
    disabled: [{ type: Input }],
    opacity: [{ type: HostBinding, args: ['style.opacity',] }],
    cursor: [{ type: HostBinding, args: ['style.cursor',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 * @template T
 */
class WrapperComponent extends BaseComponent {
    /**
     * @return {?}
     */
    _initProps() {
        this.$props = CommonsUtils.defaults({}, this.$props || {}, this.$defaultProps || {});
        if (!this.$props.$id) {
            this.$props.$id = IdUtils.getRandom();
        }
        if (!this.$props.$ext) {
            this.$props.$ext = {};
        }
        if (this.$props.$ext['apiDataProps']) {
            if (!this.$props.$ext['apiDataProps'].requestOptions) {
                this.$props.$ext['apiDataProps'].requestOptions = {};
            }
            CommonsUtils.defaults(this.$props.$ext['apiDataProps'].requestOptions, {
                context: this,
                tag: this.$props.$id
            });
        }
        this.onPropsInit();
    }
    /**
     * @return {?}
     */
    _propsBind() {
        this.onPropsBind();
    }
    /**
     * @return {?}
     */
    onPropsInit() { }
    /**
     * @return {?}
     */
    onPropsBind() {
    }
}
WrapperComponent.propDecorators = {
    outputContext: [{ type: Input }],
    attrs: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class ControlWrapperComponent extends WrapperComponent {
    constructor() {
        super(...arguments);
        this.resettable = true;
        this.disabled = false;
        this.onTouched = NO_OP;
        this.onChange = NO_OP;
    }
    /**
     * @return {?}
     */
    get opacity() {
        return this.disabled ? 0.25 : 1;
    }
    /**
     * @return {?}
     */
    get cursor() {
        return this.disabled ? 'not-allowed' : 'default';
    }
    /**
     * @return {?}
     */
    get value() {
        return this.innerValue;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        /** @type {?} */
        const v = this.valueParser ? this.valueParser(value) : value;
        if (!CommonsUtils.isEqual(v, this.innerValue)) {
            this.innerValue = v;
            this.onChange(v);
        }
    }
    /**
     * @return {?}
     */
    updateTouch() {
        this.onTouched();
    }
    /**
     * @param {?} model
     * @return {?}
     */
    writeValue(model) {
        /** @type {?} */
        const v = this.modelFormatter ? this.modelFormatter(model) : model;
        if (v !== this.innerValue) {
            this.innerValue = v;
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @return {?}
     */
    onPropsInit() {
        if (this.disabled) {
            this.$props['disabled'] = this.disabled;
        }
    }
    /**
     * @return {?}
     */
    reset() {
        this.value = null;
    }
}
ControlWrapperComponent.propDecorators = {
    valueParser: [{ type: Input }],
    modelFormatter: [{ type: Input }],
    resettable: [{ type: Input }],
    disabled: [{ type: Input }],
    opacity: [{ type: HostBinding, args: ['style.opacity',] }],
    cursor: [{ type: HostBinding, args: ['style.cursor',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_API_REQUEST_OPTIONS = {
    notifyFailure: true
};
class ApiUtils {
    /**
     * @param {?} serverType
     * @return {?}
     */
    static getPresetApiOptions(serverType) {
        if (!serverType) {
            serverType = CommonsUtils.get(ConfigUtils.getConfig(), 'api.default') || ApiServerType.ES;
        }
        ApiUtils.presetApiOptions[serverType] = Object.assign({}, DEFAULT_API_REQUEST_OPTIONS, CommonsUtils.get(ConfigUtils.getConfig(), `api.servers.${serverType}`, {}));
        if (!ApiUtils.presetApiOptions[serverType].actions) {
            ApiUtils.presetApiOptions[serverType].actions = {};
        }
        return ApiUtils.presetApiOptions[serverType];
    }
    /**
     * @param {?} payload
     * @param {?=} options
     * @return {?}
     */
    static login(payload, options = {}) {
        /** @type {?} */
        const presetActionOptions = ApiUtils.getPresetApiOptions(options.serverType).actions.login || {};
        return ApiUtils.doRequest(null, payload, presetActionOptions, options);
    }
    /**
     * @param {?=} options
     * @return {?}
     */
    static logout(options = {}) {
        /** @type {?} */
        const presetActionOptions = ApiUtils.getPresetApiOptions(options.serverType).actions.logout || {};
        return ApiUtils.doRequest(null, null, presetActionOptions, options);
    }
    /**
     * @param {?} payload
     * @param {?=} options
     * @return {?}
     */
    static changePwd(payload, options = {}) {
        /** @type {?} */
        const presetActionOptions = ApiUtils.getPresetApiOptions(options.serverType).actions.changePwd || {};
        return ApiUtils.doRequest(null, payload, presetActionOptions, options);
    }
    /**
     * @param {?} payload
     * @param {?=} options
     * @return {?}
     */
    static register(payload, options = {}) {
        /** @type {?} */
        const presetActionOptions = ApiUtils.getPresetApiOptions(options.serverType).actions.register || {};
        return ApiUtils.doRequest(null, payload, presetActionOptions, options);
    }
    /**
     * @param {?} apiEntry
     * @param {?} data
     * @param {?=} options
     * @return {?}
     */
    static save(apiEntry, data, options = {}) {
        if (data) {
            /** @type {?} */
            const _data = Object.assign({}, data);
            if (_data['id']) {
                /** @type {?} */
                const id = _data['id'];
                delete _data['id'];
                return ApiUtils.patchById.call(this, apiEntry, id, _data, options);
            }
            else {
                return ApiUtils.create.call(this, apiEntry, _data, options);
            }
        }
    }
    /**
     * @param {?} apiEntry
     * @param {?} data
     * @param {?=} options
     * @return {?}
     */
    static create(apiEntry, data, options = {}) {
        /** @type {?} */
        const presetActionOptions = ApiUtils.getPresetApiOptions(options.serverType).actions.create || {};
        ApiUtils.setContext(options, this);
        return ApiUtils.doRequest(apiEntry, data, presetActionOptions, options);
    }
    /**
     * @param {?} apiEntry
     * @param {?} id
     * @param {?=} options
     * @return {?}
     */
    static getById(apiEntry, id, options = {}) {
        /** @type {?} */
        const presetActionOptions = ApiUtils.getPresetApiOptions(options.serverType).actions.getById || {};
        ApiUtils.setContext(options, this);
        return ApiUtils.doRequest(apiEntry, { id }, presetActionOptions, options);
    }
    /**
     * @param {?} apiEntry
     * @param {?} ids
     * @param {?=} options
     * @return {?}
     */
    static getByIds(apiEntry, ids, options = {}) {
        /** @type {?} */
        const presetActionOptions = ApiUtils.getPresetApiOptions(options.serverType).actions.getByIds || {};
        ApiUtils.setContext(options, this);
        return ApiUtils.doRequest(apiEntry, ids, presetActionOptions, options);
    }
    /**
     * @param {?} apiEntry
     * @param {?=} payload
     * @param {?=} options
     * @return {?}
     */
    static getByQuery(apiEntry, payload, options = {}) {
        /** @type {?} */
        const presetActionOptions = ApiUtils.getPresetApiOptions(options.serverType).actions.getByQuery;
        ApiUtils.setContext(options, this);
        return ApiUtils.doRequest(apiEntry, payload, presetActionOptions, options);
    }
    /**
     * @param {?} apiEntry
     * @param {?} id
     * @param {?} data
     * @param {?=} options
     * @return {?}
     */
    static updateById(apiEntry, id, data, options = {}) {
        /** @type {?} */
        const presetActionOptions = ApiUtils.getPresetApiOptions(options.serverType).actions.updateById;
        ApiUtils.setContext(options, this);
        return ApiUtils.doRequest(apiEntry, Object.assign({ id }, data), presetActionOptions, options);
    }
    /**
     * @param {?} apiEntry
     * @param {?} id
     * @param {?} data
     * @param {?=} options
     * @return {?}
     */
    static patchById(apiEntry, id, data, options = {}) {
        /** @type {?} */
        const presetActionOptions = ApiUtils.getPresetApiOptions(options.serverType).actions.patchById;
        ApiUtils.setContext(options, this);
        return ApiUtils.doRequest(apiEntry, Object.assign({ id }, data), presetActionOptions, options);
    }
    /**
     * @param {?} apiEntry
     * @param {?} query
     * @param {?} data
     * @param {?=} options
     * @return {?}
     */
    static updateByQuery(apiEntry, query, data, options = {}) {
        /** @type {?} */
        const presetActionOptions = ApiUtils.getPresetApiOptions(options.serverType).actions.updateByQuery;
        ApiUtils.setContext(options, this);
        return ApiUtils.doRequest(apiEntry, query, presetActionOptions, options);
    }
    /**
     * @param {?} apiEntry
     * @param {?} id
     * @param {?=} options
     * @return {?}
     */
    static deleteById(apiEntry, id, options = {}) {
        /** @type {?} */
        const obv = DialogUtils.confirm('操作确认', '确认执行<b>删除</b>操作吗?')
            .pipe(first(), filter(accept => accept), switchMap(_ => {
            /** @type {?} */
            const presetActionOptions = ApiUtils.getPresetApiOptions(options.serverType).actions.deleteById;
            return ApiUtils.doRequest(apiEntry, id, presetActionOptions, options);
        }));
        return obv;
    }
    /**
     * @param {?} apiEntry
     * @param {?} query
     * @param {?=} options
     * @return {?}
     */
    static deleteByQuery(apiEntry, query, options = {}) {
        /** @type {?} */
        const presetActionOptions = ApiUtils.getPresetApiOptions(options.serverType).actions.deleteByQuery;
        ApiUtils.setContext(options, this);
        return ApiUtils.doRequest(apiEntry, query, presetActionOptions, options);
    }
    /**
     * @param {?} apiEntry
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    static batch(apiEntry, body, options = {}) {
        /** @type {?} */
        const presetActionOptions = ApiUtils.getPresetApiOptions(options.serverType).actions.batch;
        ApiUtils.setContext(options, this);
        return ApiUtils.doRequest(apiEntry, body, presetActionOptions, options);
    }
    /**
     * @param {?} dataSource
     * @param {?=} tag
     * @return {?}
     */
    static batchFetch(dataSource, tag) {
        if (dataSource) {
            /** @type {?} */
            let _apiDataProp = dataSource;
            if (dataSource['apiDataProps']) {
                _apiDataProp = dataSource['apiDataProps'];
            }
            _apiDataProp = CommonsUtils.copy(_apiDataProp);
            /** @type {?} */
            const apiDataProps = CommonsUtils.getArrayValue(_apiDataProp);
            if (CommonsUtils.isEmpty(apiDataProps)) {
                return;
            }
            if (!tag) {
                tag = dataSource['id'] || apiDataProps[0].id || '';
            }
            apiDataProps.forEach(apiDataProp => {
                if (dataSource['query']) {
                    /** @type {?} */
                    const query = dataSource['query'];
                    /** @type {?} */
                    const apiQuery = CommonsUtils.getArrayValue(apiDataProp.query || []);
                    apiQuery.concat(CommonsUtils.getArrayValue(query));
                    apiDataProp.query = apiQuery;
                }
                /** @type {?} */
                const _filter = apiDataProp.filter;
                if (CommonsUtils.isFunction(_filter)) {
                    if (dataSource['queryValue']) {
                        apiDataProp.filter = ((/** @type {?} */ (apiDataProp.filter)))(dataSource['queryValue']);
                    }
                    else {
                        delete apiDataProp.filter;
                    }
                }
                if (dataSource['interval']) {
                    CommonsUtils.set((/** @type {?} */ (apiDataProp)), 'aggProps.interval', dataSource['interval']);
                }
                if (dataSource['format']) {
                    CommonsUtils.set((/** @type {?} */ (apiDataProp)), 'aggProps.format', dataSource['format']);
                }
            });
            // return forkJoin(...apiDataProps.map(apiDataProp => ApiUtils.fetch(apiDataProp, tag)))
            //   .pipe(
            //     catchError((err) => throwError(err))
            //   );
            return zip(...apiDataProps.map(apiDataProp => ApiUtils.fetch(apiDataProp, tag)))
                .pipe(map(dataSet => {
                /** @type {?} */
                let resultList;
                /** @type {?} */
                let resultMap;
                dataSet.forEach((data, i) => {
                    if (apiDataProps[i].id) {
                        if (!resultMap) {
                            resultMap = {};
                        }
                        resultMap[apiDataProps[i].id] = data;
                    }
                    else {
                        if (!resultList) {
                            resultList = [];
                        }
                        resultList.push(data);
                    }
                });
                if (resultList && resultList.length === 1) {
                    resultList = resultList[0];
                }
                if (resultMap && resultList) {
                    return Object.assign({}, resultMap, { data: resultList });
                }
                else {
                    return resultMap || resultList || [];
                }
            }));
        }
    }
    /**
     * @param {?} apiDataProps
     * @param {?=} tag
     * @return {?}
     */
    static fetch(apiDataProps, tag) {
        if (!apiDataProps.apiEntry) {
            LogUtils.error('apiUtil', '没有定义apiEntry');
            return of([]);
        }
        /** @type {?} */
        let queryPayload;
        if (CommonsUtils.isFunction(apiDataProps.payload)) {
            queryPayload = ((/** @type {?} */ (apiDataProps.payload))).call(undefined, apiDataProps);
        }
        else if (apiDataProps.payload) {
            queryPayload = apiDataProps.payload;
        }
        if (!queryPayload) {
            /** @type {?} */
            const qBody = EsUtils.buildQueryBody(apiDataProps);
            queryPayload = qBody;
        }
        /** @type {?} */
        const options = apiDataProps.requestOptions || {};
        if (!options.tag) {
            options.tag = tag || '';
        }
        LogUtils.debug('apiUtils', 'apiData数据查询', { apiDataProps: apiDataProps, apiRequestBody: queryPayload });
        return ApiUtils.getByQuery(apiDataProps.apiEntry, queryPayload, options)
            .pipe(map(data => {
            /** @type {?} */
            let aggs;
            if (data && data.aggs) {
                aggs = EsUtils.resolveAggs(data.aggs);
                data.aggs = aggs;
            }
            if (CommonsUtils.isEmpty(data.items)) {
                delete data.items;
            }
            if (CommonsUtils.isEmpty(data.aggs)) {
                delete data.aggs;
            }
            /** @type {?} */
            let path = apiDataProps.dataPath || (apiDataProps.aggProps ? 'aggs' : undefined);
            if (path === '/') {
                path = undefined;
            }
            return path ? CommonsUtils.get(data, path) : data;
        }));
    }
    /**
     * @private
     * @param {?} options
     * @param {?} context
     * @return {?}
     */
    static setContext(options, context) {
        options = options || {};
        options.context = context;
    }
    /**
     * @private
     * @param {?} apiEntry
     * @param {?} payload
     * @param {?} presetActionOptions
     * @param {?=} actionOptions
     * @return {?}
     */
    static doRequest(apiEntry, payload, presetActionOptions, actionOptions) {
        /** @type {?} */
        const apiRequestOptions = Object.assign({}, presetActionOptions, actionOptions);
        delete apiRequestOptions.actions;
        /** @type {?} */
        const requestPayload = payload;
        /** @type {?} */
        const requestOptions = Object.assign({}, apiRequestOptions, { uri: ApiUtils.buildUri(apiEntry, requestPayload, apiRequestOptions), payload: ApiUtils.buildPayload(apiEntry, requestPayload, apiRequestOptions) });
        delete requestOptions.paramsKeys;
        delete requestOptions.uriResolver;
        delete requestOptions.payloadResolver;
        if (!requestOptions.uri || !requestOptions.uri.startsWith('http')) {
            /** @type {?} */
            const apiServer = ApiUtils.getPresetApiOptions(presetActionOptions.serverType).uri || '';
            requestOptions.uri = apiServer + (requestOptions.uri.startsWith('/') ? '' : '/') + requestOptions.uri;
        }
        return HttpUtils.request(requestOptions)
            .pipe(filter(response => !!response), map(response => {
            if (response.success === true) {
                if (apiRequestOptions.alertSuccess) {
                    DialogUtils.info('操作完成', apiRequestOptions.successMessage);
                }
                if (apiRequestOptions.notifySuccess) {
                    StatesUtils.create(StateNames.notify, {
                        title: '操作完成',
                        message: apiRequestOptions.successMessage
                    });
                }
                if (apiRequestOptions.onSuccess) {
                    return apiRequestOptions.onSuccess.call(requestOptions.context, response, requestOptions);
                }
                else {
                    if (apiRequestOptions.dataPath) {
                        return CommonsUtils.get(response.content, apiRequestOptions.dataPath);
                    }
                    return response.content || response;
                }
            }
            else if (!response.success === false) {
                if (apiRequestOptions.alertFailure) {
                    DialogUtils.error('操作失败', response.message);
                }
                if (apiRequestOptions.notifyFailure) {
                    StatesUtils.create(StateNames.notify, {
                        level: NotifyLevel.ERROR,
                        title: response.error,
                        message: response.message
                    });
                }
                if (apiRequestOptions.onFailure) {
                    return apiRequestOptions.onFailure.call(requestOptions.context, response, requestOptions);
                }
                return response;
            }
            return response;
        }), first());
    }
    /**
     * @private
     * @param {?} apiEntry
     * @param {?} payload
     * @param {?} options
     * @return {?}
     */
    static buildUri(apiEntry, payload, options) {
        /** @type {?} */
        let uri = apiEntry;
        if (CommonsUtils.isTemplateStr(apiEntry)) ;
        if (CommonsUtils.isString(options.uriResolver)) {
            uri = (/** @type {?} */ (options.uriResolver));
        }
        else if (CommonsUtils.isFunction(options.uriResolver)) {
            uri = ((/** @type {?} */ (options.uriResolver))).call(options.context, apiEntry, payload, options);
        }
        else if (!uri) {
            uri = options.uri || '';
        }
        if (!uri.startsWith('http')) {
            /** @type {?} */
            const serverUri = ApiUtils.getPresetApiOptions(options.serverType).uri;
            if (serverUri) {
                uri = serverUri + (uri.startsWith('/') ? uri : '/' + uri);
            }
        }
        return uri;
    }
    /**
     * @private
     * @param {?} apiEntry
     * @param {?} payload
     * @param {?} options
     * @return {?}
     */
    static buildPayload(apiEntry, payload, options) {
        /** @type {?} */
        let _payload = payload;
        if (CommonsUtils.isJson(_payload)) {
            _payload = CommonsUtils.merge({}, _payload || {}, options.payload || {}, options.body || options.params || {});
        }
        if (options.payloadResolver) {
            _payload = ((/** @type {?} */ (options.payloadResolver))).call(options.context, apiEntry, _payload, options);
        }
        if (CommonsUtils.isString(_payload)) {
            return _payload;
        }
        else if (CommonsUtils.isString(options.body)) {
            return options.body;
        }
        else if (CommonsUtils.isEmpty(_payload)) {
            return undefined;
        }
        _payload = ContextUtils.resolveVariables(_payload);
        _payload = ApiUtils.resolveApiParamsName(options.paramsKeys || ApiUtils.getPresetApiOptions(options.serverType).paramsKeys || {}, _payload);
        if (CommonsUtils.isEmpty(_payload)) {
            return undefined;
        }
        return _payload;
    }
    /**
     * @private
     * @param {?} paramsKeys
     * @param {?} payload
     * @return {?}
     */
    static resolveApiParamsName(paramsKeys, payload) {
        if (!CommonsUtils.isJson(payload)) {
            return payload;
        }
        /** @type {?} */
        const resolved = {};
        for (const key in payload) {
            if (paramsKeys.hasOwnProperty(key)) {
                resolved[paramsKeys[key]] = payload[key];
            }
            else {
                resolved[key] = payload[key];
            }
        }
        return resolved;
    }
}
ApiUtils.presetApiOptions = {};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ApiDataDirective extends BaseDirective {
    constructor() {
        super(...arguments);
        this.onDataReady = new EventEmitter();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.apiDataProps
            && changes.apiDataProps.currentValue
            && (this.apiDataProps.autoFetch !== false || !changes.apiDataProps.isFirstChange())) {
            this.fetchData();
        }
    }
    /**
     * @return {?}
     */
    fetchData() {
        if (CommonsUtils.isEmpty(this.apiDataProps)) {
            LogUtils.debug('apiDataDirective', '没有定义apiDataProps');
            return;
        }
        ApiUtils.fetch(this.apiDataProps)
            .subscribe(data => {
            LogUtils.debug(this, 'apiData待订阅数据', data);
            if (this.apiDataProps.data$) {
                this.apiDataProps.data$.next(data);
            }
            this.onDataReady.emit(data);
        });
    }
}
ApiDataDirective.decorators = [
    { type: Directive, args: [{
                selector: '[erApiData]'
            },] }
];
ApiDataDirective.propDecorators = {
    apiDataProps: [{ type: Input, args: ['erApiData',] }],
    onRequestData: [{ type: Output }],
    onDataReady: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class DataAwareControlWrapperComponent extends ControlWrapperComponent {
    constructor() {
        super(...arguments);
        this.data$ = new BehaviorSubject(undefined);
    }
    /**
     * @return {?}
     */
    get apiDataProps() {
        return this._apiDataProps || {};
    }
    /**
     * @param {?} props
     * @return {?}
     */
    set apiDataProps(props) {
        this._apiDataProps = props;
        if (this._apiDataProps && !this._apiDataProps.data$) {
            this._apiDataProps.data$ = this.data$;
        }
    }
    /**
     * @return {?}
     */
    onPropsInit() {
        super.onPropsInit();
        this.initLocalDataItem();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    parseValue(value) {
        try {
            if (value && this.$props.$ext.dataItemProps && !CommonsUtils.isString(value)) {
                return DataItemUtils.getItemValue(value, this.$props.$ext.dataItemProps.valueKey);
            }
            return value;
        }
        catch (e) {
            LogUtils.error(this, '数据解析错误', e);
            return undefined;
        }
    }
    /**
     * @param {?} model
     * @return {?}
     */
    formatModel(model) {
        try {
            if (CommonsUtils.isJson(model) && this.$props.$ext.dataItemProps) {
                return DataItemUtils.getItemLabel(model, this.$props.$ext.dataItemProps.labelKey);
            }
            return model;
        }
        catch (e) {
            LogUtils.error(this, '数据解析错误', e);
            return undefined;
        }
    }
    /**
     * @return {?}
     */
    initLocalDataItem() {
        if (this.$props.$ext && this.$props.$ext.dataItems) {
            /** @type {?} */
            let data = this.$props.$ext.dataItems;
            data = data.map(d => d['data'] = d);
            this.data$.next(data);
        }
    }
}
DataAwareControlWrapperComponent.propDecorators = {
    apiData: [{ type: ViewChild, args: [ApiDataDirective,] }],
    apiDataProps: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class BaseFormComponent extends BaseComponent {
    /**
     * @param {?} cd
     */
    constructor(cd) {
        super();
        this.cd = cd;
        this.options = {};
        this.buttonsStyleClass = 'text-center my-5';
        this.submitBtnStyleClass = 'btn btn-success';
        this.resetBtnStyleClass = 'btn btn-danger';
        this.initBtnStyleClass = 'btn btn-alert';
        this.onSubmit = new EventEmitter();
        this.onSubmitted = new EventEmitter();
        this.onModel = new EventEmitter();
        this.onFormValueChanges = new EventEmitter();
        this.form = new FormGroup({});
        this.templateNames = {
            header: 'header',
            buttons: 'buttons',
            footer: 'footer'
        };
        this.runtimeData = {};
        this.hasUpdated = false;
    }
    /**
     * @return {?}
     */
    get model() {
        return this._model;
    }
    /**
     * @param {?} model
     * @return {?}
     */
    set model(model) {
        this._model = CommonsUtils.omitBy(model, CommonsUtils.lodash().isUndefined);
        this.refresh();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        this.$subscriptions = this.form.valueChanges.subscribe(event => this.onFormValueChanges.emit(event));
    }
    /**
     * @return {?}
     */
    get modelId() {
        return this._modelId;
    }
    /**
     * @param {?} modelId
     * @return {?}
     */
    set modelId(modelId) {
        if (modelId !== this.modelId) {
            this._modelId = modelId;
            if (!modelId || modelId === '') {
                this.resetModel();
            }
            else if (this.apiEntry) {
                ApiUtils.getById(this.apiEntry, modelId, this.getModelOptions)
                    .subscribe(result => {
                    this.model = result;
                    this.form.updateValueAndValidity({ onlySelf: false, emitEvent: true });
                });
            }
        }
    }
    /**
     * @return {?}
     */
    get isFormValid() {
        if (!this.hasUpdated) {
            this.updateControls();
        }
        return this.form.valid;
    }
    /**
     * @return {?}
     */
    get httpTag() {
        return `http${'-' + this.formId || ''}`;
    }
    /**
     * @return {?}
     */
    get formId() {
        return this.$id;
    }
    /**
     * @return {?}
     */
    get submitModel() {
        /** @type {?} */
        let model = Object.assign({}, this.model);
        if (this.submitRootKey) {
            model = this.model[this.submitRootKey];
        }
        if (this.submitExcludeKeys) {
            model = CommonsUtils.removeKeys(model, ...CommonsUtils.getArrayValue(this.submitExcludeKeys));
        }
        Object.keys(model).forEach(key => {
            if (key.startsWith('$_')) {
                delete model[key];
            }
        });
        return model;
    }
    /**
     * @param {?} fieldName
     * @return {?}
     */
    formControl(fieldName) {
        return this.form.controls[fieldName];
    }
    /**
     * @param {?} fieldName
     * @return {?}
     */
    fieldComponent(fieldName) {
        return this.form['components'][fieldName];
    }
    /**
     * @return {?}
     */
    getFormErrorFields() {
        /** @type {?} */
        const errors = [];
        Object.keys(this.form.controls).forEach(key => {
            /** @type {?} */
            const controlErrors = this.form.get(key).errors;
            if (controlErrors != null) {
                Object.keys(controlErrors).forEach(keyError => {
                    errors.push(key); // + ', err value: ', controlErrors[keyError]);
                });
            }
        });
        return errors;
    }
    /**
     * @param {?} model
     * @return {?}
     */
    patchModel(model) {
        this.model = Object.assign({}, this.model || {}, model);
    }
    /**
     * @param {?} data
     * @return {?}
     */
    patchRuntimeData(data) {
        Object.assign(this.runtimeData, data);
    }
    /**
     * @param {?} path
     * @return {?}
     */
    isFieldValid(path) {
        /** @type {?} */
        const field = this.field(path);
        if (field) {
            return field.valid;
        }
        else {
            return undefined;
        }
    }
    /**
     * @param {?} fieldNamePath
     * @return {?}
     */
    isFieldTouched(fieldNamePath) {
        /** @type {?} */
        const field = this.field(fieldNamePath);
        if (field) {
            return field.touched;
        }
        else {
            return undefined;
        }
    }
    /**
     * @param {?=} form
     * @return {?}
     */
    updateControls(form) {
        if (!form) {
            form = this.form;
        }
        Object.keys(form.controls).forEach(field => {
            /** @type {?} */
            const control = form.get(field);
            if (control instanceof FormControl) {
                control.markAsTouched({ onlySelf: true });
                // control.updateValueAndValidity({onlySelf: true});
            }
            else if (control instanceof FormGroup) {
                this.updateControls(control);
            }
        });
        this.hasUpdated = true;
    }
    /**
     * @param {?} path
     * @return {?}
     */
    field(path) {
        return this.form.get(path);
    }
    /**
     * @return {?}
     */
    resetForm() {
        this.form.reset({});
    }
    /**
     * @param {?=} reset
     * @return {?}
     */
    resetModel(reset) {
        if (this.initModel) {
            this.model = CommonsUtils.copy(this.initModel);
        }
        else if (CommonsUtils.isJson(reset)) {
            this.model = Object.assign({}, reset);
        }
        else if (this.options['resetModel']) {
            this.options['resetModel']();
        }
        else {
            this.model = {};
        }
        this.form.reset(this.model, { emitEvent: true });
    }
    /**
     * @return {?}
     */
    setInitModel() {
        this.initModel = CommonsUtils.copy(this.model);
        if (this.options['updateInitialValue']) {
            this.options['updateInitialValue']();
        }
    }
    /**
     * @return {?}
     */
    refresh() {
        this.cd.detectChanges();
    }
    /**
     * @return {?}
     */
    submit() {
        if (!this.isFormValid) {
            DialogUtils.error('操作失败', '请填写完整信息后，再执行本操作！');
            return;
        }
        /** @type {?} */
        let result;
        if (this.beforeSubmit) {
            result = this.beforeSubmit(this.getEventContext());
            if (result instanceof Observable) {
                ((/** @type {?} */ (result)))
                    .pipe(first())
                    .subscribe(data => {
                    this.submitAfterBefore(data);
                });
            }
            else {
                this.submitAfterBefore(result);
            }
        }
        else {
            this.doSubmit();
        }
    }
    /**
     * @param {?=} submitModel
     * @return {?}
     */
    defaultSubmit(submitModel) {
        this.$subscriptions = ApiUtils.save.call(this, this.apiEntry, submitModel || this.submitModel, Object.assign({ tag: this.formId }, this.submitOptions || {}))
            .subscribe(data => {
            if (data.id && data.id !== this.model['id']) {
                this.model['id'] = data.id;
            }
            this.onSubmitted.emit(this.getEventContext({ response: data, model: this.model, submitted: submitModel || this.submitModel }));
            if (this.afterSubmit) {
                /** @type {?} */
                const result = this.afterSubmit(this.getEventContext({ submitModel: submitModel || this.submitModel, id: data.id }));
                if (result instanceof Observable) {
                    ((/** @type {?} */ (result)))
                        .pipe(first())
                        .subscribe(dat => {
                        this.doPostSubmit(dat);
                    });
                }
                else {
                    this.doPostSubmit(result);
                }
            }
            else {
                this.doPostSubmit();
            }
        });
    }
    /**
     * @param {?=} other
     * @return {?}
     */
    getEventContext(other) {
        return (Object.assign({ formlyForm: this, form: (/** @type {?} */ (this.form)), model: this.model, modelId: this.modelId, entry: this.apiEntry, entity: (/** @type {?} */ (this.entity)) }, other || {}));
    }
    /**
     * @private
     * @param {?} result
     * @return {?}
     */
    submitAfterBefore(result) {
        if (result !== false) {
            if (CommonsUtils.isJson(result) && !CommonsUtils.isEmpty(result)) {
                this.doSubmit(result);
            }
            else {
                this.doSubmit();
            }
        }
    }
    /**
     * @private
     * @param {?=} submitModel
     * @return {?}
     */
    doSubmit(submitModel) {
        if (this.onSubmit.observers.length > 0) {
            this.onSubmit.emit(this.getEventContext({ submitModel }));
        }
        else {
            this.defaultSubmit(submitModel);
        }
    }
    /**
     * @private
     * @param {?=} model
     * @return {?}
     */
    doPostSubmit(model) {
        if (model) {
            this.resetModel(model);
        }
        else if (this.resetKeys) {
            /** @type {?} */
            const keys = CommonsUtils.getArrayValue(this.resetKeys);
            keys.forEach(key => delete this.model[key]);
            delete this.model['id'];
            this.form.reset(this.model, { emitEvent: true });
        }
        else if (this.resetAfterSubmit !== false) {
            this.resetModel(this.entity && this.entity.initValue || {});
        }
    }
}
BaseFormComponent.propDecorators = {
    $id: [{ type: Input }],
    entity: [{ type: Input }],
    apiEntry: [{ type: Input }],
    options: [{ type: Input }],
    submitRootKey: [{ type: Input }],
    submitExcludeKeys: [{ type: Input }],
    resetKeys: [{ type: Input }],
    styleClass: [{ type: Input }],
    style: [{ type: Input }],
    formStyleClass: [{ type: Input }],
    formStyle: [{ type: Input }],
    buttonsStyleClass: [{ type: Input }],
    submitBtnStyleClass: [{ type: Input }],
    resetBtnStyleClass: [{ type: Input }],
    initBtnStyleClass: [{ type: Input }],
    header: [{ type: Input }],
    footer: [{ type: Input }],
    buttons: [{ type: Input }],
    getModelOptions: [{ type: Input }],
    submitOptions: [{ type: Input }],
    beforeSubmit: [{ type: Input }],
    afterSubmit: [{ type: Input }],
    valueChanges: [{ type: Input }],
    resetAfterSubmit: [{ type: Input }],
    onSubmit: [{ type: Output }],
    onSubmitted: [{ type: Output }],
    onModel: [{ type: Output }],
    onFormValueChanges: [{ type: Output }],
    model: [{ type: Input }],
    modelId: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const HTTP_STATE$ = StatesUtils.observe(StateNames.rootHttp)
    .pipe(distinctUntilChanged(), map(state => state && state.inProcess && state.inProcess > 0));
/** @type {?} */
const HTTP_TAG_STATE$ = (httpTag) => {
    return StatesUtils.observe(StateNames.http, httpTag)
        .pipe(distinctUntilChanged(), filter(state => !!state), map(state => state && state.start));
};
/** @type {?} */
const ROUTE_STATE$ = StatesUtils.observe(StateNames.nav)
    .pipe(distinctUntilChanged(), filter(state => !!state), map(state => state && state.start && state.outlet === 'primary'));
/** @type {?} */
const ROUTE_OUTLET_STATE$ = (outlet) => {
    return StatesUtils.observe(StateNames.nav)
        .pipe(distinctUntilChanged(), filter(state => !!state), map(state => state && state.start && state.outlet === outlet));
};
/** @type {?} */
const WEB_SOCKET_STATES = StatesUtils.observe(StateNames.socket)
    .pipe(distinctUntilChanged(), filter(state => !!state), map(state => state.state));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PermissionUtils {
    /**
     * @return {?}
     */
    static getPermissionsService() {
        if (!PermissionUtils._permissionsService) {
            PermissionUtils._permissionsService = DiUtils.get(NgxPermissionsService);
        }
        return PermissionUtils._permissionsService;
    }
    /**
     * @return {?}
     */
    static getRolesService() {
        if (!PermissionUtils._rolesService) {
            PermissionUtils._rolesService = DiUtils.get(NgxRolesService);
        }
        return PermissionUtils._rolesService;
    }
    /**
     * @param {?} roles
     * @return {?}
     */
    static getRolePermissions(roles) {
        return (ConfigUtils.getConfig().auth.getRolePermissions
            && ConfigUtils.getConfig().auth.getRolePermissions(roles))
            || of([]);
    }
    /**
     * @param {?} permissionName
     * @return {?}
     */
    static HasModulePermission(permissionName) {
        /** @type {?} */
        const permissions = PermissionUtils.getPermissionsService().getPermissions();
        /** @type {?} */
        const matched = Object.keys(permissions).some(name => {
            return name === permissionName
                || name.startsWith(permissionName + ':');
        });
        return matched && Object.keys(matched).length > 0;
    }
    /**
     * @param {?} permissions
     * @param {?=} validationFunction
     * @return {?}
     */
    static addPermissions(permissions, validationFunction) {
        PermissionUtils.getPermissionsService().addPermission(permissions, validationFunction);
    }
    /**
     * @param {?} roleName
     * @param {?=} validationFunction
     * @return {?}
     */
    static addRole(roleName, validationFunction) {
        if (!validationFunction) {
            validationFunction = () => true;
        }
        PermissionUtils.getRolesService().addRole(roleName, validationFunction);
    }
    /**
     * @param {?} roles
     * @return {?}
     */
    static addRoles(roles) {
        /** @type {?} */
        const _roles = CommonsUtils.getArrayValue(roles);
        if (_roles) {
            /** @type {?} */
            const roleService = PermissionUtils.getRolesService();
            _roles.filter(role => !!role).forEach(role => roleService.addRole(role, () => true));
        }
    }
    /**
     * @param {?} role
     * @return {?}
     */
    static hasRole(role) {
        /** @type {?} */
        const userRoles = PermissionUtils.getRolesService().getRoles();
        return userRoles.hasOwnProperty(role);
    }
    /**
     * @param {?} roles
     * @return {?}
     */
    static hasAnyRole(roles) {
        /** @type {?} */
        const _roles = CommonsUtils.getArrayValue(roles);
        /** @type {?} */
        const userRoles = PermissionUtils.getRolesService().getRoles();
        return _roles.some(role => userRoles.hasOwnProperty(role));
    }
    /**
     * @param {?} roles
     * @return {?}
     */
    static hasAllRoles(roles) {
        /** @type {?} */
        const _roles = CommonsUtils.getArrayValue(roles);
        /** @type {?} */
        const userRoles = PermissionUtils.getRolesService().getRoles();
        return _roles.every(role => userRoles.hasOwnProperty(role));
    }
    /**
     * @return {?}
     */
    static getPermissions() {
        return PermissionUtils.getPermissionsService().permissions$;
    }
    /**
     * @return {?}
     */
    static getRoles() {
        return PermissionUtils.getRolesService().roles$;
    }
    /**
     * @param {?} permission
     * @return {?}
     */
    static hasPermission(permission) {
        /** @type {?} */
        const userPermissions = PermissionUtils.getPermissionsService().getPermissions();
        return userPermissions.hasOwnProperty(permission);
    }
    /**
     * @param {?} permissios
     * @return {?}
     */
    static hasAnyPermission(permissios) {
        /** @type {?} */
        const _permissions = CommonsUtils.getArrayValue(permissios);
        /** @type {?} */
        const userPermissions = PermissionUtils.getPermissionsService().getPermissions();
        return _permissions.some(permisiion => userPermissions.hasOwnProperty(permisiion));
    }
    /**
     * @param {?} permissions
     * @return {?}
     */
    static hasAllPermissions(permissions) {
        /** @type {?} */
        const _permissions = CommonsUtils.getArrayValue(permissions);
        /** @type {?} */
        const userPermissions = PermissionUtils.getPermissionsService().getPermissions();
        return _permissions.every(permisiion => userPermissions.hasOwnProperty(permisiion));
    }
    /**
     * @param {?} roleOrPermission
     * @return {?}
     */
    static hasAuth(roleOrPermission) {
        return PermissionUtils.hasAnyRole(roleOrPermission) || PermissionUtils.hasAnyPermission(roleOrPermission);
    }
    /**
     * @param {?} roleOrPermissions
     * @return {?}
     */
    static hasAllAuths(roleOrPermissions) {
        return PermissionUtils.hasAllRoles(roleOrPermissions) || PermissionUtils.hasAllPermissions(roleOrPermissions);
    }
    /**
     * @return {?}
     */
    static clearRoles() {
        PermissionUtils.getRolesService().flushRoles();
    }
    /**
     * @return {?}
     */
    static clearPermission() {
        PermissionUtils.getPermissionsService().flushPermissions();
    }
}
PermissionUtils._permissionsService = null;
PermissionUtils._rolesService = null;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} route
 * @param {?} state
 * @return {?}
 */
function anyRoleUser(route, state) {
    if (AuthUtils.getCurrentUser().roles) {
        return AuthUtils.getCurrentUser().roles;
    }
    else {
        return 'NO_ROLE_USER';
    }
}
class AuthUtils {
    /**
     * @param {?} payLoad
     * @param {?=} isRememberMe
     * @return {?}
     */
    static login(payLoad, isRememberMe) {
        /** @type {?} */
        const login$ = ApiUtils.login(Object.assign({}, payLoad, { rememberMe: isRememberMe }), Object.assign({}, ConfigUtils.getConfig().auth.loginApiOptions || {}, { tag: StateNames.auth }))
            .pipe(filter(loginUser => !!loginUser), tap(loginUser => {
            if (loginUser.jwtToken) {
                if (ConfigUtils.getConfig().auth.getUserInfo) {
                    ConfigUtils.getConfig().auth.getUserInfo(loginUser)
                        .subscribe(userInfo => {
                        /** @type {?} */
                        const user = Object.assign({}, loginUser, userInfo);
                        AuthUtils.onLoginSuccess(user, isRememberMe);
                    });
                }
                else {
                    AuthUtils.onLoginSuccess(loginUser, isRememberMe);
                }
            }
        }));
        return login$;
    }
    /**
     * @param {?} payLoad
     * @return {?}
     */
    static register(payLoad) {
        /** @type {?} */
        const reg$ = ApiUtils.register(payLoad, Object.assign({}, ConfigUtils.getConfig().auth.registerApiOptions || ConfigUtils.getConfig().auth.loginApiOptions, { tag: StateNames.auth }));
        return reg$;
    }
    /**
     * @return {?}
     */
    static logout() {
        ApiUtils.logout(Object.assign({}, ConfigUtils.getConfig().auth.logoutApiOptions || ConfigUtils.getConfig().auth.loginApiOptions, { tag: StateNames.auth }))
            .subscribe(success => {
            if (success) {
                AuthUtils.updateUser({});
                PermissionUtils.clearRoles();
                PermissionUtils.clearPermission();
                /** @type {?} */
                const url = ConfigUtils.getConfig().auth.logoutSuccessRouter;
                RouteUtils.nav(url);
            }
        });
    }
    /**
     * @param {?} payload
     * @return {?}
     */
    static changePwd(payload) {
        /** @type {?} */
        const pwd$ = ApiUtils.changePwd(payload, Object.assign({}, ConfigUtils.getConfig().auth.changePwdApiOptions || ConfigUtils.getConfig().auth.loginApiOptions, { tag: StateNames.auth }));
        return pwd$;
    }
    /**
     * @return {?}
     */
    static getCurrentUser() {
        if (AuthUtils.CURRENT_USER) {
            return AuthUtils.CURRENT_USER || {};
        }
        /** @type {?} */
        const storageKey = ConfigUtils.getConfig().auth.storageKey;
        /** @type {?} */
        let user = (/** @type {?} */ ((JSON.parse(sessionStorage.getItem(storageKey)))));
        if (!user) {
            user = (/** @type {?} */ ((JSON.parse(localStorage.getItem(storageKey)))));
        }
        if (user && user.isSu) {
            user.isAdmin = true;
        }
        AuthUtils.CURRENT_USER = user;
        return AuthUtils.CURRENT_USER || {};
    }
    /**
     * @param {?} patch
     * @param {?=} remeber
     * @return {?}
     */
    static updateUser(patch, remeber) {
        if (!CommonsUtils.isEmpty(patch)) {
            AuthUtils.CURRENT_USER = Object.assign({}, AuthUtils.CURRENT_USER, patch);
        }
        else {
            AuthUtils.CURRENT_USER = {};
        }
        StatesUtils.update(StateNames.user, AuthUtils.CURRENT_USER);
        /** @type {?} */
        const storageKey = ConfigUtils.getConfig().auth.storageKey;
        sessionStorage.setItem(storageKey, JSON.stringify(AuthUtils.CURRENT_USER));
        if (remeber) {
            if (!CommonsUtils.isEmpty(AuthUtils.CURRENT_USER)) {
                localStorage.setItem(storageKey, JSON.stringify(AuthUtils.CURRENT_USER));
            }
            else {
                localStorage.removeItem(storageKey);
            }
        }
    }
    /**
     * @param {?} returnUrl
     * @return {?}
     */
    static checkLogin(returnUrl) {
        /** @type {?} */
        const currentUser = AuthUtils.getCurrentUser();
        if (currentUser.jwtToken && JwtUtils.isValid(currentUser.jwtToken)) {
            return true;
        }
        else {
            if (true === StatesUtils.getValue(StateNames.auth, 'dialog')) {
                StatesUtils.update(StateNames.popup, {
                    content: ConfigUtils.getConfig().auth.component,
                    header: ConfigUtils.getConfig().auth.title,
                    visible: true,
                    minWidth: 500,
                    minHeight: 300,
                    contentMaxWidth: 500,
                    contentMaxHeight: 300
                });
            }
            else {
                /** @type {?} */
                const loginRouter = ConfigUtils.getConfig().auth.loginRouter;
                StatesUtils.update(StateNames.auth, { successUrl: returnUrl });
                RouteUtils.nav(loginRouter);
            }
            return false;
        }
    }
    /**
     * @private
     * @param {?} user
     * @param {?} isRememberMe
     * @return {?}
     */
    static onLoginSuccess(user, isRememberMe) {
        if (ConfigUtils.getConfig().auth.onLoginSuccess) {
            ConfigUtils.getConfig().auth.onLoginSuccess(user);
        }
        user.enabled = true;
        AuthUtils.updateUser(user, isRememberMe);
        PermissionUtils.addRoles(user.roles);
        if (ConfigUtils.getConfig().auth.defaultRules) {
            PermissionUtils.addRoles(ConfigUtils.getConfig().auth.defaultRules);
        }
        PermissionUtils.addPermissions(user.permissions || []);
        /** @type {?} */
        const key = ConfigUtils.getConfig().auth.requiredUserProps;
        if (key) {
            if (!CommonsUtils.get(user, key)) {
                RouteUtils.nav(ConfigUtils.getConfig().auth.failedPropsRouter);
            }
            else {
                /** @type {?} */
                const successUrl = ConfigUtils.getConfig().auth.loginSuccessRouter;
                RouteUtils.nav(successUrl);
            }
        }
        else {
            /** @type {?} */
            const successUrl = ConfigUtils.getConfig().auth.loginSuccessRouter;
            RouteUtils.nav(successUrl);
        }
    }
}
AuthUtils.CURRENT_USER = null;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class AppConfigComponent {
    /**
     * @param {?} rootViewContainerRef
     */
    constructor(rootViewContainerRef) {
        this.rootViewContainerRef = rootViewContainerRef;
    }
    /**
     * @return {?}
     */
    get loadingClass() {
        return ConfigUtils.getConfig().onLoading;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        const browserSupport = BrowserOsUtils.checkBrowser();
        this.resolveBrowserSupport(browserSupport);
        ConfigUtils.configApp(this.appConfig());
        setTimeout(() => {
            this.httpState$ = HTTP_STATE$;
            this.routeState$ = ROUTE_STATE$;
        }, 0);
        /** @type {?} */
        const user = AuthUtils.getCurrentUser();
        if (!CommonsUtils.isEmpty(user)) {
            PermissionUtils.addPermissions(user.permissions);
            PermissionUtils.addRoles(user.roles);
            if (user.roles && ConfigUtils.getConfig().auth.defaultRules) {
                PermissionUtils.addRoles(ConfigUtils.getConfig().auth.defaultRules);
            }
        }
    }
    /**
     * @param {?} browserSupport
     * @return {?}
     */
    resolveBrowserSupport(browserSupport) {
        if (!browserSupport.version) {
            alert('当前浏览器版本太低，请升级浏览器!');
        }
        else if (!browserSupport.features) {
            alert('当前浏览器功能不全，请更换浏览器!');
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class ModuleConfigComponent extends BaseComponent {
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        const router = DiUtils.get(Router);
        ConfigUtils.configModule(this.moduleConfig() || {}, router.url);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AuthBaseComponent extends BaseComponent {
    constructor() {
        super();
        this.userToken = ConfigUtils.getConfig().auth.userTokenKey;
        this.password = ConfigUtils.getConfig().auth.passwordKey;
        this.rememberMe = ConfigUtils.getConfig().auth.rememberMeKey;
        this.appName = ConfigUtils.getConfig().appName;
        this.stateKey = StateNames.auth;
    }
    /**
     * @return {?}
     */
    login() {
        this.error = undefined;
        AuthUtils.login(this.getSubmitData(this.form.value))
            .subscribe(response => {
            if (response.success === false) {
                this.error = response.message;
            }
        });
    }
    /**
     * @return {?}
     */
    register() {
        this.error = undefined;
        /** @type {?} */
        const data = this.form.value;
        delete data['rePassword'];
        AuthUtils.register(this.getSubmitData(this.form.value))
            .subscribe(response => {
            if (response.success === false) {
                this.error = response.message;
            }
            else {
                RouteUtils.nav(ConfigUtils.getConfig().auth.loginSuccessRouter);
            }
        });
    }
    /**
     * @param {?} data
     * @return {?}
     */
    getSubmitData(data) {
        return data;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AbstractLoginComponent extends AuthBaseComponent {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.form = DiUtils.get(FormBuilder).group({
            [this.userToken]: ['', Validators.required],
            [this.password]: ['', Validators.required],
            [this.rememberMe]: ['']
        });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NgAsyncValidator = function (requestProps, errorKey) {
    /** @type {?} */
    const fn = (control) => {
        /** @type {?} */
        let props = requestProps;
        if (requestProps.query && CommonsUtils.isFunction(requestProps.query)) {
            /** @type {?} */
            const query = ((/** @type {?} */ (requestProps.query)))(control.value);
            props = Object.assign({}, props, { query });
        }
        /** @type {?} */
        const httpRequest = ApiUtils.fetch(props)
            .pipe(map(data => {
            return !data ? null : { [errorKey]: true };
        }));
        return httpRequest;
    };
    return fn;
};
/** @type {?} */
const FormlyAsyncValidator = function (requestProps) {
    /** @type {?} */
    const fn = (control) => {
        /** @type {?} */
        let props = requestProps;
        if (requestProps.query && CommonsUtils.isFunction(requestProps.query)) {
            /** @type {?} */
            const query = ((/** @type {?} */ (requestProps.query)))(control.value);
            props = Object.assign({}, props, { query });
        }
        /** @type {?} */
        const httpRequest = ApiUtils.fetch(props)
            .pipe(map(data => !data));
        return httpRequest.toPromise();
    };
    return fn;
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AbstractRegisterComponent extends AuthBaseComponent {
    constructor() {
        super(...arguments);
        this.checkExists = false;
        this.inFocus = false;
        this.errorMessage = {
            duplicated: '该用户名已经被注册'
        };
    }
    /**
     * @return {?}
     */
    get isUserNameValidate() {
        return !this.inFocus && this.form.get(this.userToken).valid;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.form = DiUtils.get(FormBuilder).group({
            [this.userToken]: new FormControl('', {
                validators: NgValidators.required,
                asyncValidators: NgAsyncValidator(this.userExistsApiOptions(), 'duplicated'),
                updateOn: 'blur'
            }),
            [this.password]: ['', [NgValidators.required, NgValidators.minLength(6)]],
            rePassword: ['', [NgValidators.required, NgValidators.minLength(6), NgValidators.equalTo(this.password)]]
        });
    }
    /**
     * @return {?}
     */
    userExistsApiOptions() {
        return {
            requestOptions: {
                serverType: ApiServerType.ER
            },
            apiEntry: 'user/exists',
            payload: (val) => {
                return { userName: val };
            }
        };
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AbstractChangePwdComponent extends AuthBaseComponent {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.form = DiUtils.get(FormBuilder).group({
            [this.oldPasswordKey]: ['', Validators.required],
            [this.newPasswordKey]: ['', [NgValidators.required, NgValidators.minLength(6)]],
            reNewPassword: ['', [NgValidators.required, NgValidators.minLength(6), NgValidators.equalTo(this.newPasswordKey)]]
        });
    }
    /**
     * @return {?}
     */
    changePwd() {
        this.error = undefined;
        /** @type {?} */
        const data = this.form.value;
        delete data['reNewPassword'];
        data['userPwdSetDate'] = DateUtils.getFormattedDateTime();
        AuthUtils.changePwd(this.getSubmitData(this.form.value))
            .subscribe(response => {
            if (response.success === true) {
                RouteUtils.nav(ConfigUtils.getConfig().auth.changePwdSuccessRouter);
            }
            else {
                this.error = response.message || '密码修改失败';
            }
        });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AnimateNumberComponent extends BaseComponent {
    /**
     * @param {?} cd
     */
    constructor(cd) {
        super();
        this.cd = cd;
        this.currentNumber = 0;
        this.fontSize = '.8em';
        this.counter$ = new Subject();
        this.$subscriptions = this.counter$
            .pipe(switchMap(endRange => {
            return timer(1000, 200)
                .pipe(mapTo(this.positiveOrNegative(endRange, this.currentNumber)), startWith(this.currentNumber), scan((acc, curr) => acc + curr), takeWhile(this.takeUntil(endRange, this.currentNumber)));
        }))
            .subscribe(val => {
            this.currentNumber = val;
            if (this.currentNumber === this.end) {
                this.fontSize = '1em';
            }
            this.cd.detectChanges();
        });
    }
    /**
     * @return {?}
     */
    get end() {
        return this._end;
    }
    /**
     * @param {?} endRange
     * @return {?}
     */
    set end(endRange) {
        this._end = endRange;
        this.currentNumber = endRange - CommonsUtils.getRandomNumber(20);
        this.counter$.next(endRange);
    }
    /**
     * @private
     * @param {?} endRange
     * @param {?} currentNumber
     * @return {?}
     */
    positiveOrNegative(endRange, currentNumber) {
        return endRange > currentNumber ? 1 : -1;
    }
    /**
     * @private
     * @param {?} endRange
     * @param {?} currentNumber
     * @return {?}
     */
    takeUntil(endRange, currentNumber) {
        return endRange > currentNumber
            ? val => val <= endRange
            : val => val >= endRange;
    }
}
AnimateNumberComponent.decorators = [
    { type: Component, args: [{
                selector: 'animate-number',
                template: `
    <span [ngStyle]="{'font-size': fontSize, 'font-weight': 'bold'}">
       {{currentNumber}}
    </span>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
AnimateNumberComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
AnimateNumberComponent.propDecorators = {
    end: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ROUTE_DATA_BREADCRUMB_KEY = 'breadcrumb';
class BreadcrumbsComponent extends BaseComponent {
    /**
     * @param {?} router
     * @param {?} route
     */
    constructor(router, route) {
        super();
        this.router = router;
        this.route = route;
        this.outlet = 'primary';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.breadcrumbs$ = StatesUtils.observe(StateNames.nav)
            .pipe(filter(state => state && state.status === 'success'), map(() => this.resolveRoute()));
    }
    /**
     * @param {?} breadcrumb
     * @return {?}
     */
    getRouterLink(breadcrumb) {
        if (breadcrumb.params) {
            return [breadcrumb.url, breadcrumb.params];
        }
        else {
            return [breadcrumb.url];
        }
    }
    /**
     * @private
     * @return {?}
     */
    resolveRoute() {
        /** @type {?} */
        const breadcrumbs = [];
        /** @type {?} */
        let currentRoute = this.route.root;
        /** @type {?} */
        const menus = StatesUtils.getValue(StateNames.rootMenu);
        /** @type {?} */
        let url;
        /** @type {?} */
        const prefix = CommonsUtils.get(ConfigUtils.getConfig(), 'breadcrumb.prefix');
        /** @type {?} */
        const excludes = CommonsUtils.get(ConfigUtils.getConfig(), 'breadcrumb.excludes');
        /** @type {?} */
        let lastLabel = '';
        do {
            /** @type {?} */
            const childrenRoutes = currentRoute.children;
            currentRoute = null;
            childrenRoutes.forEach(route => {
                if (route.outlet === this.outlet) {
                    /** @type {?} */
                    const routeSnapshot = route.snapshot;
                    /** @type {?} */
                    let label = null;
                    if (routeSnapshot.routeConfig && routeSnapshot.routeConfig.data && routeSnapshot.routeConfig.data[ROUTE_DATA_BREADCRUMB_KEY]) {
                        label = routeSnapshot.routeConfig.data[ROUTE_DATA_BREADCRUMB_KEY];
                    }
                    if (!label) {
                        /** @type {?} */
                        const currentUrl = routeSnapshot.url.join('/');
                        if (currentUrl && currentUrl.trim().length > 0) {
                            if (!url) {
                                url = currentUrl;
                            }
                            else {
                                url = url + '/' + currentUrl;
                            }
                        }
                        if (url && !RegUtils.test(url, excludes)) {
                            /** @type {?} */
                            const parts = url.split('/');
                            /** @type {?} */
                            const menu = CommonsUtils.deepFind(menus, { routerLink: url }, { routerLink: `/${url}` }, { name: parts[parts.length - 1] });
                            if (menu && menu.length > 0) {
                                label = ((/** @type {?} */ (menu[0]))).label;
                            }
                        }
                    }
                    if (label && label.length !== 0 && label !== lastLabel) {
                        if (url.length === 0) {
                            routeSnapshot.params = {};
                        }
                        breadcrumbs.push((/** @type {?} */ ({
                            label: label,
                            url: url,
                            params: routeSnapshot.params
                        })));
                    }
                    currentRoute = route;
                    lastLabel = label;
                }
            });
        } while (currentRoute);
        if (prefix) {
            return prefix.concat(breadcrumbs);
        }
        else {
            return breadcrumbs;
        }
    }
}
BreadcrumbsComponent.decorators = [
    { type: Component, args: [{
                selector: 'er-breadcrumbs',
                template: "<ol class=\"breadcrumb\">\n    <ng-container *ngTemplateOutlet=\"templates?.before\"></ng-container>\n    <ng-container *ngFor=\"let breadcrumb of breadcrumbs$|async;let last=last\">\n        <li class=\"breadcrumb-item\" [ngClass]=\"{active: last}\">\n            <a *ngIf=\"!last\" [routerLink]=\"getRouterLink(breadcrumb)\">{{breadcrumb.label}}</a>\n            <span *ngIf=\"last\">{{breadcrumb.label}}</span>\n        </li>\n    </ng-container>\n    <ng-container *ngTemplateOutlet=\"templates?.after\"></ng-container>\n</ol>\n",
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
BreadcrumbsComponent.ctorParameters = () => [
    { type: Router },
    { type: ActivatedRoute }
];
BreadcrumbsComponent.propDecorators = {
    outlet: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StateButtonComponent extends BaseComponent {
    /**
     * @param {?} cd
     */
    constructor(cd) {
        super();
        this.cd = cd;
        this.type = 'button';
        this.hint = '';
        this.onClick = new EventEmitter();
        this.onFocus = new EventEmitter();
        this.onBlur = new EventEmitter();
        this.processIcon = 'fa fa-cog fa-spin';
        this.processing$ = new Subject();
    }
    /**
     * @param {?} processing
     * @return {?}
     */
    set processing(processing) {
        this.processing$.next(processing);
        this.cd.markForCheck(); // used for not dom event modify
    }
    /**
     * @return {?}
     */
    get btnLabel() {
        if (this.processing) {
            return this.stateLabel || this.label;
        }
        else {
            return this.label || '';
        }
    }
    /**
     * @return {?}
     */
    get btnTitle() {
        if (this.processing) {
            return this.stateHint || '执行中...';
        }
        else {
            return this.hint || '';
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.stateKey) {
            this.$subscriptions = StatesUtils.observe(StateNames.http, this.stateKey)
                .pipe(filter(state => !!state), map(state => state['start'])).subscribe(b => this.processing$.next(b));
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    click(event) {
        this.onClick.emit(Object.assign({}, event, this.context || {}));
    }
}
StateButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'er-button',
                template: "<button *ngIf=\"!hidden\"\n        [attr.type]=\"type\"\n        [ngClass]=\"styleClass\"\n        [ngStyle]=\"style\"\n        [disabled]=\"disabled || (processing$|async) \"\n        [title]=\"hint\"\n        (click)=\"click($event)\"\n        (focus)=\"emitEvent('onFocus',$event)\"\n        (blur)=\"emitEvent('onBlur',$event)\"\n>\n  <i *ngIf=\"!iconRight && !(processing$|async)\" [ngClass]=\"icon\"></i> {{btnLabel}}\n  <ng-content></ng-content>\n  <i *ngIf=\"iconRight && !(processing$|async)\" [ngClass]=\"icon\"  ></i>\n  <i *ngIf=\"processing$|async\" [ngClass]=\"processIcon\" style=\"margin-left: 5px\"></i>\n</button>\n",
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
StateButtonComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
StateButtonComponent.propDecorators = {
    type: [{ type: Input }],
    hint: [{ type: Input }],
    label: [{ type: Input }],
    icon: [{ type: Input }],
    style: [{ type: Input }],
    hidden: [{ type: Input }],
    styleClass: [{ type: Input }],
    disabled: [{ type: Input }],
    iconRight: [{ type: Input }],
    stateKey: [{ type: Input }],
    stateLabel: [{ type: Input }],
    stateHint: [{ type: Input }],
    context: [{ type: Input }],
    onClick: [{ type: Output }],
    onFocus: [{ type: Output }],
    onBlur: [{ type: Output }],
    processing: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StateButtonsComponent extends BaseComponent {
}
StateButtonsComponent.decorators = [
    { type: Component, args: [{
                selector: 'er-buttons',
                template: `
    
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DataItemComponent extends BaseComponent {
    /**
     * @return {?}
     */
    get labels() {
        /** @type {?} */
        const _label = DataItemUtils.getItemLabel(this.item, this.labelKeys);
        if (CommonsUtils.isArray(_label)) {
            return _label;
        }
        else {
            return [_label];
        }
    }
    /**
     * @return {?}
     */
    get labelKeys() {
        /** @type {?} */
        let keys = this.props.dropDownOptionKey || this.props.labelKey;
        if (!keys) {
            if (this.item.hasOwnProperty('label')) {
                keys = 'label';
            }
            else {
                keys = Object.keys(this.item).filter(key => !key.startsWith('_') && key !== 'id');
            }
        }
        return keys;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.props) {
            this.props = {};
        }
    }
}
DataItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'er-data-item',
                template: `
    <ng-container *ngIf="props.template;else default">
      <er-dyna-content [content]="props.template" [context]="item"></er-dyna-content>
    </ng-container>
    <ng-template #default>
      <div class="d-flex data-item" [ngClass]="props.itemStyleClass || 'ui-clearfix'">
        <span class="label mr-3 border-right" *ngFor="let label of labels" [ngClass]="props.labelStyleClass" [innerHTML]="label"></span>
        <span class="pull-right count" *ngIf="props.showCounter && item['value']">
          <span [ngClass]="props.counterStyleClass || 'badge badge-pill badge-info'">{{item['value']}}</span>
        </span>
      </div>
    </ng-template>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: ["/deep/ .ui-autocomplete-list-item{border-bottom:1px solid #9f9f9f!important;font-size:.8em!important;color:#000!important}/deep/ .ui-autocomplete-list-item:hover{background-color:transparent!important;font-weight:700!important;color:red!important;font-size:1em!important}"]
            }] }
];
DataItemComponent.propDecorators = {
    item: [{ type: Input }],
    props: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const cacheKey$1 = '$component-factory';
class DynaComponentUtils {
    /**
     * @param {?} hostViewContainerRef
     * @param {?} componentType
     * @return {?}
     */
    static createComponentByType(hostViewContainerRef, componentType) {
        if (!componentType) {
            return;
        }
        /** @type {?} */
        let componentFactory = CacheUtils.get(cacheKey$1, componentType);
        if (!componentFactory) {
            componentFactory = DynaComponentUtils.getComponentFactoryResolver().resolveComponentFactory(componentType);
            CacheUtils.put(cacheKey$1, componentType, componentFactory);
        }
        return DynaComponentUtils.createComponent(hostViewContainerRef, componentFactory);
    }
    /**
     * @param {?} hostViewContainerRef
     * @param {?} template
     * @return {?}
     */
    static createComponentByTemplate(hostViewContainerRef, template) {
        if (!template) {
            return;
        }
        /** @type {?} */
        let componentFactory = CacheUtils.get(cacheKey$1, template);
        if (!componentFactory) {
            /** @type {?} */
            const component = DynaComponentUtils.createDecoratedComponent(null, template);
            /** @type {?} */
            const module = DynaComponentUtils.createNgModule(component);
            componentFactory = module.componentFactories.find(factory => factory.componentType === component);
            CacheUtils.put(cacheKey$1, template, componentFactory);
        }
        return DynaComponentUtils.createComponent(hostViewContainerRef, componentFactory);
    }
    /**
     * @private
     * @return {?}
     */
    static getComponentFactoryResolver() {
        if (!DynaComponentUtils._componentFactoryResolver) {
            DynaComponentUtils._componentFactoryResolver = DiUtils.get(ComponentFactoryResolver);
        }
        return DynaComponentUtils._componentFactoryResolver;
    }
    /**
     * @private
     * @param {?} useClass
     * @param {?} template
     * @return {?}
     */
    static createDecoratedComponent(useClass, template) {
        /** @type {?} */
        const componentClass = useClass || class {
        };
        return Component({
            template: template
        })(componentClass);
    }
    /**
     * @private
     * @param {?} component
     * @return {?}
     */
    static createNgModule(component) {
        /** @type {?} */
        const ngModule = NgModule({ declarations: [component] })(class {
        });
        return DiUtils.get(Compiler).compileModuleAndAllComponentsSync(ngModule);
    }
    /**
     * @private
     * @param {?} hostViewContainerRef
     * @param {?} componentFactory
     * @return {?}
     */
    static createComponent(hostViewContainerRef, componentFactory) {
        hostViewContainerRef.clear();
        /** @type {?} */
        const componentRef = hostViewContainerRef.createComponent(componentFactory);
        return componentRef;
    }
}
DynaComponentUtils._componentFactoryResolver = null;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DynaCompComponent {
    /**
     * @param {?} viewContainerRef
     * @param {?} el
     * @param {?} renderer
     */
    constructor(viewContainerRef, el, renderer) {
        this.viewContainerRef = viewContainerRef;
        this.el = el;
        this.renderer = renderer;
        this.onCreated = new EventEmitter();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.type) {
            this.createComponent();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.component) {
            this.component.destroy();
            this.component = null;
        }
    }
    /**
     * @private
     * @return {?}
     */
    createComponent() {
        if (this.type) {
            if (CommonsUtils.isString(this.type)) {
                this.component = DynaComponentUtils.createComponentByTemplate(this.viewContainerRef, (/** @type {?} */ (this.type)));
            }
            else {
                this.component = DynaComponentUtils.createComponentByType(this.viewContainerRef, (/** @type {?} */ (this.type)));
            }
            ComponentUtils.bind(this.component.instance, this.props);
            this.onCreated.emit(this.component);
            /** @type {?} */
            const parent = this.el.nativeElement.parentNode;
            this.renderer.removeChild(parent, this.el.nativeElement);
        }
    }
}
DynaCompComponent.decorators = [
    { type: Component, args: [{
                selector: 'er-dyna-component',
                template: '',
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
DynaCompComponent.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: ElementRef },
    { type: Renderer2 }
];
DynaCompComponent.propDecorators = {
    type: [{ type: Input }],
    props: [{ type: Input }],
    onCreated: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} val
 * @return {?}
 */
function createNewChange(val) {
    return new SimpleChange(undefined, val, true);
}
/**
 * @param {?} record
 * @param {?=} isFirstChange
 * @return {?}
 */
function recordToChange(record, isFirstChange = false) {
    return isFirstChange
        ? createNewChange(record.currentValue)
        : new SimpleChange(record.previousValue, record.currentValue, false);
}
/**
 * @param {?} isFirstChanges
 * @param {?} setter
 * @return {?}
 */
function setChangeFromRecord(isFirstChanges, setter) {
    return (record) => setter(record, recordToChange(record, isFirstChanges));
}
/**
 * @param {?} isFirstChanges
 * @return {?}
 */
function getChangesRecords(isFirstChanges) {
    return (changes) => setChangeFromRecord(isFirstChanges, (record, change) => changes[record.key] = change);
}
/**
 * @param {?} isFirstChanges
 * @return {?}
 */
function getNewChangesRecords(isFirstChanges) {
    return (changes) => setChangeFromRecord(isFirstChanges, (record, change) => {
        if (!changes[record.key]) {
            changes[record.key] = change;
        }
    });
}
/** @type {?} */
const defaultOpts = {
    isFirstChanges: false,
    onlyNewChanges: false,
};
/**
 * @param {?=} opts
 * @return {?}
 */
function changesFromRecord(opts = defaultOpts) {
    return opts.onlyNewChanges
        ? getNewChangesRecords(opts.isFirstChanges)
        : getChangesRecords(opts.isFirstChanges);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const recordToChanges = changesFromRecord({ isFirstChanges: true });
/** @type {?} */
const recordToNewChanges = changesFromRecord({ onlyNewChanges: true });
class PropsBindDirective extends BaseDirective {
    /**
     * @param {?} differs
     * @param {?} elementRef
     * @param {?} renderer
     * @param {?} viewContainerRef
     */
    constructor(differs, elementRef, renderer, viewContainerRef) {
        super();
        this.differs = differs;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.viewContainerRef = viewContainerRef;
        this.autoBind = true;
        this.differ = this.differs.find({}).create();
        this._hostComponentInst = undefined;
        this._viewComponentRef = undefined;
    }
    /**
     * @return {?}
     */
    get hostComponentInst() {
        if (this._hostComponentInst === undefined) {
            this._hostComponentInst = ComponentUtils.getHostComponentInst(this.viewContainerRef);
        }
        return this._hostComponentInst;
    }
    /**
     * @return {?}
     */
    get viewComponentRef() {
        if (this._viewComponentRef === undefined) {
            this._viewComponentRef = ComponentUtils.getViewComponentRef(this.viewContainerRef);
        }
        return this._viewComponentRef;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.autoBind) {
            if (changes.props && !CommonsUtils.isEmpty(this.props)) {
                this.resolveProps();
                this.differs.find({}).create();
                LogUtils.debug(this, '属性绑定', this.props, this.inputs, this.outputs, this.hooks);
                if (this.methods) {
                    this.bindMethods();
                }
                if (this.inputs) {
                    /** @type {?} */
                    const inputsChanges = this.differ.diff(this.inputs);
                    this.expInputs = this.getExpressionInputs(this.inputs);
                    if (inputsChanges) {
                        this.updateInputsChanges(inputsChanges);
                        this.updateInputs(!this.lastInputChanges);
                    }
                }
                if (this.outputs) {
                    /** @type {?} */
                    const outputsChanges = this.differ.diff(this.outputs);
                    if (outputsChanges) {
                        this.bindOutputs();
                    }
                }
                if (this.hooks) {
                    this.bindLifeCycles();
                }
                if (changes.props.isFirstChange()) {
                    if (this.hostComponentInst._propsBind) {
                        this.hostComponentInst._propsBind();
                    }
                }
            }
            if (changes.attrs && this.attrs) {
                this.resolveAttrs();
                /** @type {?} */
                const attrChanges = this.differ.diff(this.attrs);
                if (attrChanges) {
                    this.lastAttrChanges = this.changesToAttrChanges(attrChanges);
                    this.updateAttributes(this.lastAttrChanges);
                }
                // this.expAttrs = this.getExpressionInputs(this.attrs);
            }
        }
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this.attrs && this.autoBind) {
            if (this.expAttrs && Object.keys(this.expAttrs).length > 0) {
                Object.keys(this.expAttrs).forEach(key => {
                    this.attrs[key] = this.expAttrs[key].call(this, this.getEventContext());
                });
            }
            /** @type {?} */
            const attrChanges = this.differ.diff(this.attrs);
            if (attrChanges) {
                this.lastAttrChanges = this.changesToAttrChanges(attrChanges);
                this.updateAttributes(this.lastAttrChanges);
            }
        }
        if (this.inputs && this.autoBind) {
            if (this.expInputs && Object.keys(this.expInputs).length > 0) {
                Object.keys(this.expInputs).forEach(key => {
                    /** @type {?} */
                    const result = this.expInputs[key](this.getEventContext());
                    if (result instanceof Observable) {
                        this.$subscriptions = ((/** @type {?} */ (result))).subscribe(data => {
                            this.inputs[key] = data;
                        });
                    }
                    else {
                        this.inputs[key] = result;
                    }
                });
            }
            /** @type {?} */
            const inputsChanges = this.differ.diff(this.inputs);
            if (inputsChanges) {
                /** @type {?} */
                const isNotFirstChange = !!this.lastInputChanges;
                this.updateInputsChanges(inputsChanges);
                if (isNotFirstChange) {
                    this.updateInputs();
                }
            }
        }
    }
    /**
     * @param {?=} event
     * @return {?}
     */
    getEventContext(event) {
        return Object.assign({}, event, { $from: this.hostComponentInst }, this.context || {});
    }
    /**
     * @private
     * @param {?=} isFirstChange
     * @return {?}
     */
    updateInputs(isFirstChange = false) {
        if (!this.hostComponentInst || !this.inputs) {
            return;
        }
        Object.keys(this.inputs)
            .forEach(p => (this.hostComponentInst[p] = this.inputs[p]));
        this.notifyOnInputChanges(this.lastInputChanges, isFirstChange);
    }
    /**
     * @private
     * @return {?}
     */
    bindOutputs() {
        this.stopSubscribe();
        if (!this.outputs) {
            return;
        }
        Object.keys(this.outputs)
            .filter(p => this.hostComponentInst[p])
            .forEach(p => this.$subscriptions = ((/** @type {?} */ (this.hostComponentInst[p])))
            .subscribe(event => {
            try {
                this.outputs[p](this.getEventContext(event));
            }
            catch (e) {
                LogUtils.error(this.hostComponentInst, '操作失败', e);
            }
        }));
    }
    /**
     * @private
     * @return {?}
     */
    bindLifeCycles() {
        /** @type {?} */
        const constructor = ComponentUtils.getConstructor(this.hostComponentInst);
        /** @type {?} */
        const destructor = constructor.prototype['ngOnDestroy'];
        ComponentUtils.bindLifeCycles(this.hostComponentInst, this.hooks, constructor, destructor);
    }
    /**
     * @private
     * @return {?}
     */
    bindMethods() {
        if (this.methods) {
            Object.keys(this.methods).forEach(method => {
                this.hostComponentInst[method] = this.methods[method].bind(this.hostComponentInst);
            });
        }
    }
    /**
     * @private
     * @param {?=} changes
     * @param {?=} forceFirstChanges
     * @return {?}
     */
    notifyOnInputChanges(changes = {}, forceFirstChanges) {
        if (!this.hostComponentInst.ngOnChanges) {
            return;
        }
        if (forceFirstChanges) {
            changes = this.collectFirstChanges();
        }
        this.hostComponentInst.ngOnChanges(changes);
        if (this.hostComponentInst.cd && this.hostComponentInst.cd.detectChanges) {
            this.hostComponentInst.cd.detectChanges();
        }
    }
    /**
     * @private
     * @param {?} props
     * @return {?}
     */
    getExpressionInputs(props) {
        if (props) {
            /** @type {?} */
            const expProps = {};
            Object.keys(props).forEach(key => {
                if (props[key] instanceof Function) {
                    expProps[key] = props[key];
                }
            });
            return expProps;
        }
        return undefined;
    }
    /**
     * @private
     * @param {?} differ
     * @return {?}
     */
    updateInputsChanges(differ) {
        this.lastInputChanges = this.collectChangesFromDiffer(differ);
    }
    /**
     * @private
     * @return {?}
     */
    collectFirstChanges() {
        /** @type {?} */
        const changes = (/** @type {?} */ ({}));
        /** @type {?} */
        const inputs = this.inputs;
        Object.keys(inputs)
            .forEach(prop => (changes[prop] = new SimpleChange(undefined, inputs[prop], true)));
        return changes;
    }
    /**
     * @private
     * @param {?} differ
     * @return {?}
     */
    collectChangesFromDiffer(differ) {
        /** @type {?} */
        const changes = (/** @type {?} */ ({}));
        differ.forEachAddedItem(recordToChanges(changes));
        differ.forEachItem(recordToNewChanges(changes));
        return changes;
    }
    /**
     * @private
     * @param {?} changes
     * @return {?}
     */
    changesToAttrChanges(changes) {
        /** @type {?} */
        const attrChanges = {
            set: {},
            remove: []
        };
        changes.forEachAddedItem(r => (attrChanges.set[r.key] = r.currentValue));
        changes.forEachChangedItem(r => (attrChanges.set[r.key] = r.currentValue));
        changes.forEachRemovedItem(r => attrChanges.remove.push(r.key));
        return attrChanges;
    }
    /**
     * @private
     * @param {?} actions
     * @return {?}
     */
    updateAttributes(actions) {
        Object.keys(actions.set).forEach(key => this.setAttribute(key, actions.set[key]));
        actions.remove.forEach(key => this.removeAttribute(key));
    }
    /**
     * @private
     * @param {?} name
     * @param {?} value
     * @param {?=} namespace
     * @return {?}
     */
    setAttribute(name, value, namespace) {
        this.renderer.setAttribute(this.elementRef.nativeElement, name, value, namespace);
    }
    /**
     * @private
     * @param {?} name
     * @param {?=} namespace
     * @return {?}
     */
    removeAttribute(name, namespace) {
        this.renderer.removeAttribute(this.elementRef.nativeElement, name, namespace);
    }
    /**
     * @private
     * @return {?}
     */
    resolveProps() {
        if (this.hostComponentInst && CommonsUtils.isJson(this.props)) {
            this.inputs = {};
            this.outputs = {};
            if (this.hostComponentInst._initProps) {
                this.hostComponentInst.$props = CommonsUtils.merge({}, this.props);
                this.hostComponentInst._initProps();
                this.props = CommonsUtils.merge({}, this.hostComponentInst.$props);
            }
            if (!this.props['$id']) {
                this.props['$id'] = IdUtils.getRandom();
            }
            if (this.props['methods']) {
                this.methods = this.props['methods'];
                delete this.props['methods'];
            }
            if (this.props['hooks']) {
                this.hooks = this.props['hooks'];
                delete this.props['hooks'];
            }
            // else if (this.props['$ext'] && this.props['$ext'].hooks) {
            //   this.hooks = this.props['$ext'].hooks;
            //   delete this.props['$ext'].hooks;
            // }
            if (this.hostComponentInst instanceof WrapperComponent) {
                this.props = CommonsUtils.get(this.props, '$ext', {});
                if (this.props['hooks']) {
                    this.hooks = this.props['hooks'];
                    delete this.props['hooks'];
                }
            }
            else {
                this.props = CommonsUtils.omit(this.props, '$ext');
            }
            Object.keys(this.props).forEach(key => {
                if (this.hostComponentInst[key] instanceof EventEmitter) {
                    this.outputs[key] = this.props[key];
                }
                else {
                    this.inputs[key] = this.props[key];
                }
            });
            if (Object.keys(this.inputs).length === 0) {
                this.inputs = undefined;
            }
            if (Object.keys(this.outputs).length === 0) {
                this.outputs = undefined;
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    resolveAttrs() {
        if (this.hostComponentInst instanceof WrapperComponent) {
            this.attrs = CommonsUtils.get(this.attrs, '$ext', {});
        }
        else {
            this.attrs = CommonsUtils.omit(this.attrs, '$ext');
        }
    }
}
PropsBindDirective.decorators = [
    { type: Directive, args: [{
                selector: '[erPropsBind]'
            },] }
];
/** @nocollapse */
PropsBindDirective.ctorParameters = () => [
    { type: KeyValueDiffers },
    { type: ElementRef },
    { type: Renderer2 },
    { type: ViewContainerRef }
];
PropsBindDirective.propDecorators = {
    props: [{ type: Input }],
    context: [{ type: Input }],
    attrs: [{ type: Input }],
    autoBind: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DynaContentComponent extends BaseComponent {
    /**
     * @param {?} cd
     */
    constructor(cd) {
        super();
        this.cd = cd;
        this.CONTENT_TYPE = ContentType;
        this.parsedContent$ = new BehaviorSubject$1(undefined);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.parse();
    }
    /**
     * @return {?}
     */
    refresh() {
        this.parse();
        this.cd.markForCheck();
    }
    /**
     * @private
     * @return {?}
     */
    parse() {
        if (CommonsUtils.isJson(this.content)) {
            if (this.content['content']) {
                if (this.content['styleClass']) {
                    this.styleClass = this.content['styleClass'];
                }
                if (this.content['style']) {
                    this.style = this.content['style'];
                }
                this.content = this.content['content'];
            }
            if (this.content['data']) {
                this.contentType = ContentType.DATA;
                this.parsedContent = [];
                Object.keys(this.content['data']).forEach(key => {
                    this.parsedContent.push({
                        key,
                        value: CommonsUtils.getText(this.content['data'][key])
                    });
                });
                return;
            }
            else if (this.content['type']) {
                this.contentType = ContentType.COMPONENT;
                this.dynaComponent = (/** @type {?} */ (this.content));
                /** @type {?} */
                let directives = this.dynaComponent.directives;
                /** @type {?} */
                const dynaDirectives = [];
                if (directives) {
                    directives = CommonsUtils.getArrayValue(directives);
                    directives.filter(direct => !!direct.type).forEach(direct => {
                        dynaDirectives.push(dynamicDirectiveDef(direct.type, direct.inputs, direct.outputs));
                    });
                }
                if (this.dynaComponent.props || this.context) {
                    dynaDirectives.push(dynamicDirectiveDef(PropsBindDirective, Object.assign({}, this.dynaComponent.props || {}, this.context || {})));
                }
                this.dynaComponent.directives = dynaDirectives;
                return;
            }
            else {
                this.parsedContent = ((/** @type {?} */ (this.content))).content;
                this.parsedContext = Object.assign({}, ((/** @type {?} */ (this.content))).context || {}, this.context || {});
            }
        }
        else {
            this.parsedContent = this.content;
            this.parsedContext = this.context;
        }
        if (CommonsUtils.isString(this.parsedContent)) {
            if (CommonsUtils.isTemplateStr(this.parsedContent)) {
                this.parsedContent = CommonsUtils.templateStr(this.parsedContent, this.context) || '<span></span>';
                this.contentType = ContentType.TEMPLATE_STR;
            }
            else {
                this.contentType = ContentType.STRING;
            }
        }
        else if (this.parsedContent instanceof TemplateRef) {
            this.contentType = ContentType.TEMPLATE;
        }
        else if (CommonsUtils.isFunction(this.parsedContent)) {
            this.parsedContextFn = this.parsedContent;
            /** @type {?} */
            const rtn = this.parsedContextFn(this.parsedContext);
            if (rtn instanceof Observable) {
                ((/** @type {?} */ (rtn))).subscribe(result => this.parsedContent$.next(CommonsUtils.toString(result)));
            }
            else {
                this.parsedContent$.next(rtn);
            }
            this.contentType = ContentType.FUNCTION;
        }
    }
}
DynaContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'er-dyna-content',
                template: `
    <ng-container [ngSwitch]="contentType">
      <div *ngSwitchCase="CONTENT_TYPE.STRING" [ngClass]="styleClass" [ngStyle]="style" [innerHTML]="parsedContent|erSafeHtml"></div>
      <div *ngSwitchCase="CONTENT_TYPE.DATA" class="d-flex" [ngClass]="styleClass" [ngStyle]="style">
        <div *ngFor="let item of parsedContent" class="d-flex justify-content-center m-3">
          <span class="mr-2 font-weight-bold">{{item.key}}</span>
          <span [innerHTML]="item.value|erSafeHtml"></span>
        </div>
      </div>
      <span *ngSwitchCase="CONTENT_TYPE.TEMPLATE_STR" [innerHTML]="parsedContent" [ngClass]="styleClass"
            [ngStyle]="style"></span>
      <ng-container *ngSwitchCase="CONTENT_TYPE.FUNCTION">
        <ng-container *ngIf="parsedContent$|async as asyncContent">
          <span [innerHTML]="asyncContent" [ngClass]="styleClass" [ngStyle]="style"></span>
        </ng-container>
      </ng-container>
      <ng-container *ngSwitchCase="CONTENT_TYPE.TEMPLATE">
        <ng-container *ngTemplateOutlet="parsedContent;context:parsedContext"></ng-container>
      </ng-container>
      <ng-container *ngSwitchCase="CONTENT_TYPE.COMPONENT">
        <ndc-dynamic [ndcDynamicComponent]="dynaComponent.type"
                     [ndcDynamicDirectives]="dynaComponent.directives"
                     [ndcDynamicAttributes]="dynaComponent.attrs"
        >
        </ndc-dynamic>
      </ng-container>
    </ng-container>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
DynaContentComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
DynaContentComponent.propDecorators = {
    content: [{ type: Input }],
    context: [{ type: Input }],
    styleClass: [{ type: Input }],
    style: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HttpStatusComponent extends BaseComponent {
    constructor() {
        super(...arguments);
        this.loadingClass = 'loading-circle';
    }
    /**
     * @return {?}
     */
    get httpState$() {
        /** @type {?} */
        let subject;
        if (!this.tag) {
            subject = HTTP_STATE$;
        }
        else {
            subject = HTTP_TAG_STATE$(this.tag);
        }
        return subject;
    }
}
HttpStatusComponent.decorators = [
    { type: Component, args: [{
                selector: 'er-http-status',
                template: `    
      <ng-container *ngIf="httpState$|async">
        <ng-container *ngTemplateOutlet="template('_',default)"></ng-container>
        <ng-template #default>
          <div [ngClass]="loadingClass"></div>
        </ng-template>
      </ng-container>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
HttpStatusComponent.propDecorators = {
    tag: [{ type: Input }],
    loadingClass: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ContainerComponent {
    constructor() {
        this.styleClass = 'container';
    }
}
ContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'er-container',
                template: `
    <div [ngClass]="styleClass">
       <ng-content></ng-content>
     </div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
ContainerComponent.propDecorators = {
    styleClass: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FluidContainerComponent {
    constructor() {
        this.styleClass = 'container-fluid';
    }
}
FluidContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'er-fluid-container',
                template: `
    <div [ngClass]="styleClass">
       <ng-content></ng-content>
     </div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
FluidContainerComponent.propDecorators = {
    styleClass: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LeftRightContainerComponent extends BaseComponent {
    constructor() {
        super(...arguments);
        this.leftStyleClass = 'col-3';
        this.rightStyleClass = 'col-9';
        this.switchable = true;
        this.onLeftHide = new EventEmitter();
        this.templateNames = {
            left: 'left',
            right: 'right'
        };
    }
    /**
     * @param {?} event
     * @return {?}
     */
    reLayout(event) {
        this.hideLeft = event;
        this.onLeftHide.emit(event);
    }
}
LeftRightContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'er-left-right',
                template: `
    <div class="d-flex">
      <div *ngIf="!hideLeft" class="w-25 shadow-lg">
        <ng-container *ngTemplateOutlet="template(templateNames.left)"></ng-container>
      </div>
      <div class="flex-grow-1">
        <div *ngIf="switchable">
          <i class="fa fa-2x  text-primary" [title]="hideLeft?'展开左侧内容':'收起左侧内容'"
             [ngClass]="hideLeft?'fa-arrow-circle-right':'fa-arrow-circle-left'"
             (click)="reLayout(!hideLeft)"></i>
        </div>
        <ng-container *ngTemplateOutlet="template(templateNames.right)"></ng-container>
      </div>
    </div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
LeftRightContainerComponent.propDecorators = {
    leftStyleClass: [{ type: Input }],
    rightStyleClass: [{ type: Input }],
    hideLeft: [{ type: Input }],
    switchable: [{ type: Input }],
    onLeftHide: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const MobileType = {
    iphoneX: 'iphone-x',
    iphone8: 'iphone8',
    iphone8plus: 'iphone8plus',
    iphone5s: 'iphone5s',
    nexus5: 'nexus5',
    ipad: 'ipad',
    note8: 'note8',
    macbook: 'macbook',
};
class PhonePreviewComponent extends BaseComponent {
    constructor() {
        super(...arguments);
        this.MOBILE_TYPE = MobileType;
        this.mobile = MobileType.iphone8;
        this.isLandscape = false;
        this.scale = 1;
    }
    /**
     * @return {?}
     */
    zoomIn() {
        if (this.scale > 0.25) {
            this.scale = (this.scale - 0.25);
        }
    }
    /**
     * @return {?}
     */
    zoomOut() {
        if (this.scale < 2) {
            this.scale = (this.scale + 0.25);
        }
    }
}
PhonePreviewComponent.decorators = [
    { type: Component, args: [{
                selector: 'er-phone-preview',
                template: "<!--http://marvelapp.github.io/devices.css/-->\n\n<div [ngStyle]=\"{zoom:scale}\">\n  <span style=\"display: block\">\n    <i class=\"fa fa-search-minus pull-left\" (click)=\"zoomIn()\"></i>\n    <i class=\"fa fa-search-plus pull-right\" (click)=\"zoomOut()\"></i>\n  </span>\n\n  <ng-container *ngIf=\"mobile === MOBILE_TYPE.ipad\">\n    <ng-container *ngTemplateOutlet=\"ipad\"></ng-container>\n  </ng-container>\n\n  <ng-container *ngIf=\"mobile === MOBILE_TYPE.iphone8\">\n    <ng-container *ngTemplateOutlet=\"iphone8\"></ng-container>\n  </ng-container>\n</div>\n\n\n<ng-template #ipad>\n  <div class=\"mobile-face ipad {{color || 'silver'}}\" [ngClass]=\"{landscape: isLandscape}\">\n    <div class=\"camera\"></div>\n    <div class=\"screen\">\n      <ng-content></ng-content>\n    </div>\n    <div class=\"home\"></div>\n  </div>\n</ng-template>\n\n<ng-template #iphone8>\n  <div class=\"mobile-face iphone8 {{color || 'black'}}\" [ngClass]=\"{landscape: isLandscape}\">\n    <div class=\"top-bar\"></div>\n    <div class=\"sleep\"></div>\n    <div class=\"volume\"></div>\n    <div class=\"camera\"></div>\n    <div class=\"sensor\"></div>\n    <div class=\"speaker\"></div>\n    <div class=\"screen\">\n      <ng-content></ng-content>\n    </div>\n    <div class=\"home\"></div>\n    <div class=\"bottom-bar\"></div>\n  </div>\n</ng-template>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".mobile-face{display:inline-block;position:relative;box-sizing:content-box!important}.mobile-face .screen{width:100%;position:relative;height:100%;z-index:3;background:#fff;overflow-y:scroll;display:block;border-radius:1px;box-shadow:0 0 0 3px #111}.mobile-face .bottom-bar,.mobile-face .top-bar{height:3px;background:#000;width:100%;display:block}.mobile-face .middle-bar{width:3px;height:4px;top:0;left:90px;background:#000;position:absolute}.mobile-face.iphone8{width:375px;height:667px;padding:105px 24px;background:#d9dbdc;border-radius:56px;box-shadow:inset 0 0 3px 0 rgba(0,0,0,.2)}.mobile-face.iphone8:before{width:calc(100% - 12px);height:calc(100% - 12px);position:absolute;top:6px;content:'';left:6px;border-radius:50px;background:#f8f8f8;z-index:1}.mobile-face.iphone8:after{width:calc(100% - 16px);height:calc(100% - 16px);position:absolute;top:8px;content:'';left:8px;border-radius:48px;box-shadow:inset 0 0 3px 0 rgba(0,0,0,.1),inset 0 0 6px 3px #fff;z-index:2}.mobile-face.iphone8 .home{border-radius:100%;width:68px;height:68px;position:absolute;left:50%;margin-left:-34px;bottom:22px;z-index:3;background:#303233;background:linear-gradient(135deg,#303233 0,#b5b7b9 50%,#f0f2f2 69%,#303233 100%)}.mobile-face.iphone8 .home:before{background:#f8f8f8;position:absolute;content:'';border-radius:100%;width:calc(100% - 8px);height:calc(100% - 8px);top:4px;left:4px}.mobile-face.iphone8 .top-bar{height:14px;background:#bfbfc0;position:absolute;top:68px;left:0}.mobile-face.iphone8 .bottom-bar{height:14px;background:#bfbfc0;position:absolute;bottom:68px;left:0}.mobile-face.iphone8 .sleep{position:absolute;top:190px;right:-4px;width:4px;height:66px;border-radius:0 2px 2px 0;background:#d9dbdc}.mobile-face.iphone8 .volume{position:absolute;left:-4px;top:188px;z-index:0;height:66px;width:4px;border-radius:2px 0 0 2px;background:#d9dbdc}.mobile-face.iphone8 .volume:before{position:absolute;left:2px;top:-78px;height:40px;width:2px;border-radius:2px 0 0 2px;background:inherit;content:'';display:block}.mobile-face.iphone8 .volume:after{position:absolute;left:0;top:82px;height:66px;width:4px;border-radius:2px 0 0 2px;background:inherit;content:'';display:block}.mobile-face.iphone8 .camera{background:#3c3d3d;width:12px;height:12px;position:absolute;top:24px;left:50%;margin-left:-6px;border-radius:100%;z-index:3}.mobile-face.iphone8 .sensor{background:#3c3d3d;width:16px;height:16px;position:absolute;top:49px;left:134px;z-index:3;border-radius:100%}.mobile-face.iphone8 .speaker{background:#292728;width:70px;height:6px;position:absolute;top:54px;left:50%;margin-left:-35px;border-radius:6px;z-index:3}.mobile-face.iphone8.gold{background:#f9e7d3}.mobile-face.iphone8.gold .bottom-bar,.mobile-face.iphone8.gold .top-bar{background:#fff}.mobile-face.iphone8.gold .sleep,.mobile-face.iphone8.gold .volume{background:#f9e7d3}.mobile-face.iphone8.gold .home{background:#cebba9;background:linear-gradient(135deg,#cebba9 0,#f9e7d3 50%,#cebba9 100%)}.mobile-face.iphone8.black{background:#464646;box-shadow:inset 0 0 3px 0 rgba(0,0,0,.7)}.mobile-face.iphone8.black:before{background:#080808}.mobile-face.iphone8.black:after{box-shadow:inset 0 0 3px 0 rgba(0,0,0,.1),inset 0 0 6px 3px #212121}.mobile-face.iphone8.black .bottom-bar,.mobile-face.iphone8.black .top-bar{background:#212121}.mobile-face.iphone8.black .sleep,.mobile-face.iphone8.black .volume{background:#464646}.mobile-face.iphone8.black .camera{background:#080808}.mobile-face.iphone8.black .home{background:#080808;background:linear-gradient(135deg,#080808 0,#464646 50%,#080808 100%)}.mobile-face.iphone8.black .home:before{background:#080808}.mobile-face.iphone8.landscape{padding:24px 105px;height:375px;width:667px}.mobile-face.iphone8.landscape .sleep{top:100%;border-radius:0 0 2px 2px;right:190px;height:4px;width:66px}.mobile-face.iphone8.landscape .volume{width:66px;height:4px;top:-4px;left:calc(100% - 188px - 66px);border-radius:2px 2px 0 0}.mobile-face.iphone8.landscape .volume:before{width:40px;height:2px;top:2px;right:-78px;left:auto;border-radius:2px 2px 0 0}.mobile-face.iphone8.landscape .volume:after{left:-82px;width:66px;height:4px;top:0;border-radius:2px 2px 0 0}.mobile-face.iphone8.landscape .top-bar{width:14px;height:100%;left:calc(100% - 68px - 14px);top:0}.mobile-face.iphone8.landscape .bottom-bar{width:14px;height:100%;left:68px;top:0}.mobile-face.iphone8.landscape .home{top:50%;margin-top:-34px;margin-left:0;left:22px}.mobile-face.iphone8.landscape .sensor{top:134px;left:calc(100% - 49px - 16px)}.mobile-face.iphone8.landscape .speaker{height:70px;width:6px;left:calc(100% - 54px - 6px);top:50%;margin-left:0;margin-top:-35px}.mobile-face.iphone8.landscape .camera{left:calc(100% - 32px);top:50%;margin-left:0;margin-top:-5px}.mobile-face.iphone8plus{width:414px;height:736px;padding:112px 26px;background:#d9dbdc;border-radius:56px;box-shadow:inset 0 0 3px 0 rgba(0,0,0,.2)}.mobile-face.iphone8plus:before{width:calc(100% - 12px);height:calc(100% - 12px);position:absolute;top:6px;content:'';left:6px;border-radius:50px;background:#f8f8f8;z-index:1}.mobile-face.iphone8plus:after{width:calc(100% - 16px);height:calc(100% - 16px);position:absolute;top:8px;content:'';left:8px;border-radius:48px;box-shadow:inset 0 0 3px 0 rgba(0,0,0,.1),inset 0 0 6px 3px #fff;z-index:2}.mobile-face.iphone8plus .home{border-radius:100%;width:68px;height:68px;position:absolute;left:50%;margin-left:-34px;bottom:24px;z-index:3;background:#303233;background:linear-gradient(135deg,#303233 0,#b5b7b9 50%,#f0f2f2 69%,#303233 100%)}.mobile-face.iphone8plus .home:before{background:#f8f8f8;position:absolute;content:'';border-radius:100%;width:calc(100% - 8px);height:calc(100% - 8px);top:4px;left:4px}.mobile-face.iphone8plus .top-bar{height:14px;background:#bfbfc0;position:absolute;top:68px;left:0}.mobile-face.iphone8plus .bottom-bar{height:14px;background:#bfbfc0;position:absolute;bottom:68px;left:0}.mobile-face.iphone8plus .sleep{position:absolute;top:190px;right:-4px;width:4px;height:66px;border-radius:0 2px 2px 0;background:#d9dbdc}.mobile-face.iphone8plus .volume{position:absolute;left:-4px;top:188px;z-index:0;height:66px;width:4px;border-radius:2px 0 0 2px;background:#d9dbdc}.mobile-face.iphone8plus .volume:before{position:absolute;left:2px;top:-78px;height:40px;width:2px;border-radius:2px 0 0 2px;background:inherit;content:'';display:block}.mobile-face.iphone8plus .volume:after{position:absolute;left:0;top:82px;height:66px;width:4px;border-radius:2px 0 0 2px;background:inherit;content:'';display:block}.mobile-face.iphone8plus .camera{background:#3c3d3d;width:12px;height:12px;position:absolute;top:29px;left:50%;margin-left:-6px;border-radius:100%;z-index:3}.mobile-face.iphone8plus .sensor{background:#3c3d3d;width:16px;height:16px;position:absolute;top:54px;left:154px;z-index:3;border-radius:100%}.mobile-face.iphone8plus .speaker{background:#292728;width:70px;height:6px;position:absolute;top:59px;left:50%;margin-left:-35px;border-radius:6px;z-index:3}.mobile-face.iphone8plus.gold{background:#f9e7d3}.mobile-face.iphone8plus.gold .bottom-bar,.mobile-face.iphone8plus.gold .top-bar{background:#fff}.mobile-face.iphone8plus.gold .sleep,.mobile-face.iphone8plus.gold .volume{background:#f9e7d3}.mobile-face.iphone8plus.gold .home{background:#cebba9;background:linear-gradient(135deg,#cebba9 0,#f9e7d3 50%,#cebba9 100%)}.mobile-face.iphone8plus.black{background:#464646;box-shadow:inset 0 0 3px 0 rgba(0,0,0,.7)}.mobile-face.iphone8plus.black:before{background:#080808}.mobile-face.iphone8plus.black:after{box-shadow:inset 0 0 3px 0 rgba(0,0,0,.1),inset 0 0 6px 3px #212121}.mobile-face.iphone8plus.black .bottom-bar,.mobile-face.iphone8plus.black .top-bar{background:#212121}.mobile-face.iphone8plus.black .sleep,.mobile-face.iphone8plus.black .volume{background:#464646}.mobile-face.iphone8plus.black .camera{background:#080808}.mobile-face.iphone8plus.black .home{background:#080808;background:linear-gradient(135deg,#080808 0,#464646 50%,#080808 100%)}.mobile-face.iphone8plus.black .home:before{background:#080808}.mobile-face.iphone8plus.landscape{padding:26px 112px;height:414px;width:736px}.mobile-face.iphone8plus.landscape .sleep{top:100%;border-radius:0 0 2px 2px;right:190px;height:4px;width:66px}.mobile-face.iphone8plus.landscape .volume{width:66px;height:4px;top:-4px;left:calc(100% - 188px - 66px);border-radius:2px 2px 0 0}.mobile-face.iphone8plus.landscape .volume:before{width:40px;height:2px;top:2px;right:-78px;left:auto;border-radius:2px 2px 0 0}.mobile-face.iphone8plus.landscape .volume:after{left:-82px;width:66px;height:4px;top:0;border-radius:2px 2px 0 0}.mobile-face.iphone8plus.landscape .top-bar{width:14px;height:100%;left:calc(100% - 68px - 14px);top:0}.mobile-face.iphone8plus.landscape .bottom-bar{width:14px;height:100%;left:68px;top:0}.mobile-face.iphone8plus.landscape .home{top:50%;margin-top:-34px;margin-left:0;left:24px}.mobile-face.iphone8plus.landscape .sensor{top:154px;left:calc(100% - 54px - 16px)}.mobile-face.iphone8plus.landscape .speaker{height:70px;width:6px;left:calc(100% - 59px - 6px);top:50%;margin-left:0;margin-top:-35px}.mobile-face.iphone8plus.landscape .camera{left:calc(100% - 29px);top:50%;margin-left:0;margin-top:-5px}.mobile-face.iphone5s{padding:105px 22px;background:#2c2b2c;width:320px;height:568px;border-radius:50px}.mobile-face.iphone5s:before{width:calc(100% - 8px);height:calc(100% - 8px);position:absolute;top:4px;content:'';left:4px;border-radius:46px;background:#1e1e1e;z-index:1}.mobile-face.iphone5s .sleep{position:absolute;top:-4px;right:60px;width:60px;height:4px;border-radius:2px 2px 0 0;background:#282727}.mobile-face.iphone5s .volume{position:absolute;left:-4px;top:180px;z-index:0;height:27px;width:4px;border-radius:2px 0 0 2px;background:#282727}.mobile-face.iphone5s .volume:before{position:absolute;left:0;top:-75px;height:35px;width:4px;border-radius:2px 0 0 2px;background:inherit;content:'';display:block}.mobile-face.iphone5s .volume:after{position:absolute;left:0;bottom:-64px;height:27px;width:4px;border-radius:2px 0 0 2px;background:inherit;content:'';display:block}.mobile-face.iphone5s .camera{background:#3c3d3d;width:10px;height:10px;position:absolute;top:32px;left:50%;margin-left:-5px;border-radius:5px;z-index:3}.mobile-face.iphone5s .sensor{background:#3c3d3d;width:10px;height:10px;position:absolute;top:60px;left:160px;z-index:3;margin-left:-32px;border-radius:5px}.mobile-face.iphone5s .speaker{background:#292728;width:64px;height:10px;position:absolute;top:60px;left:50%;margin-left:-32px;border-radius:5px;z-index:3}.mobile-face.iphone5s .home{border-radius:36px;width:68px;box-shadow:inset 0 0 0 4px #2c2b2c;height:68px;position:absolute;left:50%;margin-left:-34px;bottom:19px;z-index:3}.mobile-face.iphone5s .top-bar{top:70px;position:absolute;left:0}.mobile-face.iphone5s .bottom-bar{bottom:70px;position:absolute;left:0}.mobile-face.iphone5s.landscape{padding:22px 105px;height:320px;width:568px}.mobile-face.iphone5s.landscape .sleep{right:-4px;top:calc(100% - 120px);height:60px;width:4px;border-radius:0 2px 2px 0}.mobile-face.iphone5s.landscape .volume{width:27px;height:4px;top:-4px;left:calc(100% - 180px);border-radius:2px 2px 0 0}.mobile-face.iphone5s.landscape .volume:before{width:35px;height:4px;top:0;right:-75px;left:auto;border-radius:2px 2px 0 0}.mobile-face.iphone5s.landscape .volume:after{bottom:0;left:-64px;z-index:999;height:4px;width:27px;border-radius:2px 2px 0 0}.mobile-face.iphone5s.landscape .sensor{top:160px;left:calc(100% - 60px);margin-left:0;margin-top:-32px}.mobile-face.iphone5s.landscape .speaker{height:64px;width:10px;left:calc(100% - 60px);top:50%;margin-left:0;margin-top:-32px}.mobile-face.iphone5s.landscape .camera{left:calc(100% - 32px);top:50%;margin-left:0;margin-top:-5px}.mobile-face.iphone5s.landscape .home{left:19px;bottom:50%;margin-bottom:-34px;margin-left:0}.mobile-face.iphone5s.landscape .top-bar{left:70px;top:0;width:3px;height:100%}.mobile-face.iphone5s.landscape .bottom-bar{right:70px;left:auto;bottom:0;width:3px;height:100%}.mobile-face.iphone5s.silver{background:#bcbcbc}.mobile-face.iphone5s.silver:before{background:#fcfcfc}.mobile-face.iphone5s.silver .sleep,.mobile-face.iphone5s.silver .volume{background:#d6d6d6}.mobile-face.iphone5s.silver .bottom-bar,.mobile-face.iphone5s.silver .top-bar{background:#eaebec}.mobile-face.iphone5s.silver .home{box-shadow:inset 0 0 0 4px #bcbcbc}.mobile-face.iphone5s.gold{background:#f9e7d3}.mobile-face.iphone5s.gold:before{background:#fcfcfc}.mobile-face.iphone5s.gold .sleep,.mobile-face.iphone5s.gold .volume{background:#f9e7d3}.mobile-face.iphone5s.gold .bottom-bar,.mobile-face.iphone5s.gold .top-bar{background:#fff}.mobile-face.iphone5s.gold .home{box-shadow:inset 0 0 0 4px #f9e7d3}.mobile-face.nexus5{padding:50px 15px;width:320px;height:568px;background:#1e1e1e;border-radius:20px}.mobile-face.nexus5:before{border-radius:600px/50px;background:inherit;content:'';position:absolute;height:103.1%;width:calc(100% - 26px);top:50%;left:50%;-webkit-transform:translateX(-50%) translateY(-50%);transform:translateX(-50%) translateY(-50%)}.mobile-face.nexus5 .top-bar{width:calc(100% - 8px);height:calc(100% - 6px);position:absolute;top:3px;left:4px;border-radius:20px;background:#181818}.mobile-face.nexus5 .top-bar:before{border-radius:600px/50px;background:inherit;content:'';position:absolute;height:103%;width:calc(100% - 26px);top:50%;left:50%;-webkit-transform:translateX(-50%) translateY(-50%);transform:translateX(-50%) translateY(-50%)}.mobile-face.nexus5 .bottom-bar{display:none}.mobile-face.nexus5 .sleep{width:3px;position:absolute;left:-3px;top:110px;height:100px;background:inherit;border-radius:2px 0 0 2px}.mobile-face.nexus5 .volume{width:3px;position:absolute;right:-3px;top:70px;height:45px;background:inherit;border-radius:0 2px 2px 0}.mobile-face.nexus5 .camera{background:#3c3d3d;width:10px;height:10px;position:absolute;top:18px;left:50%;z-index:3;margin-left:-5px;border-radius:100%}.mobile-face.nexus5 .camera:before{background:#3c3d3d;width:6px;height:6px;content:'';display:block;position:absolute;top:2px;left:-100px;z-index:3;border-radius:100%}.mobile-face.nexus5.landscape{padding:15px 50px;height:320px;width:568px}.mobile-face.nexus5.landscape:before{width:103.1%;height:calc(100% - 26px);border-radius:50px/600px}.mobile-face.nexus5.landscape .top-bar{left:3px;top:4px;height:calc(100% - 8px);width:calc(100% - 6px)}.mobile-face.nexus5.landscape .top-bar:before{width:103%;height:calc(100% - 26px);border-radius:50px/600px}.mobile-face.nexus5.landscape .sleep{height:3px;width:100px;left:calc(100% - 210px);top:-3px;border-radius:2px 2px 0 0}.mobile-face.nexus5.landscape .volume{height:3px;width:45px;right:70px;top:100%;border-radius:0 0 2px 2px}.mobile-face.nexus5.landscape .camera{top:50%;left:calc(100% - 18px);margin-left:0;margin-top:-5px}.mobile-face.nexus5.landscape .camera:before{top:-100px;left:2px}.mobile-face.ipad{width:576px;height:768px;padding:90px 25px;background:#242324;border-radius:44px}.mobile-face.ipad:before{width:calc(100% - 8px);height:calc(100% - 8px);position:absolute;content:'';display:block;top:4px;left:4px;border-radius:40px;background:#1e1e1e}.mobile-face.ipad .camera{background:#3c3d3d;width:10px;height:10px;position:absolute;top:44px;left:50%;margin-left:-5px;border-radius:100%}.mobile-face.ipad .bottom-bar,.mobile-face.ipad .top-bar{display:none}.mobile-face.ipad .home{background:#242324;border-radius:36px;width:50px;height:50px;position:absolute;left:50%;margin-left:-25px;bottom:22px}.mobile-face.ipad .home:after{width:15px;height:15px;margin-top:-8px;margin-left:-8px;border:1px solid rgba(255,255,255,.1);border-radius:4px;position:absolute;display:block;content:'';top:50%;left:50%}.mobile-face.ipad.landscape{height:576px;width:768px;padding:25px 90px}.mobile-face.ipad.landscape .camera{left:calc(100% - 44px);top:50%;margin-left:0;margin-top:-5px}.mobile-face.ipad.landscape .home{top:50%;left:22px;margin-left:0;margin-top:-25px}.mobile-face.ipad.silver{background:#bcbcbc}.mobile-face.ipad.silver:before{background:#fcfcfc}.mobile-face.ipad.silver .home{background:#fcfcfc;box-shadow:inset 0 0 0 1px #bcbcbc}.mobile-face.ipad.silver .home:after{border:1px solid rgba(0,0,0,.2)}.mobile-face.macbook{width:960px;height:600px;padding:44px 44px 76px;margin:0 auto;background:#bebebe;border-radius:34px}.mobile-face.macbook:before{width:calc(100% - 8px);height:calc(100% - 8px);position:absolute;content:'';display:block;top:4px;left:4px;border-radius:30px;background:#1e1e1e}.mobile-face.macbook .top-bar{width:calc(100% + 2 * 70px);height:40px;position:absolute;content:'';display:block;top:680px;left:-70px;border-bottom-left-radius:90px 18px;border-bottom-right-radius:90px 18px;background:#bebebe;box-shadow:inset 0 -4px 13px 3px rgba(34,34,34,.6)}.mobile-face.macbook .top-bar:before{width:100%;height:24px;content:'';display:block;top:0;left:0;background:#f0f0f0;border-bottom:2px solid #aaa;border-radius:5px;position:relative}.mobile-face.macbook .top-bar:after{width:16%;height:14px;content:'';display:block;top:0;background:#ddd;position:absolute;margin-left:auto;margin-right:auto;left:0;right:0;border-radius:0 0 20px 20px;box-shadow:inset 0 -3px 10px #999}.mobile-face.macbook .bottom-bar{background:0 0;width:calc(100% + 2 * 70px);height:26px;position:absolute;content:'';display:block;top:680px;left:-70px}.mobile-face.macbook .bottom-bar:after,.mobile-face.macbook .bottom-bar:before{height:calc(100% - 2px);width:80px;content:'';display:block;top:0;position:absolute}.mobile-face.macbook .bottom-bar:before{left:0;background:#f0f0f0;background:linear-gradient(to right,#747474 0,#c3c3c3 5%,#ebebeb 14%,#979797 41%,#f0f0f0 80%,#f0f0f0 100%,#f0f0f0 100%)}.mobile-face.macbook .bottom-bar:after{right:0;background:#f0f0f0;background:linear-gradient(to right,#f0f0f0 0,#f0f0f0 0,#f0f0f0 20%,#979797 59%,#ebebeb 86%,#c3c3c3 95%,#747474 100%)}.mobile-face.macbook .camera{background:#3c3d3d;width:10px;height:10px;position:absolute;top:20px;left:50%;margin-left:-5px;border-radius:100%}.mobile-face.macbook .home{display:none}.mobile-face.iphone-x{width:375px;height:812px;padding:26px;background:#fdfdfd;box-shadow:inset 0 0 11px 0 #000;border-radius:66px}.mobile-face.iphone-x .overflow{width:100%;height:100%;position:absolute;top:0;left:0;border-radius:66px;overflow:hidden}.mobile-face.iphone-x .shadow{border-radius:100%;width:90px;height:90px;position:absolute;background:radial-gradient(ellipse at center,rgba(0,0,0,.6) 0,rgba(255,255,255,0) 60%)}.mobile-face.iphone-x .shadow--tl{top:-20px;left:-20px}.mobile-face.iphone-x .shadow--tr{top:-20px;right:-20px}.mobile-face.iphone-x .shadow--bl{bottom:-20px;left:-20px}.mobile-face.iphone-x .shadow--br{bottom:-20px;right:-20px}.mobile-face.iphone-x:before{width:calc(100% - 10px);height:calc(100% - 10px);position:absolute;top:5px;content:'';left:5px;border-radius:61px;background:#000;z-index:1}.mobile-face.iphone-x .inner-shadow{width:calc(100% - 20px);height:calc(100% - 20px);position:absolute;top:10px;overflow:hidden;left:10px;border-radius:56px;box-shadow:inset 0 0 15px 0 rgba(255,255,255,.66);z-index:1}.mobile-face.iphone-x .inner-shadow:before{box-shadow:inset 0 0 20px 0 #fff;width:100%;height:116%;position:absolute;top:-8%;content:'';left:0;border-radius:200px/112px;z-index:2}.mobile-face.iphone-x .screen{border-radius:40px;box-shadow:none}.mobile-face.iphone-x .bottom-bar,.mobile-face.iphone-x .top-bar{width:100%;position:absolute;height:8px;background:rgba(0,0,0,.1);left:0}.mobile-face.iphone-x .top-bar{top:80px}.mobile-face.iphone-x .bottom-bar{bottom:80px}.mobile-face.iphone-x .sleep,.mobile-face.iphone-x .volume,.mobile-face.iphone-x .volume:after,.mobile-face.iphone-x .volume:before{width:3px;background:#b5b5b5;position:absolute}.mobile-face.iphone-x .volume{left:-3px;top:116px;height:32px}.mobile-face.iphone-x .volume:before{height:62px;top:62px;content:'';left:0}.mobile-face.iphone-x .volume:after{height:62px;top:140px;content:'';left:0}.mobile-face.iphone-x .sleep{height:96px;top:200px;right:-3px}.mobile-face.iphone-x .camera{width:6px;height:6px;top:9px;border-radius:100%;position:absolute;left:154px;background:#0d4d71}.mobile-face.iphone-x .speaker{height:6px;width:60px;left:50%;position:absolute;top:9px;margin-left:-30px;background:#171818;border-radius:6px}.mobile-face.iphone-x .notch{position:absolute;width:210px;height:30px;top:26px;left:108px;z-index:4;background:#000;border-bottom-left-radius:24px;border-bottom-right-radius:24px}.mobile-face.iphone-x .notch:after,.mobile-face.iphone-x .notch:before{content:'';height:8px;position:absolute;top:0;width:8px}.mobile-face.iphone-x .notch:after{background:radial-gradient(circle at bottom left,transparent 0,transparent 70%,#000 70%,#000 100%);left:-8px}.mobile-face.iphone-x .notch:before{background:radial-gradient(circle at bottom right,transparent 0,transparent 70%,#000 70%,#000 100%);right:-8px}.mobile-face.iphone-x.landscape{height:375px;width:812px}.mobile-face.iphone-x.landscape .bottom-bar,.mobile-face.iphone-x.landscape .top-bar{width:8px;height:100%;top:0}.mobile-face.iphone-x.landscape .top-bar{left:80px}.mobile-face.iphone-x.landscape .bottom-bar{right:80px;bottom:auto;left:auto}.mobile-face.iphone-x.landscape .sleep,.mobile-face.iphone-x.landscape .volume,.mobile-face.iphone-x.landscape .volume:after,.mobile-face.iphone-x.landscape .volume:before{height:3px}.mobile-face.iphone-x.landscape .inner-shadow:before{height:100%;width:116%;left:-8%;top:0;border-radius:112px/200px}.mobile-face.iphone-x.landscape .volume{bottom:-3px;top:auto;left:116px;width:32px}.mobile-face.iphone-x.landscape .volume:before{width:62px;left:62px;top:0}.mobile-face.iphone-x.landscape .volume:after{width:62px;left:140px;top:0}.mobile-face.iphone-x.landscape .sleep{width:96px;left:200px;top:-3px;right:auto}.mobile-face.iphone-x.landscape .camera{left:9px;bottom:154px;top:auto}.mobile-face.iphone-x.landscape .speaker{width:6px;height:60px;left:9px;top:50%;margin-top:-30px;margin-left:0}.mobile-face.iphone-x.landscape .notch{height:210px;width:30px;left:26px;bottom:108px;top:auto;border-top-right-radius:24px;border-bottom-right-radius:24px;border-bottom-left-radius:0}.mobile-face.iphone-x.landscape .notch:after,.mobile-face.iphone-x.landscape .notch:before{left:0}.mobile-face.iphone-x.landscape .notch:after{background:radial-gradient(circle at bottom right,transparent 0,transparent 70%,#000 70%,#000 100%);bottom:-8px;top:auto}.mobile-face.iphone-x.landscape .notch:before{background:radial-gradient(circle at top right,transparent 0,transparent 70%,#000 70%,#000 100%);top:-8px}.mobile-face.note8{width:400px;height:822px;background:#000;border-radius:34px;padding:45px 10px}.mobile-face.note8 .overflow{width:100%;height:100%;position:absolute;top:0;left:0;border-radius:34px;overflow:hidden}.mobile-face.note8 .speaker{height:8px;width:56px;left:50%;position:absolute;top:25px;margin-left:-28px;background:#171818;z-index:1;border-radius:8px}.mobile-face.note8 .camera{height:18px;width:18px;left:86px;position:absolute;top:18px;background:#212b36;z-index:1;border-radius:100%}.mobile-face.note8 .camera:before{content:'';height:8px;width:8px;left:-22px;position:absolute;top:5px;background:#212b36;z-index:1;border-radius:100%}.mobile-face.note8 .sensors{height:10px;width:10px;left:120px;position:absolute;top:22px;background:#1d233b;z-index:1;border-radius:100%}.mobile-face.note8 .sensors:before{content:'';height:10px;width:10px;left:18px;position:absolute;top:0;background:#1d233b;z-index:1;border-radius:100%}.mobile-face.note8 .more-sensors{height:16px;width:16px;left:285px;position:absolute;top:18px;background:#33244a;box-shadow:0 0 0 2px rgba(255,255,255,.1);z-index:1;border-radius:100%}.mobile-face.note8 .more-sensors:before{content:'';height:11px;width:11px;left:40px;position:absolute;top:4px;background:#214a61;z-index:1;border-radius:100%}.mobile-face.note8 .sleep{width:2px;height:56px;background:#000;position:absolute;top:288px;right:-2px}.mobile-face.note8 .volume{width:2px;height:120px;background:#000;position:absolute;top:168px;left:-2px}.mobile-face.note8 .volume:before{content:'';top:168px;width:2px;position:absolute;left:0;background:#000;height:56px}.mobile-face.note8 .inner{width:100%;height:calc(100% - 8px);position:absolute;top:2px;content:'';left:0;border-radius:34px;border-top:2px solid #9fa0a2;border-bottom:2px solid #9fa0a2;background:#000;z-index:1;box-shadow:inset 0 0 6px 0 rgba(255,255,255,.5)}.mobile-face.note8 .shadow{box-shadow:inset 0 0 60px 0 #fff,inset 0 0 30px 0 rgba(255,255,255,.5),0 0 20px 0 #fff,0 0 20px 0 rgba(255,255,255,.5);height:101%;position:absolute;top:-.5%;content:'';width:calc(100% - 20px);left:10px;border-radius:38px;z-index:5;pointer-events:none}.mobile-face.note8 .screen{border-radius:14px;box-shadow:none}.mobile-face.note8.landscape{height:400px;width:822px;padding:10px 45px}.mobile-face.note8.landscape .speaker{height:56px;width:8px;top:50%;margin-top:-28px;margin-left:0;right:25px;left:auto}.mobile-face.note8.landscape .camera{top:86px;right:18px;left:auto}.mobile-face.note8.landscape .camera:before{top:-22px;left:5px}.mobile-face.note8.landscape .sensors{top:120px;right:22px;left:auto}.mobile-face.note8.landscape .sensors:before{top:18px;left:0}.mobile-face.note8.landscape .more-sensors{top:285px;right:18px;left:auto}.mobile-face.note8.landscape .more-sensors:before{top:40px;left:4px}.mobile-face.note8.landscape .sleep{bottom:-2px;top:auto;right:288px;width:56px;height:2px}.mobile-face.note8.landscape .volume{width:120px;height:2px;top:-2px;right:168px;left:auto}.mobile-face.note8.landscape .volume:before{right:168px;left:auto;top:0;width:56px;height:2px}.mobile-face.note8.landscape .inner{height:100%;width:calc(100% - 8px);left:2px;top:0;border-top:0;border-bottom:0;border-left:2px solid #9fa0a2;border-right:2px solid #9fa0a2}.mobile-face.note8.landscape .shadow{width:101%;height:calc(100% - 20px);left:-.5%;top:10px}"]
            }] }
];
PhonePreviewComponent.propDecorators = {
    mobile: [{ type: Input }],
    color: [{ type: Input }],
    isLandscape: [{ type: Input }],
    scale: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_QUERY_BUILDER_BOOTSTRAP_STYLES_CLASS = {
    removeIcon: 'fa fa-minus',
    addIcon: 'fa fa-plus',
    button: 'btn',
    buttonGroup: 'btn-group',
    rightAlign: 'order-12 ml-auto',
    switchRow: 'd-flex px-2',
    switchGroup: 'd-flex align-items-center',
    switchRadio: 'custom-control-input',
    switchLabel: 'custom-control-label',
    switchControl: 'custom-control custom-radio custom-control-inline',
    row: 'row p-2 m-1',
    connector: 'q-connector',
    rule: 'border',
    ruleSet: 'border',
    invalidRuleSet: 'alert alert-danger',
    emptyWarning: 'text-danger mx-auto',
    operatorControl: 'form-control',
    operatorControlSize: 'col-auto pr-0',
    fieldControl: 'form-control',
    fieldControlSize: 'col-auto pr-0',
    entityControl: 'form-control',
    entityControlSize: 'col-auto pr-0',
    inputControl: 'form-control',
    inputControlSize: 'col-auto'
};
// export const DEFAULT_QUERY_BUILDER_TYPE_OPERATORS = {
//   string: ['=', '!=', 'contains', 'like'],
//   number: ['=', '!=', '>', '>=', '<', '<='],
//   time: ['=', '!=', '>', '>=', '<', '<='],
//   date: ['=', '!=', '>', '>=', '<', '<='],
//   category: ['=', '!=', 'in', 'not in'],
//   boolean: ['=']
// };
/** @type {?} */
const EMPTY_QUERY_RULE_SET = { condition: 'AND', rules: [] };
/** @type {?} */
const DEFAULT_QUERY_BUILDER_PROPS = {
    fields: [],
    styleClasses: DEFAULT_QUERY_BUILDER_BOOTSTRAP_STYLES_CLASS,
    allowRuleSet: true
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => QueryBuilderComponent),
    multi: true
};
/** @type {?} */
const VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => QueryBuilderComponent),
    multi: true
};
class QueryBuilderComponent extends ControlComponent {
    /**
     * @param {?} changeDetectorRef
     */
    constructor(changeDetectorRef) {
        super();
        this.changeDetectorRef = changeDetectorRef;
        this.ruleSet = { condition: 'AND', rules: [] };
        this.defaultValue = EMPTY_QUERY_RULE_SET;
        this.templateNames = {
            buttonGroup: 'buttonGroup',
            switchGroup: 'switchGroup',
            removeButton: 'removeButton',
            entity: 'entity',
            field: 'field',
            operator: 'operator',
            input: 'input',
            empty: 'empty'
        };
        this._config = {};
    }
    /**
     * @return {?}
     */
    get config() {
        return this._config;
    }
    /**
     * @param {?} config
     * @return {?}
     */
    set config(config) {
        CommonsUtils.defaults(this._config, config, DEFAULT_QUERY_BUILDER_PROPS);
        LogUtils.debug(this, '查询构造器配置', this._config);
    }
    /**
     * @return {?}
     */
    get value() {
        return this.ruleSet;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        this.ruleSet = value || { condition: 'AND', rules: [] };
    }
    /**
     * @param {?} control
     * @return {?}
     */
    validate(control) {
        /** @type {?} */
        const errors = {};
        /** @type {?} */
        const ruleErrorStore = [];
        /** @type {?} */
        let hasErrors = false;
        if (!this.config.allowEmptyRuleSet && this.checkEmptyRuleInRuleSet(this.value)) {
            errors.empty = '查询定义不能为空.';
            hasErrors = true;
        }
        this.validateRulesInRuleSet(this.value, ruleErrorStore);
        if (ruleErrorStore.length) {
            errors.rules = ruleErrorStore;
            hasErrors = true;
        }
        return hasErrors ? errors : null;
    }
    /**
     * @param {?=} index
     * @return {?}
     */
    ruleSetStyle(index = 0) {
        /** @type {?} */
        const bgColor = Object.keys(THEME_COLORS).filter((color, i) => i === index);
        if (bgColor.length === 0) {
            bgColor[0] = 'blue';
        }
        return {
            'border-left-width': '5px',
            'border-left-style': 'solid',
            'border-left-color': THEME_COLORS[bgColor[0]]
        };
    }
    /**
     * @param {?} field
     * @return {?}
     */
    getOperators(field) {
        if (CommonsUtils.isFunction(this.config.operators)) {
            return ((/** @type {?} */ (this.config.operators)))(field);
        }
        else {
            /** @type {?} */
            const operators = [];
            Object.keys(this.config.operators).forEach(key => {
                if (key === field.key) {
                    operators.push(this.config.operators[key]);
                }
            });
            return operators;
        }
    }
    /**
     * @param {?=} entityKey
     * @return {?}
     */
    getFields(entityKey) {
        if (this.config.entities && entityKey) {
            return this.config.fields.filter((field) => {
                return field && field['entityKey'] === entityKey;
            });
        }
        else {
            return this.config.fields;
        }
    }
    /**
     * @param {?} rule
     * @return {?}
     */
    getField(rule) {
        /** @type {?} */
        const fields = this.getFields(rule.entity);
        if (fields) {
            /** @type {?} */
            const matched = fields.filter(field => field.key === rule.field);
            if (matched && matched.length > 0) {
                return matched[0];
            }
        }
        return undefined;
    }
    /**
     * @param {...?} args
     * @return {?}
     */
    getClassNames(...args) {
        /** @type {?} */
        const styleClasses = this.config.styleClasses;
        /** @type {?} */
        const classNames = args.map((id) => styleClasses[id]).filter((c) => !!c);
        return classNames.length ? classNames.join(' ') : null;
    }
    /**
     * @param {?} rule
     * @return {?}
     */
    isInValidRule(rule) {
        return this.config.allowRuleSet && rule.rules && rule.rules.length === 0;
    }
    /**
     * @param {?} rule
     * @return {?}
     */
    getRuleClassName(rule) {
        /** @type {?} */
        let cls = this.getClassNames('row', 'connector', 'transition');
        cls += ' ' + this.getClassNames(rule['condition'] ? 'ruleSet' : 'rule');
        // if (ruleMeta.invalid) {
        // cls += ' ' + this.getClassNames('invalidRuleSet');
        // }
        return cls;
    }
    /**
     * @param {?} entity
     * @return {?}
     */
    getDefaultDataField(entity) {
        if (!entity) {
            return null;
        }
        else if (entity.defaultField !== undefined) {
            return this.getDefaultValue(entity.defaultField);
        }
        else {
            /** @type {?} */
            const entityDataFields = this.config.fields.filter((field) => {
                return field && field['entityKey'] === entity.key;
            });
            if (entityDataFields && entityDataFields.length) {
                return entityDataFields[0];
            }
        }
    }
    /**
     * @param {?} field
     * @return {?}
     */
    getDefaultOperator(field) {
        if (field && field['defaultOperator'] !== undefined) {
            return this.getDefaultValue(field['defaultOperator']);
        }
        else {
            /** @type {?} */
            const operators = this.getOperators(field);
            if (operators && operators.length) ;
        }
    }
    /**
     * @return {?}
     */
    addRule() {
        /** @type {?} */
        const parent = this.ruleSet;
        if (this.config.addRule) {
            this.config.addRule(parent);
        }
        else {
            /** @type {?} */
            const field = this.config.fields[0];
            parent.rules = [
                ...parent.rules,
                {
                    field: field.key,
                    entity: field['entityKey'],
                    operator: this.getDefaultOperator(field),
                    value: this.getDefaultValue(field.defaultValue)
                }
            ];
        }
    }
    /**
     * @return {?}
     */
    addRuleSet() {
        /** @type {?} */
        const parent = this.ruleSet;
        if (this.config.addRuleSet) {
            this.config.addRuleSet(parent);
        }
        else {
            parent.rules = [
                ...parent.rules,
                { condition: 'AND', rules: [] }
            ];
        }
    }
    /**
     * @param {?} rule
     * @return {?}
     */
    removeRule(rule) {
        /** @type {?} */
        const parent = this.ruleSet;
        if (this.config.removeRule) {
            this.config.removeRule(rule, parent);
        }
        else {
            parent.rules = parent.rules.filter((r) => r !== rule);
        }
    }
    /**
     * @param {?=} ruleSet
     * @return {?}
     */
    removeRuleSet(ruleSet) {
        ruleSet = ruleSet || this.ruleSet;
        /** @type {?} */
        const parent = this.parentRuleSet;
        if (this.config.removeRuleSet) {
            this.config.removeRuleSet(ruleSet, parent);
        }
        else {
            parent.rules = parent.rules.filter((r) => r !== ruleSet);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    changeCondition(value) {
        this.ruleSet.condition = value;
    }
    /**
     * @param {?} key
     * @param {?} rule
     * @return {?}
     */
    changeField(key, rule) {
        /** @type {?} */
        const field = this.config.fields[key];
        if (field && field.defaultValue !== undefined) {
            rule.value = this.getDefaultValue(field.defaultValue);
        }
        else {
            delete rule.value;
        }
        rule.operator = this.getDefaultOperator(field);
    }
    /**
     * @param {?} entityValue
     * @param {?} rule
     * @return {?}
     */
    changeEntity(entityValue, rule) {
        if (this.disabled) {
            return;
        }
        // const currentEntity: DataEntity = this.config.entities.find((e) => e.value === entityValue);
        // const defaultDataField: DataField = this.getDefaultDataField(currentEntity);
        // if (defaultDataField) {
        //   this.changeDataField(defaultDataField.key, rule);
        // }
    }
    /**
     * @param {?} defaultValue
     * @return {?}
     */
    getDefaultValue(defaultValue) {
        switch (typeof defaultValue) {
            case 'function':
                return defaultValue();
            default:
                return defaultValue;
        }
    }
    /**
     * @param {?=} context
     * @return {?}
     */
    context(context) {
        return Object.assign({ qb: (/** @type {?} */ (this)) }, context);
    }
    /**
     * @private
     * @param {?} ruleSet
     * @return {?}
     */
    checkEmptyRuleInRuleSet(ruleSet) {
        if (!ruleSet || !ruleSet.rules || ruleSet.rules.length === 0) {
            return true;
        }
        else {
            return ruleSet.rules.some((item) => {
                if (item.rules) {
                    return this.checkEmptyRuleInRuleSet(item);
                }
                else {
                    return false;
                }
            });
        }
    }
    /**
     * @private
     * @param {?} ruleSet
     * @param {?} errorStore
     * @return {?}
     */
    validateRulesInRuleSet(ruleSet, errorStore) {
        if (ruleSet && ruleSet.rules && ruleSet.rules.length > 0) {
            ruleSet.rules.forEach((item) => {
                if (((/** @type {?} */ (item))).rules) {
                    return this.validateRulesInRuleSet((/** @type {?} */ (item)), errorStore);
                }
                else if (((/** @type {?} */ (item))).field) {
                    /** @type {?} */
                    const field = this.config.fields[((/** @type {?} */ (item))).field];
                    if (field && field['validator'] && field['validator'].apply) {
                        /** @type {?} */
                        const error = field['validator']((/** @type {?} */ (item)), ruleSet);
                        if (error != null) {
                            errorStore.push(error);
                        }
                    }
                }
            });
        }
    }
}
QueryBuilderComponent.decorators = [
    { type: Component, args: [{
                selector: 'er-query-builder',
                template: "<div [ngStyle]=\"ruleSetStyle(index)\" class=\"ruleSet\">\n  <div [ngClass]=\"getClassNames('switchRow')\">\n    <ng-container *ngIf=\"templates[templateNames.buttonGroup] as customer; else defaultButtonGroup\">\n      <div [ngClass]=\"getClassNames('buttonGroup', 'rightAlign')\">\n        <ng-container *ngTemplateOutlet=\"customer; context: context()\"></ng-container>\n      </div>\n    </ng-container>\n\n    <ng-container *ngIf=\"templates[templateNames.switchGroup] as customer; else defaultSwitchGroup\">\n      <ng-container *ngTemplateOutlet=\"customer; context: context()\"></ng-container>\n    </ng-container>\n  </div>\n  <ul [ngClass]=\"getClassNames('tree')\" *ngIf=\"ruleSet && ruleSet.rules\">\n    <ng-container *ngFor=\"let rule of ruleSet.rules; let index = index\">\n\n      <li [ngClass]=\"getRuleClassName(rule)\">\n\n        <ng-container *ngIf=\"!rule['condition']\">\n          <er-query-builder-rule [rule]=\"rule\" [ruleIndex]=\"index\"></er-query-builder-rule>\n        </ng-container>\n\n        <ng-container *ngIf=\"rule['condition']\">\n          <er-query-builder [config]=\"config\" [ruleSet]=\"rule\" [parentRuleSet]=\"ruleSet\" [index]=\"index\">\n          </er-query-builder>\n        </ng-container>\n\n        <ng-container *ngIf=\"templates[templateNames.empty] as customer; else defaultEmptyWarning\">\n          <ng-container *ngIf=\"isInValidRule(rule)\">\n            <ng-container *ngTemplateOutlet=\"customer; context: context()\"></ng-container>\n          </ng-container>\n        </ng-container>\n\n        <ng-template #defaultEmptyWarning>\n          <p [ngClass]=\"getClassNames('emptyWarning')\" *ngIf=\"isInValidRule(rule)\"\n             [innerHTML]=\"config.emptyMessage|erSafeHtml\">\n          </p>\n        </ng-template>\n\n      </li>\n    </ng-container>\n  </ul>\n</div>\n<ng-template #defaultButtonGroup>\n  <div [ngClass]=\"getClassNames('buttonGroup', 'rightAlign')\">\n    <button (click)=\"addRule()\" [ngClass]=\"getClassNames('button')\" [disabled]=disabled>\n      <i [ngClass]=\"getClassNames('addIcon')\"></i> \u6761\u4EF6\n    </button>\n    <button (click)=\"addRuleSet()\" [ngClass]=\"getClassNames('button')\" *ngIf=\"config.allowRuleSet\"\n            [disabled]=disabled>\n      <i [ngClass]=\"getClassNames('addIcon')\"></i> \u6761\u4EF6\u7EC4\n    </button>\n    <ng-container *ngIf=\"!!parentRuleSet && config.allowRuleSet\">\n      <button (click)=\"removeRuleSet()\" [ngClass]=\"getClassNames('button', 'removeButton')\"\n              [disabled]=disabled>\n        <i [ngClass]=\"getClassNames('removeIcon')\"></i>\n      </button>\n    </ng-container>\n  </div>\n</ng-template>\n\n<ng-template #defaultSwitchGroup>\n  <div [ngClass]=\"getClassNames('switchGroup', 'transition')\" *ngIf=\"ruleSet\">\n    <div [ngClass]=\"getClassNames('switchControl')\">\n      <input type=\"radio\" [ngClass]=\"getClassNames('switchRadio')\" [(ngModel)]=\"ruleSet.condition\"\n             [disabled]=disabled\n             value=\"and\" #andOption/>\n      <label (click)=\"changeCondition(andOption.value)\" [ngClass]=\"getClassNames('switchLabel')\">\u5E76\u4E14</label>\n    </div>\n    <div [ngClass]=\"getClassNames('switchControl')\">\n      <input type=\"radio\" [ngClass]=\"getClassNames('switchRadio')\" [(ngModel)]=\"ruleSet.condition\"\n             [disabled]=disabled\n             value=\"or\" #orOption/>\n      <label (click)=\"changeCondition(orOption.value)\" [ngClass]=\"getClassNames('switchLabel')\">\u6216\u8005</label>\n    </div>\n    <div [ngClass]=\"getClassNames('switchControl')\">\n      <input type=\"radio\" [ngClass]=\"getClassNames('switchRadio')\" [(ngModel)]=\"ruleSet.condition\"\n             [disabled]=disabled\n             value=\"not\" #notOption/>\n      <label (click)=\"changeCondition(notOption.value)\" [ngClass]=\"getClassNames('switchLabel')\">\u4E0D\u662F</label>\n    </div>\n  </div>\n</ng-template>\n\n\n",
                providers: [CONTROL_VALUE_ACCESSOR, VALIDATOR],
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: ["@charset \"UTF-8\";:host::ng-deep{display:block;width:100%;font-size:.8em}:host::ng-deep .q-icon{font-style:normal;font-size:12px}:host::ng-deep .q-remove-icon::before{content:'\u274C'}:host::ng-deep .q-add-icon{color:#555}:host::ng-deep .q-add-icon::before{content:'\u2795'}:host::ng-deep .q-remove-button{color:#b3415d;width:31px}:host::ng-deep .q-button-group,:host::ng-deep .q-switch-group{overflow:hidden}:host::ng-deep .q-right-align{float:right}:host::ng-deep .q-button{margin-left:8px;padding:0 8px;background-color:#fff}:host::ng-deep .q-button:disabled{display:none}:host::ng-deep .q-control-size{display:inline-block;vertical-align:top;padding-right:10px}:host::ng-deep .q-entity-control,:host::ng-deep .q-field-control,:host::ng-deep .q-input-control,:host::ng-deep .q-operator-control{display:inline-block;padding:5px 8px;color:#555;background-color:#fff;background-image:none;border:1px solid #ccc;border-radius:4px;box-sizing:border-box;width:auto}:host::ng-deep .q-entity-control:disabled,:host::ng-deep .q-field-control:disabled,:host::ng-deep .q-input-control:disabled,:host::ng-deep .q-operator-control:disabled{border-color:transparent}:host::ng-deep .q-entity-control,:host::ng-deep .q-field-control,:host::ng-deep .q-input-control:not([type=checkbox]),:host::ng-deep .q-operator-control{min-height:32px;-webkit-appearance:none}:host::ng-deep .q-button,:host::ng-deep .q-switch-label{float:left;margin-bottom:0;font-size:14px;line-height:30px;font-weight:400;text-align:center;text-shadow:none;border:1px solid rgba(0,0,0,.2);box-sizing:border-box}:host::ng-deep .q-button:hover,:host::ng-deep .q-switch-label:hover{cursor:pointer;background-color:#f0f0f0}:host::ng-deep .q-switch-label{background-color:#e4e4e4;padding:0 8px}:host::ng-deep .q-switch-radio{position:absolute;clip:rect(0,0,0,0);height:1px;width:1px;border:0;overflow:hidden}:host::ng-deep .q-switch-radio:checked+.q-switch-label{border:1px solid #619ed7;background:#fff;color:#3176b3}:host::ng-deep .q-switch-radio:disabled+.q-switch-label{display:none}:host::ng-deep .q-switch-radio:checked:disabled+.q-switch-label{display:initial;color:initial;cursor:default;border-color:transparent}:host::ng-deep .q-invalid-ruleset{border:1px solid rgba(179,65,93,.5)!important;background:rgba(179,65,93,.1)!important}:host::ng-deep .q-empty-warning{color:#8d252e;text-align:center}:host::ng-deep .q-ruleset{border:1px solid #ccc}:host::ng-deep .q-rule{border:1px solid #ccc;background:#fff}:host::ng-deep .q-transition{transition:.1s ease-in-out}:host::ng-deep .q-tree{list-style:none;margin:4px 0 2px}:host::ng-deep .q-row{padding:6px 8px;margin-top:6px}:host::ng-deep .q-connector{position:relative}:host::ng-deep .q-connector::before{top:-5px;border-width:0 0 2px 2px}:host::ng-deep .q-connector::after{border-width:0 0 0 2px;top:50%}:host::ng-deep .q-connector::after,:host::ng-deep .q-connector::before{content:'';left:-12px;border-color:#ccc;border-style:solid;width:9px;height:calc(50% + 6px);position:absolute}:host::ng-deep .q-connector:last-child::after{content:none}:host::ng-deep .q-inline-block-display{display:inline-block;vertical-align:top}"]
            }] }
];
/** @nocollapse */
QueryBuilderComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
QueryBuilderComponent.propDecorators = {
    ruleSet: [{ type: Input }],
    index: [{ type: Input }],
    parentRuleSet: [{ type: Input }],
    config: [{ type: Input }],
    value: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class QueryBuilderRuleComponent extends BaseComponent {
    /**
     * @param {?} qb
     */
    constructor(qb) {
        super();
        this.qb = qb;
        this.ruleChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get rule() {
        return this._rule;
    }
    /**
     * @param {?} rule
     * @return {?}
     */
    set rule(rule) {
        this._rule = rule;
        this.ruleChange.emit(this._rule);
    }
}
QueryBuilderRuleComponent.decorators = [
    { type: Component, args: [{
                selector: 'er-query-builder-rule',
                template: "<div class=\"d-flex justify-content-between align-items-center rule\">\n\n  <div class=\"badge badge-info rounded-circle\">{{ruleIndex+1}}</div>\n\n  <ng-container *ngIf=\"qb.templates[qb.templateNames.removeButton] as custumer; else defaultRemoveButton\">\n    <div [ngClass]=\"qb.getClassNames('buttonGroup', 'rightAlign')\">\n      <ng-container *ngTemplateOutlet=\"custumer; context: qb.context({$implicit:rule})\"></ng-container>\n    </div>\n  </ng-container>\n\n  <div *ngIf=\"qb.config.entities?.length > 0\" class=\"q-inline-block-display\">\n    <ng-container *ngIf=\"qb.templates[qb.templateNames.entity] as customer; else defaultEntity\">\n      <ng-container *ngTemplateOutlet=\"customer; context: qb.context({$implicit:rule})\"></ng-container>\n    </ng-container>\n  </div>\n\n  <ng-container *ngIf=\"qb.templates[qb.templateNames.field] as customer; else defaultField\">\n    <ng-container *ngTemplateOutlet=\"customer; context: qb.context({$implicit:rule})\"></ng-container>\n  </ng-container>\n\n  <ng-container *ngIf=\"qb.templates[qb.templateNames.operator] as customer; else defaultOperator\">\n    <ng-container *ngTemplateOutlet=\"customer; context: qb.context({$implicit:rule})\"></ng-container>\n  </ng-container>\n\n  <div [ngClass]=\"qb.getClassNames('inputControlSize')\">\n    <ng-container\n      *ngTemplateOutlet=\"qb.templates[qb.templateNames.input]; context: qb.context({$implicit:rule})\"></ng-container>\n  </div>\n\n</div>\n\n<ng-template #defaultRemoveButton>\n  <div [ngClass]=\"qb.getClassNames('removeButtonSize', 'rightAlign')\">\n    <button [ngClass]=\"qb.getClassNames('button', 'removeButton')\" (click)=\"qb.removeRule(rule)\"\n            [disabled]=qb.disabled>\n      <i [ngClass]=\"qb.getClassNames('removeIcon')\"></i>\n    </button>\n  </div>\n</ng-template>\n\n<ng-template #defaultEntity>\n  <div [ngClass]=\"qb.getClassNames('entityControlSize')\">\n    <select [ngClass]=\"qb.getClassNames('entityControl')\" [(ngModel)]=\"rule.entity\"\n            (change)=\"qb.changeEntity($event, rule)\" [disabled]=\"qb.disabled\">\n      <option *ngFor=\"let entity of qb.config.entities\" [ngValue]=\"entity.key\">\n        {{entity.label}}\n      </option>\n    </select>\n  </div>\n</ng-template>\n\n<ng-template #defaultField>\n  <div [ngClass]=\"qb.getClassNames('fieldControlSize')\">\n    <select [ngClass]=\"qb.getClassNames('fieldControl')\" [(ngModel)]=\"rule.field\"\n            (change)=\"qb.changeField($event, rule)\" [disabled]=\"qb.disabled\">\n      <option *ngFor=\"let field of qb.getFields(rule.entity)\" [value]=\"field.key\">\n        {{field.label}}\n      </option>\n    </select>\n  </div>\n</ng-template>\n\n<ng-template #defaultOperator>\n  <div [ngClass]=\"qb.getClassNames('operatorControlSize')\">\n    <select [ngClass]=\"qb.getClassNames('operatorControl')\" [(ngModel)]=\"rule.operator\"\n            [disabled]=\"qb.disabled\">\n      <option *ngFor=\"let operator of qb.getOperators(rule.field)\" [value]=\"operator.value\">\n        {{operator.label}}\n      </option>\n    </select>\n  </div>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".rule:hover{background-color:green}"]
            }] }
];
/** @nocollapse */
QueryBuilderRuleComponent.ctorParameters = () => [
    { type: QueryBuilderComponent }
];
QueryBuilderRuleComponent.propDecorators = {
    ruleIndex: [{ type: Input }],
    ruleChange: [{ type: Output }],
    rule: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * 不能多次创建组件，不能用
 */
class RouteDataPropsBindComponent extends BaseComponent {
    /**
     * @param {?} cd
     */
    constructor(cd) {
        super();
        this.cd = cd;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.$subscriptions = RouteUtils.getActiveRoute().data.subscribe(data => {
            if (!data['$component']) {
                LogUtils.error(this, '没有定义组件类型', data);
                return;
            }
            /** @type {?} */
            let activeRoute = RouteUtils.getActiveRoute();
            /** @type {?} */
            const params = Object.assign({}, activeRoute.snapshot.params || {}, activeRoute.snapshot.queryParams || {});
            while (activeRoute && !activeRoute.snapshot.data['$props']) {
                activeRoute = activeRoute.parent;
            }
            /** @type {?} */
            const routeData = Object.assign({}, activeRoute.snapshot.data, data);
            LogUtils.debug(this, '路由数据', routeData);
            /** @type {?} */
            let props = routeData['$resolvedProps'] || routeData['$props'];
            if (routeData['$propsKey']) {
                props = CommonsUtils.get(props, routeData['$propsKey']);
            }
            /** @type {?} */
            const component = routeData['$component'];
            Object.keys(data).forEach(key => {
                if (CommonsUtils.isFunction(data[key])) {
                    data[key] = ((/** @type {?} */ (data[key])))(props, params, data);
                }
                else if (CommonsUtils.isString(data[key]) && data[key].startsWith(':')) {
                    /** @type {?} */
                    const param = ((/** @type {?} */ (data[key]))).substring(1);
                    if (param === 'USER_ID') ;
                    else if (params[param]) {
                        props[key] = params[param];
                    }
                }
                else if (key !== '$component' && key !== '$propsKey') {
                    props[key] = data[key];
                }
            });
            this.type = component;
            this.props = props;
            this.inputs = props['inputs'] || props || {};
            this.outputs = props['outputs'] || {};
            if (props['hooks']) {
                this.hooks = props['hooks'];
                delete props['hooks'];
            }
            if (!props['inputs'] && !props['outputs']) {
                props['$props'] = CommonsUtils.copy(props);
            }
            this.cd.detectChanges();
        });
    }
    /**
     * @param {?} componentRef
     * @return {?}
     */
    created(componentRef) {
        if (!CommonsUtils.isEmpty(this.hooks)) {
            /** @type {?} */
            const constructor = ComponentUtils.getConstructor(componentRef);
            /** @type {?} */
            const destructor = constructor.prototype['ngOnDestroy'];
            ComponentUtils.bindLifeCycles(componentRef.instance, this.hooks, constructor, destructor);
        }
    }
}
RouteDataPropsBindComponent.decorators = [
    { type: Component, args: [{
                selector: 'er-route-bind',
                template: `
    <ndc-dynamic [ndcDynamicComponent]="type"
                 [ndcDynamicInputs]="inputs"
                 [ndcDynamicOutputs]="outputs"
                 (ndcDynamicCreated)="created($event)"
    >
    </ndc-dynamic>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
RouteDataPropsBindComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class WechatQrCodeComponent {
    constructor() {
        this.height = 300;
        this.width = 300;
        this.baseUrl = 'https://open.weixin.qq.com/connect/qrconnect';
    }
    /**
     * @return {?}
     */
    get qrCodeUrl() {
        /** @type {?} */
        const wechat = ConfigUtils.getConfig().wechat;
        /** @type {?} */
        const redirect = encodeURIComponent(wechat.redirect_uri);
        /** @type {?} */
        let url = `${this.baseUrl}?appid=${wechat.appid}&redirect_uri=${redirect}&scope=${wechat.scope}&response_type=code`;
        url += wechat.style ? '&style=' + wechat.style : '';
        url += wechat.self_redirect ? '&self_redirect=' + wechat.self_redirect : '';
        url += wechat.href ? '&href=' + wechat.href : '';
        return url;
    }
}
WechatQrCodeComponent.decorators = [
    { type: Component, args: [{
                selector: 'wechat-qrcode',
                template: `
    <iframe [src]="qrCodeUrl|erSafeHtml:'resource'" [width]="width" [height]="height" scrolling="no" [attr.frameborder]="0"></iframe>
  `
            }] }
];
WechatQrCodeComponent.propDecorators = {
    height: [{ type: Input }],
    width: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CoreComponents = [
    BreadcrumbsComponent,
    DataItemComponent,
    HttpStatusComponent,
    DynaContentComponent,
    StateButtonComponent,
    StateButtonsComponent,
    ContainerComponent,
    FluidContainerComponent,
    LeftRightContainerComponent,
    PhonePreviewComponent,
    RouteDataPropsBindComponent,
    QueryBuilderComponent,
    QueryBuilderRuleComponent,
    AnimateNumberComponent,
    WechatQrCodeComponent,
    DynaCompComponent
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} el
 * @param {?} maxWait
 * @return {?}
 */
function animationEndSafe(el, maxWait) {
    return Observable$1.create((observer) => {
        el.addEventListener('animationend', observer);
        setTimeout(observer, maxWait);
    });
    // return new Promise((resolve, reject) => {
    //   el.addEventListener('animationend', resolve);
    //   setTimeout(resolve, maxWait);
    // });
}
class AnimatedIfDirective extends NgIf {
    /**
     * @param {?} viewContainer
     * @param {?} _templateRef
     */
    constructor(viewContainer, _templateRef) {
        super(viewContainer, _templateRef);
        this.viewContainer = viewContainer;
        this.animatedIfOnShow = new EventEmitter(false);
        this.animatedIfOnHide = new EventEmitter(false);
        this.visible = false;
        this.destroyed$ = new Subject$1();
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set erAnimatedIf(val) {
        if (this.visible && !val) {
            this.hide();
        }
        else if (!this.visible && val) {
            this.show();
        }
        this.visible = val;
    }
    /**
     * @private
     * @return {?}
     */
    getContainer() {
        if (this.viewContainer.length > 0) {
            return ((/** @type {?} */ (this.viewContainer.get(0)))).rootNodes[0];
        }
        else {
            return null;
        }
    }
    /**
     * Hides the element. Animation is performed through css on the container.
     * This method will set the class to hiding and preserve the element for the animation duration.
     * @private
     * @return {?}
     */
    hide() {
        /** @type {?} */
        const container = this.getContainer();
        if (!!container) {
            container.classList.remove('showing');
            container.classList.add('hiding');
            animationEndSafe(container, 1000)
                .pipe(takeUntil(this.destroyed$))
                .subscribe(() => {
                this.ngIf = this.visible;
                container.classList.remove('hiding');
            });
            this.animatedIfOnHide.emit();
        }
    }
    /**
     * Shows the element. Animation is performed through css on the container
     * @private
     * @return {?}
     */
    show() {
        this.ngIf = true;
        /** @type {?} */
        const container = this.getContainer();
        if (!!container) {
            container.classList.remove('hiding');
            container.classList.add('showing');
            animationEndSafe(container, 1000)
                .pipe(takeUntil(this.destroyed$))
                .subscribe(() => {
                container.classList.remove('showing');
            });
            this.animatedIfOnShow.emit();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroyed$.next();
        this.destroyed$.complete();
    }
}
AnimatedIfDirective.decorators = [
    { type: Directive, args: [{
                selector: '[erAnimatedIf]'
            },] }
];
/** @nocollapse */
AnimatedIfDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: TemplateRef }
];
AnimatedIfDirective.propDecorators = {
    animatedIfOnShow: [{ type: Output }],
    animatedIfOnHide: [{ type: Output }],
    erAnimatedIf: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AnimateDirective {
    /**
     * @param {?} el
     */
    constructor(el) {
        this.el = el;
        this._animations = [
            'fadeIn',
            'fadeInLeft',
            'fadeInRight',
            'fadeInUp',
            'fadeInDown',
            'zoomIn',
            'zoomInLeft',
            'zoomInRight',
            'zoomInUp',
            'slideInDown',
            'slideInLeft',
            'slideInRight',
            'slideInUp'
        ];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        let classes = 'animated ';
        if (this.animation) {
            classes += this.animation;
        }
        else {
            classes += this._animations[CommonsUtils.getRandomNumber(this._animations.length - 1)];
        }
        DomUtils.addClasses(this.el.nativeElement, classes);
    }
}
AnimateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[erAnimate]'
            },] }
];
/** @nocollapse */
AnimateDirective.ctorParameters = () => [
    { type: ElementRef }
];
AnimateDirective.propDecorators = {
    animation: [{ type: Input, args: ['erAnimate',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DynaTemplateDirective extends BaseDirective {
    /**
     * @param {?} viewContainerRef
     * @param {?} el
     * @param {?} renderer
     */
    constructor(viewContainerRef, el, renderer) {
        super();
        this.viewContainerRef = viewContainerRef;
        this.el = el;
        this.renderer = renderer;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (CommonsUtils.isEmptyString(this.template)) {
            this.template = this.el.nativeElement.innerHTML;
        }
        if (CommonsUtils.isEmptyString(this.template)) {
            return;
        }
        this.template = this.template.replace(/\[\[/g, '{{');
        this.template = this.template.replace(/]]/g, '}}');
        this.componentRef = DynaComponentUtils.createComponentByTemplate(this.viewContainerRef, this.template);
        /** @type {?} */
        const parent = this.el.nativeElement.parentNode;
        this.renderer.removeChild(parent, this.el.nativeElement);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        super.ngOnDestroy();
        if (this.componentRef) {
            this.componentRef.destroy();
            this.componentRef = null;
        }
    }
}
DynaTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[erDynaTemplate]',
            },] }
];
/** @nocollapse */
DynaTemplateDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: ElementRef },
    { type: Renderer2 }
];
DynaTemplateDirective.propDecorators = {
    template: [{ type: Input, args: ['erDynaTemplate',] }],
    context: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FocusHighlightDirective extends BaseDirective {
    /**
     * @param {?} el
     */
    constructor(el) {
        super();
        this.el = el;
        this.defaultBgColor = 'yellow';
    }
    /**
     * @return {?}
     */
    onMouseEnter() {
        this.highlight(this.bgColor || this.defaultBgColor);
    }
    /**
     * @return {?}
     */
    onMouseLeave() {
        this.highlight(null);
    }
    /**
     * @private
     * @param {?} color
     * @return {?}
     */
    highlight(color) {
        this.el.nativeElement.style.backgroundColor = color;
    }
}
FocusHighlightDirective.decorators = [
    { type: Directive, args: [{ selector: '[erFocusHighlight]' },] }
];
/** @nocollapse */
FocusHighlightDirective.ctorParameters = () => [
    { type: ElementRef }
];
FocusHighlightDirective.propDecorators = {
    bgColor: [{ type: Input }],
    onMouseEnter: [{ type: HostListener, args: ['mouseenter',] }],
    onMouseLeave: [{ type: HostListener, args: ['mouseleave',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HighlightDirective extends BaseDirective {
    /**
     * @param {?} el
     */
    constructor(el) {
        super();
        this.el = el;
        this.searchTerm = undefined;
        this.caseSensitive = true;
        this.viewRendered = false;
        this.WRAPPER_TOKEN = '==--==##';
    }
    /**
     * @private
     * @return {?}
     */
    get caseSensitivity() {
        return this.caseSensitive ? '' : 'i';
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.highlightSearchTerm();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.highlightSearchTerm();
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
        this.viewRendered = true;
    }
    /**
     * @return {?}
     */
    highlightSearchTerm() {
        if (!this.searchTerm) {
            if (this.viewRendered) {
                this.removePreviouslyMarkedTextInNode();
            }
            return;
        }
        if (this.el.nativeElement) {
            this.removePreviouslyMarkedTextInNode();
            this.markMatchedTextTokens(this.el.nativeElement);
        }
    }
    /**
     * @private
     * @param {?} htmlNode
     * @return {?}
     */
    markMatchedTextTokens(htmlNode) {
        /** @type {?} */
        const _searchTerm = this.getSearchTerm();
        /** @type {?} */
        const searchRegex = new RegExp(_searchTerm, 'gmi');
        /** @type {?} */
        const _searchTermUniqueTokens = this.getUniqueTokenWrappedSearchTerm();
        /** @type {?} */
        const searchRegexUniqueTokens = new RegExp(_searchTermUniqueTokens, 'gmi');
        this.traverseHtmlElementsTree(htmlNode, e => {
            this.traverseNodesInElement(htmlNode.childNodes, node => this.wrapUniqueTokensAroundMatchedText(node, searchRegex));
        });
        this.markMatchedTextAndRemoveUniqueTokens(htmlNode, searchRegexUniqueTokens);
    }
    /**
     * @private
     * @param {?} htmlNode
     * @param {?} searchRegex
     * @return {?}
     */
    markMatchedTextAndRemoveUniqueTokens(htmlNode, searchRegex) {
        if (htmlNode.innerHTML) {
            /** @type {?} */
            const innerHtml = htmlNode.innerHTML;
            /** @type {?} */
            const newHtml = innerHtml.replace(searchRegex, match => {
                /** @type {?} */
                const wrapperLength = this.WRAPPER_TOKEN.length;
                /** @type {?} */
                const markedStr = match.substr(wrapperLength, match.length - (wrapperLength * 2));
                return `<mark>${markedStr}</mark>`;
            });
            htmlNode.innerHTML = newHtml;
        }
    }
    /**
     * @private
     * @param {?} nodes
     * @param {?} visitCallback
     * @return {?}
     */
    traverseNodesInElement(nodes, visitCallback) {
        for (let i = 0; i < nodes.length; i++) {
            /** @type {?} */
            const node = nodes[i];
            if (node.nodeType === 3) {
                visitCallback(node);
            }
        }
    }
    /**
     * @private
     * @param {?} htmlNode
     * @param {?} searchRegex
     * @return {?}
     */
    wrapUniqueTokensAroundMatchedText(htmlNode, searchRegex) {
        /** @type {?} */
        const innerText = htmlNode.nodeValue;
        /** @type {?} */
        const newText = innerText.replace(searchRegex, `${this.WRAPPER_TOKEN}$&${this.WRAPPER_TOKEN}`);
        htmlNode.nodeValue = newText;
    }
    /**
     * @private
     * @param {?} currentNode
     * @param {?} visitCallback
     * @return {?}
     */
    traverseHtmlElementsTree(currentNode, visitCallback) {
        if (currentNode) {
            visitCallback(currentNode);
        }
        for (let i = 0; i < currentNode.children.length; i++) {
            /** @type {?} */
            const childNode = currentNode.children[i];
            this.markMatchedTextTokens((/** @type {?} */ (childNode)));
        }
    }
    /**
     * @private
     * @return {?}
     */
    removePreviouslyMarkedTextInNode() {
        /** @type {?} */
        const node = this.el.nativeElement;
        /** @type {?} */
        const markingPattern = new RegExp('<mark>|<\/mark>', 'g');
        /** @type {?} */
        const cleanText = node.innerHTML.replace(markingPattern, '');
        node.innerHTML = cleanText;
    }
    // private highlightedNewTextInNode() {
    //   const node = this.el.nativeElement;
    //   const htmlNegativeLookaheadPattern = '(?![^<>]*>)';
    //   const searchTermPattern = this.getSearchTerm();
    //   const searchRegex = new RegExp(searchTermPattern + htmlNegativeLookaheadPattern, 'gmi');
    //   const markedText = node.innerHTML.replace(searchRegex, '<mark>$&</mark>');
    //   node.innerHTML = markedText;
    // }
    /**
     * @private
     * @return {?}
     */
    getSearchTerm() {
        /** @type {?} */
        let escapedSearchTerm = `${this.escapeRegExp(this.searchTerm)}`;
        /** @type {?} */
        const spaceToMultiMatchRegex = new RegExp(' ', 'gm');
        escapedSearchTerm = escapedSearchTerm.replace(spaceToMultiMatchRegex, '|');
        return escapedSearchTerm;
    }
    /**
     * @private
     * @return {?}
     */
    getUniqueTokenWrappedSearchTerm() {
        /** @type {?} */
        let escapedSearchTerm = this.escapeRegExp(this.searchTerm);
        /** @type {?} */
        const spaceToMultiMatchRegex = new RegExp(' ', 'gm');
        escapedSearchTerm = escapedSearchTerm.replace(spaceToMultiMatchRegex, `${this.WRAPPER_TOKEN}|${this.WRAPPER_TOKEN}`);
        escapedSearchTerm = `${this.WRAPPER_TOKEN}${escapedSearchTerm}${this.WRAPPER_TOKEN}`;
        return escapedSearchTerm;
    }
    /**
     * @private
     * @param {?} str
     * @return {?}
     */
    escapeRegExp(str) {
        return str.replace('/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g', '\\$&');
    }
}
HighlightDirective.decorators = [
    { type: Directive, args: [{
                selector: '[erHighlight]'
            },] }
];
/** @nocollapse */
HighlightDirective.ctorParameters = () => [
    { type: ElementRef }
];
HighlightDirective.propDecorators = {
    searchTerm: [{ type: Input, args: ['erHighlight',] }],
    caseSensitive: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ObjectDiff {
    constructor() {
        this.openChar = '{';
        this.closeChar = '}';
    }
    /**
     * @param {?} obj1
     * @param {?} obj2
     * @return {?}
     */
    static diff(obj1, obj2) {
        if (!ObjectDiff.instance) {
            ObjectDiff.instance = new ObjectDiff();
        }
        /** @type {?} */
        const diff = ObjectDiff.instance.diffOwnProperties(obj1, obj2);
        return '<pre>' + ObjectDiff.instance.formatChangesToHtml(diff) + '</pre>';
    }
    /**
     * @param {?} a
     * @param {?} b
     * @param {?} shallow
     * @param {?} isOwn
     * @return {?}
     */
    diff(a, b, shallow, isOwn) {
        if (a === b) {
            return this.equalObj(a);
        }
        /** @type {?} */
        const diffValue = {};
        /** @type {?} */
        let equal = true;
        if (!a) {
            a = {};
        }
        for (const key in a) {
            if ((!isOwn && key in b) || (isOwn && b && b.hasOwnProperty(key))) {
                if (a[key] === b[key]) {
                    diffValue[key] = this.equalObj(a[key]);
                }
                else {
                    if (!shallow && this.isValidAttr(a[key], b[key])) {
                        /** @type {?} */
                        const valueDiff = this.diff(a[key], b[key], shallow, isOwn);
                        if (valueDiff.changed === 'equal') {
                            diffValue[key] = this.equalObj(a[key]);
                        }
                        else {
                            equal = false;
                            diffValue[key] = valueDiff;
                        }
                    }
                    else {
                        equal = false;
                        diffValue[key] = {
                            changed: 'primitive change',
                            removed: a[key],
                            added: b[key]
                        };
                    }
                }
            }
            else {
                equal = false;
                diffValue[key] = {
                    changed: 'removed',
                    value: a[key]
                };
            }
        }
        for (const key in b) {
            if ((!isOwn && !(key in a)) || (isOwn && typeof a !== 'undefined' && !a.hasOwnProperty(key))) {
                equal = false;
                diffValue[key] = {
                    changed: 'added',
                    value: b[key]
                };
            }
        }
        if (equal) {
            return this.equalObj(a);
        }
        else {
            return {
                changed: 'object change',
                value: diffValue
            };
        }
    }
    /**
     * @param {?} a
     * @param {?} b
     * @param {?=} shallow
     * @return {?}
     */
    diffOwnProperties(a, b, shallow) {
        return this.diff(a, b, shallow, true);
    }
    /**
     * @param {?} changes
     * @param {?=} shallow
     * @return {?}
     */
    formatToJsonXMLString(changes, shallow) {
        /** @type {?} */
        const properties = [];
        /** @type {?} */
        const diff = changes.value;
        if (changes.changed === 'equal') {
            return this.inspect(diff, shallow);
        }
        for (const key in diff) {
            properties.push(this.formatChange(key, diff[key], shallow));
        }
        return '<span>' + this.openChar + '</span>\n<div class="diff-level">' + properties.join('<span>,</span>\n') + '\n</div><span>' + this.closeChar + '</span>';
    }
    /**
     * @param {?} obj
     * @param {?} shallow
     * @return {?}
     */
    formatToJson(obj, shallow) {
        return this.inspect(obj, shallow);
    }
    /**
     * @param {?} changes
     * @param {?=} shallow
     * @return {?}
     */
    formatChangesToHtml(changes, shallow) {
        /** @type {?} */
        const properties = [];
        if (changes.changed === 'equal') {
            return '';
        }
        /** @type {?} */
        const diff = changes.value;
        for (const key in diff) {
            /** @type {?} */
            const changed = diff[key].changed;
            if (changed !== 'equal')
                properties.push(this.formatChange(key, diff[key], shallow, true));
        }
        return '<span>' + this.openChar + '</span>\n<div class="diff-level">' + properties.join('<span>,</span>\n') + '\n</div><span>' + this.closeChar + '</span>';
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    equalObj(obj) {
        return {
            changed: 'equal',
            value: obj
        };
    }
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    isValidAttr(a, b) {
        /** @type {?} */
        const typeA = typeof a;
        /** @type {?} */
        const typeB = typeof b;
        return (a && b && (typeA === 'object' || typeA === 'function') && (typeB === 'object' || typeB === 'function'));
    }
    /**
     * @param {?} key
     * @param {?} diffItem
     * @param {?} shallow
     * @param {?=} diffOnly
     * @return {?}
     */
    formatChange(key, diffItem, shallow, diffOnly) {
        /** @type {?} */
        const changed = diffItem.changed;
        /** @type {?} */
        let property;
        switch (changed) {
            case 'equal':
                property = (this.stringifyObjectKey(this.escapeHTML(key)) + '<span>: </span>' + this.inspect(diffItem.value));
                break;
            case 'removed':
                property = ('<del class="diff">' + this.stringifyObjectKey(this.escapeHTML(key)) + '<span>: </span>' + this.inspect(diffItem.value) + '</del>');
                break;
            case 'added':
                property = ('<ins class="diff">' + this.stringifyObjectKey(this.escapeHTML(key)) + '<span>: </span>' + this.inspect(diffItem.value) + '</ins>');
                break;
            case 'primitive change':
                /** @type {?} */
                const prefix = this.stringifyObjectKey(this.escapeHTML(key)) + '<span>: </span>';
                property = ('<del class="diff diff-key">' + prefix + this.inspect(diffItem.removed) + '</del><span>,</span>\n' +
                    '<ins class="diff diff-key">' + prefix + this.inspect(diffItem.added) + '</ins>');
                break;
            case 'object change':
                property = shallow ? '' : (this.stringifyObjectKey(key) + '<span>: </span>' + (diffOnly ? this.formatChangesToHtml(diffItem) : this.formatToJsonXMLString(diffItem)));
                break;
        }
        return property;
    }
    /**
     * @param {?} key
     * @return {?}
     */
    stringifyObjectKey(key) {
        return /^[a-z0-9_$]*$/i.test(key) ?
            key :
            JSON.stringify(key);
    }
    /**
     * @param {?} string
     * @return {?}
     */
    escapeHTML(string) {
        return string.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }
    /**
     * @param {?} obj
     * @param {?=} shallow
     * @return {?}
     */
    inspect(obj, shallow) {
        /** @type {?} */
        const that = this;
        return _inspect('', obj, shallow);
        /**
         * @param {?} accumulator
         * @param {?} obj
         * @param {?=} shallow
         * @return {?}
         */
        function _inspect(accumulator, obj, shallow) {
            switch (typeof obj) {
                case 'object':
                    if (!obj) {
                        accumulator += 'null';
                        break;
                    }
                    if (shallow) {
                        accumulator += '[object]';
                        break;
                    }
                    /** @type {?} */
                    const keys = Object.keys(obj);
                    /** @type {?} */
                    const length = keys.length;
                    if (length === 0) {
                        accumulator += '<span>' + that.openChar + that.closeChar + '</span>';
                    }
                    else {
                        accumulator += '<span>' + that.openChar + '</span>\n<div class="diff-level">';
                        for (let i = 0; i < length; i++) {
                            /** @type {?} */
                            const key = keys[i];
                            accumulator = _inspect(accumulator + that.stringifyObjectKey(that.escapeHTML(key)) + '<span>: </span>', obj[key]);
                            if (i < length - 1) {
                                accumulator += '<span>,</span>\n';
                            }
                        }
                        accumulator += '\n</div><span>' + that.closeChar + '</span>';
                    }
                    break;
                case 'string':
                    accumulator += JSON.stringify(that.escapeHTML(obj));
                    break;
                case 'undefined':
                    accumulator += 'undefined';
                    break;
                default:
                    accumulator += that.escapeHTML(String(obj));
                    break;
            }
            return accumulator;
        }
    }
}
ObjectDiff.instance = undefined;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class JsonViewerDirective extends BaseDirective {
    /**
     * @param {?} el
     * @param {?} cd
     */
    constructor(el, cd) {
        super();
        this.el = el;
        this.cd = cd;
        this.showCurrent = true;
        this.openLevel = 2;
        this.showDiff = false;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.model) {
            this.model = changes.model.currentValue;
            if (this.model) {
                Object.keys(this.model).forEach(key => {
                    if (this.model[key] instanceof BehaviorSubject) {
                        this.model[key] = this.model[key].value;
                    }
                    else if (this.model[key] instanceof Observable) {
                        ((/** @type {?} */ (this.model[key])))
                            .pipe(takeUntil(this.destroyed$))
                            .subscribe(v => this.model[key] = v);
                    }
                    else if (this.showDiff) {
                        try {
                            this.diff = ObjectDiff.diff(changes.model.previousValue, changes.model.currentValue);
                        }
                        catch (e) {
                        }
                    }
                });
            }
            this.showJson();
        }
    }
    /**
     * @return {?}
     */
    showJson() {
        this.el.nativeElement.innerHTML = '';
        if (this.showCurrent) {
            /** @type {?} */
            const formatter = new JSONFormatter(this.model || {}, this.openLevel, {
                hoverPreviewEnabled: true
            });
            try {
                /** @type {?} */
                const divEle = formatter.render();
                divEle.classList.add('json-viewer');
                this.el.nativeElement.appendChild(divEle);
            }
            catch (e) {
            }
        }
        if (this.showDiff) {
            /** @type {?} */
            const divEle = document.createElement('div');
            divEle.classList.add('diff-viewer');
            divEle.innerHTML = this.diff;
            this.el.nativeElement.appendChild(divEle);
        }
    }
}
JsonViewerDirective.decorators = [
    { type: Directive, args: [{
                selector: '[erJsonViewer]'
            },] }
];
/** @nocollapse */
JsonViewerDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
JsonViewerDirective.propDecorators = {
    model: [{ type: Input, args: ['erJsonViewer',] }],
    showCurrent: [{ type: Input, args: ['current',] }],
    openLevel: [{ type: Input }],
    showDiff: [{ type: Input, args: ['diff',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MovableHandleDirective {
    /**
     * @param {?} element
     */
    constructor(element) {
        this.element = element;
        this.movableEnabled = false;
        this.isMoving = false;
        this.isHandle = true;
    }
}
MovableHandleDirective.decorators = [
    { type: Directive, args: [{
                selector: '[movableHandle]'
            },] }
];
/** @nocollapse */
MovableHandleDirective.ctorParameters = () => [
    { type: ElementRef }
];
MovableHandleDirective.propDecorators = {
    movableEnabled: [{ type: HostBinding, args: ['class.movable-enabled',] }],
    isMoving: [{ type: HostBinding, args: ['class.movable-moving',] }],
    movableHandle: [{ type: Input }],
    isHandle: [{ type: HostBinding, args: ['class.movable-handle',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Position {
    /**
     * @param {?} pos
     */
    constructor(pos) {
        this.height = null;
        this.width = null;
        if (this.containsNumberProp(pos, ['top', 'left'])) {
            this.top = ((/** @type {?} */ (pos))).top;
            this.left = ((/** @type {?} */ (pos))).left;
            if (this.containsNumberProp(pos, ['height', 'width'])) {
                this.height = ((/** @type {?} */ (pos))).height;
                this.width = ((/** @type {?} */ (pos))).width;
            }
        }
        else if (this.containsNumberProp(pos, ['clientY', 'clientX'])) {
            this.top = ((/** @type {?} */ (pos))).clientY;
            this.left = ((/** @type {?} */ (pos))).clientX;
        }
        else if (((/** @type {?} */ (pos))).changedTouches
            && ((/** @type {?} */ (pos))).changedTouches.length > 0
            && ((/** @type {?} */ (pos))).changedTouches[0]
            && this.containsNumberProp(((/** @type {?} */ (pos))).changedTouches[0], ['clientY', 'clientX'])) {
            this.top = ((/** @type {?} */ (pos))).changedTouches[0].clientY;
            this.left = ((/** @type {?} */ (pos))).changedTouches[0].clientX;
        }
    }
    /**
     * @return {?}
     */
    get bottom() {
        return (this.height === null) ? null : this.top + this.height;
    }
    /**
     * @return {?}
     */
    get right() {
        return (this.width === null) ? null : this.left + this.width;
    }
    /**
     * @param {?} position
     * @return {?}
     */
    minus(position) {
        return new Position({
            top: (this.top - position.top),
            left: (this.left - position.left),
            height: this.height,
            width: this.width
        });
    }
    /**
     * @param {?} position
     * @return {?}
     */
    plus(position) {
        return new Position({
            top: (this.top + position.top),
            left: (this.left + position.left),
            height: this.height,
            width: this.width
        });
    }
    /**
     * @protected
     * @param {?} object
     * @param {?} props
     * @return {?}
     */
    containsNumberProp(object, props) {
        return props.every(prop => prop in object && typeof object[prop] === 'number');
    }
}
class MovableDirective {
    /**
     * @param {?} element
     * @param {?} cd
     */
    constructor(element, cd) {
        this.element = element;
        this.cd = cd;
        this.movableConstrained = true;
        /**
         * true if moving is in progress.
         */
        this.isMoving = false;
        this.isHandle = false;
        /**
         * set class on host to indicate movable support.
         */
        this.isMovable = true;
        this.handles = [];
        /**
         * set class depending on the status.
         */
        this._movableEnabled = true;
    }
    /**
     * @protected
     * @return {?}
     */
    get movableEnabled() {
        return this._movableEnabled;
    }
    /**
     * optional input to toggle movable status.
     * @protected
     * @param {?} value
     * @return {?}
     */
    set movableEnabled(value) {
        this._movableEnabled = value;
        // propagate enabled status to handles
        if (this.handles.length > 0) {
            this.handles.forEach(handle => handle.movableEnabled = value);
        }
    }
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    set movable(value) {
        this.movableName = value;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        /** @type {?} */
        const position = this.getStyle(this.element.nativeElement, 'position');
        if (position === 'static') {
            this.positionStyle = 'relative';
            this.cd.detectChanges();
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.allHandles.changes.subscribe((handles) => this.updateQuery(handles));
        // TODO: workaround for https://github.com/angular/angular/issues/12818 and https://github.com/angular/angular/issues/9689
        // manually trigger first update.
        this.updateQuery(this.allHandles);
    }
    /**
     * @protected
     * @param {?} handles
     * @return {?}
     */
    updateQuery(handles) {
        this.handles = handles.filter(handle => handle.movableHandle === this.movableName);
        // fallback to this as handle if not specified
        if (this.handles.length === 0) {
            this.isHandle = true;
        }
        // propagate enabled status to handles
        if (this.handles.length > 0) {
            this.handles.forEach(handle => handle.movableEnabled = this.movableEnabled);
        }
    }
    /**
     * @protected
     * @param {?} event
     * @return {?}
     */
    onMouseDown(event) {
        this.startMoving(event);
    }
    /**
     * @protected
     * @param {?} event
     * @return {?}
     */
    onMouseUp(event) {
        this.stopMoving();
    }
    // using document to move even pointer leaves the host (fast moving)
    /**
     * @protected
     * @param {?} event
     * @return {?}
     */
    onMouseMove(event) {
        this.moveElement(event);
    }
    /**
     * @protected
     * @param {?} event
     * @return {?}
     */
    onTouchStart(event) {
        this.startMoving(event);
    }
    /**
     * @protected
     * @param {?} event
     * @return {?}
     */
    onTouchEnd(event) {
        this.stopMoving();
    }
    // using document to move even pointer leaves the host (fast moving)
    /**
     * @protected
     * @param {?} event
     * @return {?}
     */
    onTouchMove(event) {
        this.moveElement(event);
    }
    /**
     * @protected
     * @param {?} event
     * @return {?}
     */
    startMoving(event) {
        if (this.isEventInHandle(event) && this.movableEnabled) {
            this.startPosition = new Position(event).minus(this.getRelativeRect(this.element.nativeElement));
            this.isMoving = true;
            if (this.handles.length > 0) {
                this.handles.forEach(handle => handle.isMoving = true);
            }
            this.cd.detectChanges();
        }
    }
    /**
     * @protected
     * @return {?}
     */
    stopMoving() {
        this.isMoving = false;
        if (this.handles.length > 0) {
            this.handles.forEach(handle => handle.isMoving = false);
        }
        this.cd.detectChanges();
    }
    /**
     * @protected
     * @param {?} event
     * @return {?}
     */
    moveElement(event) {
        if (this.isMoving) {
            /** @type {?} */
            let moved = false;
            /** @type {?} */
            const newPosition = new Position(event).minus(this.startPosition);
            if (!this.movableConstrained) {
                this.positionTop = newPosition.top;
                this.positionLeft = newPosition.left;
                moved = true;
            }
            else {
                /** @type {?} */
                const constainedByElement = this.element.nativeElement.ownerDocument.getElementById(this.movableConstraint);
                /** @type {?} */
                let constainedByAbsPos;
                if (constainedByElement) {
                    constainedByAbsPos = new Position(constainedByElement.getBoundingClientRect());
                }
                else {
                    constainedByAbsPos = this.getViewPos(this.element.nativeElement);
                }
                /** @type {?} */
                const elementAbsPos = new Position(this.element.nativeElement.getBoundingClientRect());
                /** @type {?} */
                const diffAbsToRel = elementAbsPos.minus(this.getRelativeRect(this.element.nativeElement));
                /** @type {?} */
                const newAbsPos = diffAbsToRel.plus(newPosition);
                if (newAbsPos.top >= constainedByAbsPos.top && newAbsPos.bottom <= constainedByAbsPos.bottom) {
                    this.positionTop = newPosition.top;
                    moved = true;
                }
                else {
                    if (newAbsPos.top < constainedByAbsPos.top) {
                        // max to top limit, to prevent sticking of the movable on fast move
                        this.positionTop = constainedByAbsPos.minus(diffAbsToRel).top;
                        moved = true;
                    }
                    if (newAbsPos.bottom > constainedByAbsPos.bottom) {
                        // max to bottom limit, to prevent sticking of the movable on fast move
                        this.positionTop = constainedByAbsPos.minus(diffAbsToRel).bottom - elementAbsPos.height;
                        moved = true;
                    }
                }
                if (newAbsPos.left >= constainedByAbsPos.left && newAbsPos.right <= constainedByAbsPos.right) {
                    this.positionLeft = newPosition.left;
                    moved = true;
                }
                else {
                    if (newAbsPos.left < constainedByAbsPos.left) {
                        // max to left limit, to prevent sticking of the movable on fast move
                        this.positionLeft = constainedByAbsPos.minus(diffAbsToRel).left;
                        moved = true;
                    }
                    if (newAbsPos.right > constainedByAbsPos.right) {
                        // max to right limit, to prevent sticking of the movable on fast move
                        this.positionLeft = constainedByAbsPos.minus(diffAbsToRel).right - elementAbsPos.width;
                        moved = true;
                    }
                }
            }
            if (moved) {
                // prevent selection and other side effects during moving, only when position moved, i.e. to allow buttons to be clicked
                event.preventDefault();
                event.stopPropagation();
                this.cd.detectChanges();
            }
        }
    }
    /**
     * @protected
     * @param {?} event
     * @return {?}
     */
    isEventInHandle(event) {
        /** @type {?} */
        let srcElement = event.target || event.srcElement;
        if (this.isHandle) {
            // check parent elements too.
            while (srcElement instanceof HTMLElement && srcElement !== this.element.nativeElement && srcElement.parentElement) {
                srcElement = srcElement.parentElement;
            }
            return this.element.nativeElement === srcElement;
        }
        else {
            return this.handles.some(handle => {
                // check parent elements too.
                while (srcElement instanceof HTMLElement && srcElement !== handle.element.nativeElement && srcElement.parentElement) {
                    srcElement = srcElement.parentElement;
                }
                return handle.element.nativeElement === srcElement;
            });
        }
    }
    /**
     * @protected
     * @param {?} element
     * @return {?}
     */
    getRelativeRect(element) {
        return new Position({
            top: this.parseStyleInt(this.getStyle(element, 'top')) || 0,
            left: this.parseStyleInt(this.getStyle(element, 'left')) || 0,
            height: this.parseStyleInt(this.getStyle(element, 'height')) || 0,
            width: this.parseStyleInt(this.getStyle(element, 'width')) || 0
        });
    }
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    parseStyleInt(value) {
        return parseInt(value, 10);
    }
    /**
     * @protected
     * @param {?} element
     * @param {?} property
     * @return {?}
     */
    getStyle(element, property) {
        /** @type {?} */
        const view = this.getView(element);
        return view.getComputedStyle(element, null).getPropertyValue(property);
    }
    /**
     * @protected
     * @param {?} element
     * @return {?}
     */
    getView(element) {
        /** @type {?} */
        let view = element.ownerDocument.defaultView;
        if (!view || view.opener) {
            view = window;
        }
        return view;
    }
    /**
     * @protected
     * @param {?} element
     * @return {?}
     */
    getViewPos(element) {
        /** @type {?} */
        const view = this.getView(element);
        return new Position({
            top: 0,
            left: 0,
            height: view.innerHeight || element.ownerDocument.documentElement.clientHeight,
            width: view.innerWidth || element.ownerDocument.documentElement.clientWidth
        });
    }
}
MovableDirective.decorators = [
    { type: Directive, args: [{
                selector: '[movable]'
            },] }
];
/** @nocollapse */
MovableDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
MovableDirective.propDecorators = {
    movableConstrained: [{ type: Input }],
    movableConstraint: [{ type: Input }],
    isMoving: [{ type: HostBinding, args: ['class.movable-moving',] }],
    isHandle: [{ type: HostBinding, args: ['class.movable-handle',] }],
    positionStyle: [{ type: HostBinding, args: ['style.position',] }],
    positionTop: [{ type: HostBinding, args: ['style.top.px',] }],
    positionLeft: [{ type: HostBinding, args: ['style.left.px',] }],
    isMovable: [{ type: HostBinding, args: ['class.movable',] }],
    allHandles: [{ type: ContentChildren, args: [MovableHandleDirective, { descendants: true },] }],
    _movableEnabled: [{ type: HostBinding, args: ['class.movable-enabled',] }],
    movableEnabled: [{ type: Input }],
    movable: [{ type: Input }],
    onMouseDown: [{ type: HostListener, args: ['mousedown', ['$event'],] }],
    onMouseUp: [{ type: HostListener, args: ['document:mouseup', ['$event'],] }],
    onMouseMove: [{ type: HostListener, args: ['document:mousemove', ['$event'],] }],
    onTouchStart: [{ type: HostListener, args: ['touchstart', ['$event'],] }],
    onTouchEnd: [{ type: HostListener, args: ['document:touchend', ['$event'],] }],
    onTouchMove: [{ type: HostListener, args: ['document:touchmove', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PositionDirective {
    /**
     * @param {?} el
     * @param {?} render
     */
    constructor(el, render) {
        this.el = el;
        this.render = render;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.render.addClass(this.el.nativeElement.parentNode, 'd-flex');
        this.render.addClass(this.el.nativeElement.parentNode, 'align-items-center');
        this.render.addClass(this.el.nativeElement.parentNode, 'justify-content-center');
        this.render.addClass(this.el.nativeElement, this.positionClass || 'text-center');
    }
}
PositionDirective.decorators = [
    { type: Directive, args: [{
                selector: '[erPosition]'
            },] }
];
/** @nocollapse */
PositionDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
PositionDirective.propDecorators = {
    positionClass: [{ type: Input, args: ['erPosition',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RemoveMeDirective {
    /**
     * @param {?} el
     */
    constructor(el) {
        this.el = el;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        const nativeElement = this.el.nativeElement;
        /** @type {?} */
        const parentElement = nativeElement.parentElement;
        if (!this.parentContent) {
            this.parentContent = parentElement.innerHTML;
        }
        else {
            parentElement.innerHTML = this.parentContent;
        }
        // move all children out of the element
        while (nativeElement.firstChild) {
            parentElement.insertBefore(nativeElement.firstChild, nativeElement);
        }
        // remove the empty element(the host)
        parentElement.removeChild(nativeElement);
    }
}
RemoveMeDirective.decorators = [
    { type: Directive, args: [{
                selector: '[erInsideOut]'
            },] }
];
/** @nocollapse */
RemoveMeDirective.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SelectorDirective extends BaseDirective {
    /**
     * @param {?} viewContainerRef
     */
    constructor(viewContainerRef) {
        super();
        this.viewContainerRef = viewContainerRef;
    }
    /**
     * @return {?}
     */
    get hostComponent() {
        return this.viewContainerRef['_data'].componentView.component;
    }
}
SelectorDirective.decorators = [
    { type: Directive, args: [{
                selector: '[erSelector]'
            },] }
];
/** @nocollapse */
SelectorDirective.ctorParameters = () => [
    { type: ViewContainerRef }
];
SelectorDirective.propDecorators = {
    id: [{ type: Input, args: ['erSelector',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class SpinnerBaseDirective extends BaseDirective {
    /**
     * @param {?} el
     * @param {?} renderer
     */
    constructor(el, renderer) {
        super();
        this.el = el;
        this.renderer = renderer;
        this.position = 'right';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.onInit();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.spinElement = this.createElement('span', ['spinner', this.position, 'd-none']);
        if (!this.spinnerClass) {
            this.spinnerClass = ConfigUtils.getConfig().onLoading || 'fa fa-cog fa-spin fa-spin-2x';
        }
        /** @type {?} */
        const spinnerEle = this.createElement('i', this.spinnerClass.split(' '));
        this.renderer.appendChild(this.spinElement, spinnerEle);
        this.placeSpin();
    }
    /**
     * @protected
     * @return {?}
     */
    placeSpin() {
        /** @type {?} */
        const element = this.el.nativeElement;
        if (element instanceof HTMLDivElement) {
            this.addSpin(element);
        }
        else if (element instanceof HTMLButtonElement) {
            this.appendChildSpin(element);
        }
        else if (element instanceof HTMLImageElement) {
            this.replaceWithWrapper();
        }
        else if (element instanceof HTMLUListElement) {
            this.replaceWithWrapper();
        }
        else if (element instanceof HTMLInputElement) {
            switch (element.type) {
                case 'text':
                case 'file': {
                    this.replaceWithWrapper();
                    break;
                }
                case 'checkbox':
                case 'radio':
                case 'button': {
                    this.replaceWithWrapper('span');
                    break;
                }
                default:
                    this.replaceWithWrapper();
            }
        }
        else {
            this.replaceWithWrapper();
        }
    }
    /**
     * @protected
     * @param {?} parent
     * @return {?}
     */
    appendChildSpin(parent) {
        this.renderer.appendChild(parent, this.spinElement);
    }
    /**
     * @protected
     * @param {?} parent
     * @return {?}
     */
    addSpin(parent) {
        this.renderer.addClass(parent, 'spin-container');
        this.renderer.removeClass(this.spinElement, this.position);
        this.renderer.addClass(this.spinElement, 'fa-2x');
        this.renderer.addClass(this.spinElement, 'center');
        this.appendChildSpin(parent);
    }
    /**
     * @protected
     * @param {?=} tag
     * @return {?}
     */
    replaceWithWrapper(tag = 'div') {
        this.containerElement = this.createElement(tag, ['spin-container']);
        /** @type {?} */
        const parent = this.el.nativeElement.parentNode;
        this.renderer.insertBefore(parent, this.containerElement, this.el.nativeElement);
        this.renderer.removeChild(parent, this.el.nativeElement);
        if (tag !== 'div') {
            this.renderer.addClass(this.spinElement, 'spin-inline');
            if (this.position === 'left') {
                this.renderer.appendChild(this.containerElement, this.spinElement);
                this.renderer.appendChild(this.containerElement, this.el.nativeElement);
            }
        }
        else {
            this.renderer.appendChild(this.containerElement, this.el.nativeElement);
            this.renderer.appendChild(this.containerElement, this.spinElement);
        }
    }
    /**
     * @protected
     * @param {?} tag
     * @param {?} classNames
     * @return {?}
     */
    createElement(tag, classNames) {
        /** @type {?} */
        const element = this.renderer.createElement(tag);
        if (classNames) {
            classNames.forEach(className => this.renderer.addClass(element, className));
        }
        return element;
    }
}
SpinnerBaseDirective.propDecorators = {
    spinnerClass: [{ type: Input }],
    position: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HttpSpinnerDirective extends SpinnerBaseDirective {
    /**
     * @param {?} el
     * @param {?} renderer
     */
    constructor(el, renderer) {
        super(el, renderer);
    }
    /**
     * @return {?}
     */
    onInit() {
        this.$subscriptions = StatesUtils.observe(StateNames.http, this.spinnerTag)
            .subscribe(state => {
            if (state && state.start) {
                this.renderer.removeClass(this.spinElement, 'd-none');
                this.renderer.setAttribute(this.el.nativeElement, 'disabled', 'true');
                if (this.containerElement) {
                    this.renderer.setStyle(this.el.nativeElement, 'opacity', 0.5);
                }
            }
            else {
                if (this.spinElement) {
                    this.renderer.addClass(this.spinElement, 'd-none');
                    this.renderer.removeAttribute(this.el.nativeElement, 'disabled');
                    if (this.containerElement) {
                        this.renderer.setStyle(this.el.nativeElement, 'opacity', 1);
                    }
                }
            }
        });
    }
}
HttpSpinnerDirective.decorators = [
    { type: Directive, args: [{
                selector: '[erHttpState]'
            },] }
];
/** @nocollapse */
HttpSpinnerDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
HttpSpinnerDirective.propDecorators = {
    spinnerTag: [{ type: Input, args: ['erHttpState',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NotifySpinnerDirective extends SpinnerBaseDirective {
    /**
     * @param {?} el
     * @param {?} renderer
     */
    constructor(el, renderer) {
        super(el, renderer);
    }
    /**
     * @return {?}
     */
    onInit() {
        this.$subscriptions =
            this.notifier
                .subscribe(state => {
                !!state
                    ? this.renderer.removeClass(this.spinElement, 'd-none')
                    : this.renderer.addClass(this.spinElement, 'd-none');
            });
    }
}
NotifySpinnerDirective.decorators = [
    { type: Directive, args: [{
                selector: '[erNotifySpinner]'
            },] }
];
/** @nocollapse */
NotifySpinnerDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NotifySpinnerDirective.propDecorators = {
    notifier: [{ type: Input, args: ['notifySpinner',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TagDirective extends BaseDirective {
    /**
     * @param {?} el
     * @param {?} render
     */
    constructor(el, render) {
        super();
        this.el = el;
        this.render = render;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (!CommonsUtils.isEmpty(this.color)) {
            this.render.setStyle(this.el.nativeElement, 'color', this.color);
        }
        if (!CommonsUtils.isEmpty(this.bg)) {
            this.render.setStyle(this.el.nativeElement, 'background-color', this.bg);
        }
        if (CommonsUtils.isEmpty(this.color) && CommonsUtils.isEmpty(this.bg)) {
            if (!this.text) {
                this.text = this.el.nativeElement.innerHTML;
            }
            this.render.setStyle(this.el.nativeElement, 'background', ColorUtils.getColor(this.text));
            this.render.setStyle(this.el.nativeElement, 'color', 'white');
        }
        this.render.addClass(this.el.nativeElement, 'badge-pill');
        this.render.addClass(this.el.nativeElement, 'badge');
    }
}
TagDirective.decorators = [
    { type: Directive, args: [{
                selector: '[erTag]'
            },] }
];
/** @nocollapse */
TagDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
TagDirective.propDecorators = {
    text: [{ type: Input }],
    bg: [{ type: Input }],
    color: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CoreDirectives = [
    AnimateDirective,
    AnimatedIfDirective,
    ApiDataDirective,
    TypedTemplateDirective,
    DynaTemplateDirective,
    TagDirective,
    SelectorDirective,
    PositionDirective,
    RemoveMeDirective,
    PropsBindDirective,
    MovableDirective,
    MovableHandleDirective,
    JsonViewerDirective,
    HttpSpinnerDirective,
    NotifySpinnerDirective,
    HighlightDirective,
    FocusHighlightDirective
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HttpAppConfiguredInterceptor {
    constructor() {
        this.customerInterceptors = ConfigUtils.getConfig().httpInterceptors;
    }
    /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    intercept(req, next) {
        // const cloned = req.clone();
        // if (this.customerInterceptors) {
        //   this.customerInterceptors.forEach((interceptor: HttpInterceptorConfig) => {
        //     if (req && interceptor.request && RegUtils.test(req.url, interceptor.urlPatterns)) {
        //      // cloned = interceptor.request(cloned);
        //     }
        //   });
        // }
        return next.handle(req);
        // .pipe(
        //    map(response => {
        //      if (this.customerInterceptors) {
        //        this.customerInterceptors.forEach((interceptor: HttpInterceptorConfig) => {
        //          if (interceptor.response && RegUtils.test(req.url, interceptor.urlPatterns)) {
        //            interceptor.response(response);
        //          }
        //        });
        //        return response;
        //      } else {
        //        return response;
        //      }
        //    })
        // );
    }
}
HttpAppConfiguredInterceptor.decorators = [
    { type: Injectable }
];
/** @nocollapse */
HttpAppConfiguredInterceptor.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HttpErrorHandlerInterceptor {
    /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    intercept(req, next) {
        return next.handle(req)
            .pipe(catchError((err) => {
            if (err instanceof HttpErrorResponse) {
                if (err.status === 401) {
                    RouteUtils.nav(ConfigUtils.getConfig().auth.loginRouter);
                }
                else if (err.status === 403) {
                    StatesUtils.create(StateNames.notify, {
                        message: '没有操作权限！',
                        level: NotifyLevel.ERROR
                    });
                }
                else {
                    this.errorHandler(err);
                }
            }
            else if (err instanceof TimeoutError) {
                StatesUtils.create(StateNames.notify, {
                    message: '网络访问超时！',
                    level: NotifyLevel.ERROR
                });
            }
            return throwError(err);
        }));
    }
    /**
     * @private
     * @param {?} err
     * @return {?}
     */
    errorHandler(err) {
        /** @type {?} */
        let message = '';
        if (err.error instanceof Error) {
            message = err.error.message;
        }
        else {
            if (err.status === 0) {
                message = '网络链接已断开';
            }
            else if (err.status === 404) {
                message = '请求地址不存在';
            }
            else if (err.status === 500) {
                message = '服务器程序错误';
            }
            else {
                message = '数据请求错误';
            }
        }
        StatesUtils.create(StateNames.notify, {
            level: NotifyLevel.ERROR,
            message: `${message},错误代码:【${err.status}】`,
            title: '网络访问失败'
        });
    }
}
HttpErrorHandlerInterceptor.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HttpJwtAuthInterceptor {
    constructor() {
        this.headerName = ConfigUtils.getConfig().auth.headerName;
        this.authScheme = ConfigUtils.getConfig().auth.authScheme;
    }
    /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    intercept(req, next) {
        /** @type {?} */
        const currentUser = AuthUtils.getCurrentUser();
        if (currentUser && currentUser.jwtToken) {
            //  if (JwtUtils.isValid(currentUser.jwtToken))
            {
                req = req.clone({
                    setHeaders: {
                        [this.headerName]: `${this.authScheme}${currentUser.jwtToken}`
                    }
                });
            }
        }
        return next.handle(req);
    }
}
HttpJwtAuthInterceptor.decorators = [
    { type: Injectable }
];
/** @nocollapse */
HttpJwtAuthInterceptor.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DateSyncUtils {
    /**
     * @return {?}
     */
    static start() {
        /** @type {?} */
        const timeServer = ConfigUtils.getConfig().api.servers.timer;
        if (timeServer) {
            HttpUtils.request({
                uri: timeServer.uri,
                observe: 'events'
            })
                .pipe(first())
                .subscribe(response => {
                /** @type {?} */
                const dates = response.headers && response.headers.getAll('Date');
                if (dates) {
                    LogUtils.info('DateSyncUtils', '同步服务器时间', dates);
                    if (dates && dates.length > 0) {
                        DateSyncUtils.updateLocalDate(dates[0]);
                    }
                }
            });
        }
    }
    /**
     * @param {?} date
     * @return {?}
     */
    static updateLocalDate(date) {
        /** @type {?} */
        const d = new Date(date);
        DateSyncUtils.timeServer$.next(d);
        DateSyncUtils.stopSyncSchedule();
        DateSyncUtils.startRefreshSchedule();
        DateSyncUtils.startSyncSchedule();
    }
    /**
     * @private
     * @return {?}
     */
    static stopSyncSchedule() {
        if (DateSyncUtils.interval) {
            clearInterval(DateSyncUtils.interval);
        }
    }
    /**
     * @private
     * @return {?}
     */
    static startRefreshSchedule() {
        DateSyncUtils.interval = setInterval(() => {
            /** @type {?} */
            const d = DateSyncUtils.timeServer$.value;
            d.setSeconds(DateSyncUtils.timeServer$.value.getSeconds() + 1);
            DateSyncUtils.timeServer$.next(d);
            StatesUtils.create(StateNames.serverTime, { date: d }, true);
        }, 1000);
    }
    /**
     * @private
     * @return {?}
     */
    static startSyncSchedule() {
        setInterval(() => {
            DateSyncUtils.start();
        }, 1000 * 60 * 15);
    }
}
DateSyncUtils.timeServer$ = new BehaviorSubject(new Date());
DateSyncUtils.interval = undefined;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HttpLogInterceptor {
    /**
     * @param {?} logService
     */
    constructor(logService) {
        this.logService = logService;
    }
    /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    intercept(req, next) {
        /** @type {?} */
        const started = Date.now();
        return next.handle(req)
            .pipe(tap(event => {
            if (event instanceof HttpResponse) {
                /** @type {?} */
                const elapsed = Date.now() - started;
                StatesUtils.set(StateNames.httpTimer, { elapsed });
                /** @type {?} */
                const dates = event.headers.getAll('Date');
                if (dates && dates.length > 0) {
                    DateSyncUtils.updateLocalDate(dates[0]);
                }
            }
        }), catchError((err) => {
            if (!ConfigUtils.getConfig().isProduction) {
                this.logService.debug(this, '网络请求失败！', req.url, err);
            }
            return throwError(err);
        }));
    }
}
HttpLogInterceptor.decorators = [
    { type: Injectable }
];
/** @nocollapse */
HttpLogInterceptor.ctorParameters = () => [
    { type: LogService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HttpProgressInterceptor {
    constructor() {
        this.inProcess = 0;
    }
    /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    intercept(req, next) {
        return next
            .handle(req).pipe(tap(event => {
            if (event.type === HttpEventType.Sent) {
                StatesUtils.update(StateNames.rootHttp, { inProcess: ++this.inProcess, request: req });
            }
            else if (event instanceof HttpResponse) {
                StatesUtils.update(StateNames.rootHttp, { inProcess: --this.inProcess, request: req });
            }
        }), catchError((err) => {
            StatesUtils.update(StateNames.rootHttp, { inProcess: --this.inProcess, request: req });
            return throwError(err);
        }));
    }
}
HttpProgressInterceptor.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HttpTimeoutInterceptor {
    constructor() {
        this.timeout = ConfigUtils.getConfig().httpTimeout || 5000;
    }
    /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    intercept(req, next) {
        /** @type {?} */
        const reqTimeout = Number(req.headers.get('timeout')) || this.timeout;
        return next.handle(req)
            .pipe(timeout(reqTimeout));
    }
}
HttpTimeoutInterceptor.decorators = [
    { type: Injectable }
];
/** @nocollapse */
HttpTimeoutInterceptor.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} bounds
 * @return {?}
 */
function esBoundInterceptor(bounds) {
    return (req) => {
        /** @type {?} */
        let must = [];
        /** @type {?} */
        const query = CommonsUtils.get(req, 'body.query');
        if (query) {
            /** @type {?} */
            const bool = CommonsUtils.get(req, 'body.query.bool');
            if (!bool) {
                must.push(query);
            }
        }
        must = CommonsUtils.get(req, 'body.query.bool.must', must);
        if (!CommonsUtils.isArray(must)) {
            must = [must];
        }
        /** @type {?} */
        let _bounds = bounds;
        if (!CommonsUtils.isArray(bounds)) {
            _bounds = [bounds];
        }
        _bounds.forEach(bound => {
            if (must.indexOf(bound) === -1) {
                if (bound.toJSON) {
                    must.push(bound.toJSON());
                }
                else if (CommonsUtils.isFunction(bound)) {
                    must.push(bound(req));
                }
                else if (CommonsUtils.isJson(bound)) {
                    must.push(bound);
                }
            }
        });
        CommonsUtils.set(req, 'body.query.bool.must', must);
        console.log(must);
        return req;
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function credentialHttpRequestInterceptor() {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CoreInterceptors = [
    { provide: HTTP_INTERCEPTORS, useClass: HttpErrorHandlerInterceptor, multi: true },
    { provide: HTTP_INTERCEPTORS, useClass: HttpProgressInterceptor, multi: true },
    { provide: HTTP_INTERCEPTORS, useClass: HttpLogInterceptor, multi: true },
    { provide: HTTP_INTERCEPTORS, useClass: HttpTimeoutInterceptor, multi: true },
    { provide: HTTP_INTERCEPTORS, useClass: HttpJwtAuthInterceptor, multi: true },
    { provide: HTTP_INTERCEPTORS, useClass: HttpAppConfiguredInterceptor, multi: true }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class KeyValuePipe {
    /**
     * @param {?} data
     * @return {?}
     */
    transform(data) {
        /** @type {?} */
        const lst = [];
        Object.keys(data).map(key => {
            lst.push({ key, value: data[key] });
        });
        return lst;
    }
}
KeyValuePipe.decorators = [
    { type: Pipe, args: [{
                name: 'erKeyValue'
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Base64DecodePipe {
    /**
     * @param {?} value
     * @return {?}
     */
    transform(value) {
        return decodeURIComponent(atob(value));
    }
}
Base64DecodePipe.decorators = [
    { type: Pipe, args: [{
                name: 'base64Decode'
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CommaSeparatedNumberPipe {
    /**
     * @param {?} value
     * @param {?} args
     * @return {?}
     */
    transform(value, args) {
        /** @type {?} */
        const reg = /(^[+-]?\d+)(\d{3})/;
        /** @type {?} */
        let n = value.toString();
        while (reg.test(n)) {
            n = n.replace(reg, '$1' + ',' + '$2');
        }
        return n;
    }
}
CommaSeparatedNumberPipe.decorators = [
    { type: Pipe, args: [{
                name: 'erCommaSeparatedNumber'
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DataItemsPipe {
    /**
     * @param {?} items
     * @param {?} config
     * @return {?}
     */
    transform(items, config) {
        if (!items) {
            return items;
        }
        return DataItemUtils.transItems(items, config || {});
    }
}
DataItemsPipe.decorators = [
    { type: Pipe, args: [{ name: 'erDataItems' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DefaultPipe {
    /**
     * @param {?} data
     * @param {?} dft
     * @return {?}
     */
    transform(data, dft) {
        return !!data ? data : dft;
    }
}
DefaultPipe.decorators = [
    { type: Pipe, args: [{ name: 'erDefault' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const emojiDictionary = [
    { patterns: [':)', ':-)', '=)'], unicode: '😃' },
    { patterns: [':D', ':-D', '=D'], unicode: '😀' },
    { patterns: [':(', ':-(', '=('], unicode: '🙁' },
    { patterns: [':|', ':-|', '=|'], unicode: '😐' },
    { patterns: [':*', ':-*', '=*'], unicode: '😙' },
    { patterns: ['T_T', 'T.T'], unicode: '😭' },
    { patterns: [':O', ':-O', '=O', ':o', ':-o', '=o'], unicode: '😮' },
    { patterns: [':P', ':-P', '=P', ':p', ':-p', '=p'], unicode: '😋' },
    { patterns: ['>.<'], unicode: '😣' },
    { patterns: ['@.@'], unicode: '😵' },
    { patterns: ['*.*'], unicode: '😍' },
    { patterns: ['<3'], unicode: '❤️' },
    { patterns: ['^.^'], unicode: '😊' },
    { patterns: [':+1'], unicode: '👍' },
    { patterns: [':-1'], unicode: '👎' }
];
class EmojifyPipe {
    /**
     * @param {?} message
     * @param {?=} pipeEnabled
     * @return {?}
     */
    transform(message, pipeEnabled = true) {
        if (pipeEnabled && message && message.length > 1) {
            emojiDictionary.forEach(emoji => {
                emoji.patterns.forEach(pattern => {
                    message = message.replace(pattern, emoji.unicode);
                });
            });
        }
        return message;
    }
}
EmojifyPipe.decorators = [
    { type: Pipe, args: [{ name: 'erEmojify' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FilterPipe {
    /**
     * @param {?} arr
     * @param {?} criteria
     * @param {?=} matcher
     * @return {?}
     */
    transform(arr, criteria, matcher) {
        if (!criteria)
            return arr;
        return arr.filter(value => {
            if (CommonsUtils.isJson(value)) {
                return value[criteria.key] && value[criteria.key].toLowerCase().indexOf(criteria.value.toLowerCase()) > -1;
            }
            else
                return value === criteria;
        });
    }
}
FilterPipe.decorators = [
    { type: Pipe, args: [{
                name: 'erFilter'
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HighLightPipe {
    /**
     * @param {?} text
     * @param {...?} keywords
     * @return {?}
     */
    transform(text, ...keywords) {
        if (text && keywords.length > 0) {
            keywords.forEach(keyword => {
                text = text.replace(new RegExp('(' + keyword + ')', 'gi'), '<span class="keyword">$1</span>');
            });
        }
        return text;
    }
}
HighLightPipe.decorators = [
    { type: Pipe, args: [{
                name: 'erHighLight'
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IdCardPipe {
    /**
     * @param {?} idCardNo
     * @param {?=} attr
     * @return {?}
     */
    transform(idCardNo, attr) {
        /** @type {?} */
        const attrs = IdCardUtils.parse(idCardNo);
        if (attrs && Object.keys(attrs).length > 0) {
            return attr ? attrs[attr] : attrs;
        }
        else {
            return '';
        }
    }
}
IdCardPipe.decorators = [
    { type: Pipe, args: [{ name: 'idCard' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class JoinPipe {
    /**
     * @param {?} arr
     * @param {?=} seperator
     * @return {?}
     */
    transform(arr, seperator) {
        return CommonsUtils.join(arr, seperator);
    }
}
JoinPipe.decorators = [
    { type: Pipe, args: [{ name: 'join' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LinkifyPipe {
    /**
     * @param {?} text
     * @param {?=} pipeEnabled
     * @return {?}
     */
    transform(text, pipeEnabled = true) {
        if (pipeEnabled && !CommonsUtils.isEmpty(text)) {
            return this.linkify(text);
        }
        return text;
    }
    /**
     * @private
     * @param {?} plainText
     * @param {?=} pipeEnabled
     * @return {?}
     */
    linkify(plainText, pipeEnabled = true) {
        if (pipeEnabled) {
            /** @type {?} */
            let replacedText;
            /** @type {?} */
            let replacePattern1;
            /** @type {?} */
            let replacePattern2;
            /** @type {?} */
            let replacePattern3;
            // URLs starting with http://, https://, or ftp://
            replacePattern1 = /(\b(https?|ftp):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/gim;
            replacedText = plainText.replace(replacePattern1, '<a href="$1" target=`${options.target|"_blank"}`>$1</a>');
            // URLs starting with "www." (without // before it, or it'd re-link the ones done above).
            replacePattern2 = /(^|[^\/])(www\.[\S]+(\b|$))/gim;
            replacedText = replacedText.replace(replacePattern2, '$1<a href="http://$2" target=`${options.target|"_blank"}`>$2</a>');
            // Change email addresses to mailto:: links.
            replacePattern3 = /(([a-zA-Z0-9\-\_\.])+@[a-zA-Z\_]+?(\.[a-zA-Z]{2,6})+)/gim;
            replacedText = replacedText.replace(replacePattern3, '<a href="mailto:$1">$1</a>');
            return replacedText;
        }
        return plainText;
    }
}
LinkifyPipe.decorators = [
    { type: Pipe, args: [{
                name: 'erLinkify',
                pure: false
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class KeysPipe {
    /**
     * @param {?} src
     * @return {?}
     */
    transform(src) {
        return Object.keys(src);
    }
}
KeysPipe.decorators = [
    { type: Pipe, args: [{
                name: 'erKeys'
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NumberToTextPipe {
    constructor() {
        this.numbers = {
            0: '',
            '00': '',
            '000': '',
            1: 'one',
            2: 'two',
            3: 'three',
            4: 'four',
            5: 'five',
            6: 'six',
            7: 'seven',
            8: 'eight',
            9: 'nine',
            10: 'ten',
            11: 'eleven',
            12: 'twelve',
            13: 'thirteen',
            14: 'fourteen',
            15: 'fifteen',
            16: 'sixteen',
            17: 'seventeen',
            18: 'eighteen',
            19: 'nineteen',
            20: 'twenty',
            30: 'thirty',
            40: 'forty',
            50: 'fifty',
            60: 'sixty',
            70: 'seventy',
            80: 'eighty',
            90: 'ninety'
        };
    }
    /**
     * @param {?} value
     * @return {?}
     */
    transform(value) {
        /** @type {?} */
        let numberWords = [];
        if (typeof value !== 'string') {
            value = value.toString();
        }
        if (value.indexOf(',') > -1) {
            /** @type {?} */
            const re = new RegExp(',', 'g');
            value = value.replace(re, '');
        }
        /** @type {?} */
        let numLength = value.length;
        /** @type {?} */
        let numberString = '';
        /** @type {?} */
        let divide = Math.ceil(value.length / 3);
        /** @type {?} */
        let splits = [];
        for (let i = 0; i < divide; i++) {
            if (value.length % 3 === 2) {
                splits.push([value[0], value[1]]);
                value = value.substring(2);
            }
            else if (value.length % 3 === 1) {
                splits.push([value[0]]);
                value = value.substring(1);
            }
            else {
                splits.push([value[0], value[1], value[2]]);
                value = value.substring(3);
            }
        }
        switch (divide) {
            case 2: {
                numberWords = ['thousand'];
                break;
            }
            case 3: {
                numberWords = ['million', 'thousand'];
                break;
            }
            case 4: {
                numberWords = ['billion', 'million', 'thousand'];
                break;
            }
            case 5: {
                numberWords = ['trillion', 'billion', 'million', 'thousand'];
                break;
            }
        }
        for (let i = 0; i < splits.length; i++) {
            if (numberWords.length > 0) {
                switch (splits[i].length) {
                    case 1:
                        numberString += this.numbers[splits[i][0]] + ' ' + numberWords[0];
                        break;
                    case 2:
                        if (this.numbers[splits[i][0].toString() + splits[i][1].toString()] !== undefined) {
                            numberString += this.numbers[splits[i][0].toString() + splits[i][1].toString()] + ' ' + numberWords[0];
                        }
                        else {
                            numberString += this.numbers[splits[i][0] + '0'] + ' ' + this.numbers[splits[i][1]] + ' ' + numberWords[0];
                        }
                        break;
                    case 3:
                        if (this.numbers[splits[i][0].toString() + splits[i][1].toString() + splits[i][2].toString()] !== undefined) {
                            numberString = numberString.substring(0, numberString.length - 1);
                            break;
                        }
                        else if (this.numbers[splits[i][1].toString() + splits[i][2].toString()] !== undefined) {
                            //Need to properly handle spaces when its double 00's
                            if (splits[i][1].toString() + splits[i][2].toString() === '00') {
                                numberString += this.numbers[splits[i][0]] + ' hundred' + ' ' + numberWords[0];
                            }
                            else {
                                numberString += this.numbers[splits[i][0]] + ' hundred ' + this.numbers[splits[i][1].toString() + splits[i][2].toString()] + ' ' + numberWords[0];
                            }
                        }
                        else {
                            numberString += this.numbers[splits[i][0]] + ' hundred ' + this.numbers[splits[i][1] + '0'] + ' ' + this.numbers[splits[i][2]] + ' ' + numberWords[0];
                        }
                        break;
                }
                numberWords.shift();
                numberString += ' ';
            }
            else {
                switch (splits[i].length) {
                    case 1:
                        if (splits[i][0] === '0') {
                            numberString += 'zero';
                        }
                        else {
                            numberString += this.numbers[splits[i][0]];
                        }
                        break;
                    case 2:
                        if (this.numbers[splits[i][0].toString() + splits[i][1].toString()] !== undefined) {
                            numberString += this.numbers[splits[i][0].toString() + splits[i][1].toString()];
                        }
                        else {
                            numberString += this.numbers[splits[i][0] + '0'] + ' ' + this.numbers[splits[i][1]];
                        }
                        break;
                    case 3:
                        if (this.numbers[splits[i][0].toString() + splits[i][1].toString() + splits[i][2].toString()] !== undefined) {
                            numberString = numberString.substring(0, numberString.length - 1);
                            break;
                        }
                        else if (this.numbers[splits[i][1].toString() + splits[i][2].toString()] !== undefined) {
                            numberString += this.numbers[splits[i][0]] + ' hundred ' + this.numbers[splits[i][1].toString() + splits[i][2].toString()];
                        }
                        else {
                            numberString += this.numbers[splits[i][0]] + ' hundred ' + this.numbers[splits[i][1] + '0'] + ' ' + this.numbers[splits[i][2]];
                        }
                        break;
                }
            }
        }
        return numberString;
    }
}
NumberToTextPipe.decorators = [
    { type: Pipe, args: [{ name: 'erNumberToText' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ObservablePipe {
    /**
     * @param {?} input
     * @return {?}
     */
    transform(input) {
        return of(input);
    }
}
ObservablePipe.decorators = [
    { type: Pipe, args: [{ name: 'observable', pure: false },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class OrderByPipe {
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    static _orderByComparator(a, b) {
        try { // HACK cuz error when delete entire textbox of number and it compares
            if ((isNaN(parseFloat(a)) || !isFinite(a)) || (isNaN(parseFloat(b)) || !isFinite(b))) {
                //Isn't a number so lowercase the string to properly compare
                if (a.toLowerCase() < b.toLowerCase()) {
                    return -1;
                }
                if (a.toLowerCase() > b.toLowerCase()) {
                    return 1;
                }
            }
            else {
                // Parse strings as numbers to compare properly
                if (parseFloat(a) < parseFloat(b)) {
                    return -1;
                }
                if (parseFloat(a) > parseFloat(b)) {
                    return 1;
                }
            }
        }
        catch (e) {
            return 1;
        }
        return 0; //equal each other
    }
    /* filter property by string 'parent.child.item.orderKey' */
    /**
     * @param {?} obj
     * @param {?} propertyPath
     * @return {?}
     */
    static _getDeepValue(obj, propertyPath) {
        /** @type {?} */
        const pathList = propertyPath.split('??');
        if (pathList.length > 0) {
            /** @type {?} */
            let index = 0;
            /** @type {?} */
            let flag = false;
            /** @type {?} */
            let result = '';
            while (!flag) {
                result = getDeepValueByPath(obj, pathList[index]);
                if (result !== undefined) {
                    flag = true;
                }
                else {
                    index++;
                    if (pathList.length === index) {
                        flag = true;
                    }
                }
            }
            return result;
        }
        else {
            return getDeepValueByPath(obj, propertyPath);
        }
        /**
         * @param {?} obj
         * @param {?} path
         * @return {?}
         */
        function getDeepValueByPath(obj, path) {
            path = path.split('.');
            if (path.length > 0) {
                for (let i = 0; i < path.length; i++) {
                    if (obj[path[i]] !== undefined) {
                        obj = obj[path[i]];
                    }
                    else {
                        obj = undefined;
                        break;
                    }
                }
                return obj;
            }
            else {
                return obj[path];
            }
        }
    }
    /**
     * @param {?} input
     * @param {?} __1
     * @return {?}
     */
    transform(input, [config = '+']) {
        if (!Array.isArray(input)) {
            return input;
        }
        if (!Array.isArray(config) || (Array.isArray(config) && config.length === 1)) {
            /** @type {?} */
            const propertyToCheck = !Array.isArray(config) ? config : config[0];
            /** @type {?} */
            const desc = propertyToCheck.substr(0, 1) === '-';
            //Basic array
            if (!propertyToCheck || propertyToCheck === '-' || propertyToCheck === '+') {
                return !desc ? input.sort() : input.sort().reverse();
            }
            else {
                /** @type {?} */
                const property = propertyToCheck.substr(0, 1) === '+' || propertyToCheck.substr(0, 1) === '-'
                    ? propertyToCheck.substr(1)
                    : propertyToCheck;
                return input.sort(function (a, b) {
                    return !desc
                        ? OrderByPipe._orderByComparator(OrderByPipe._getDeepValue(a, property), OrderByPipe._getDeepValue(b, property))
                        : -OrderByPipe._orderByComparator(OrderByPipe._getDeepValue(a, property), OrderByPipe._getDeepValue(b, property));
                });
            }
        }
        else {
            //Loop over property of the array in order and sort
            return input.sort(function (a, b) {
                for (let i = 0; i < config.length; i++) {
                    /** @type {?} */
                    const desc = config[i].substr(0, 1) === '-';
                    /** @type {?} */
                    const property = config[i].substr(0, 1) === '+' || config[i].substr(0, 1) === '-'
                        ? config[i].substr(1)
                        : config[i];
                    /** @type {?} */
                    const comparison = !desc
                        ? OrderByPipe._orderByComparator(OrderByPipe._getDeepValue(a, property), OrderByPipe._getDeepValue(b, property))
                        : -OrderByPipe._orderByComparator(OrderByPipe._getDeepValue(a, property), OrderByPipe._getDeepValue(b, property));
                    //Don't return 0 yet in case of needing to sort by next property
                    if (comparison !== 0) {
                        return comparison;
                    }
                }
                return 0; //equal each other
            });
        }
    }
}
OrderByPipe.decorators = [
    { type: Pipe, args: [{ name: 'orderBy', pure: false },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PercentPipe {
    /**
     * @param {?} num
     * @return {?}
     */
    transform(num) {
        if (num && CommonsUtils.isNumber(num)) {
            return `${num * 100}%`;
        }
        return num;
    }
}
PercentPipe.decorators = [
    { type: Pipe, args: [{ name: 'erPercent' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SafeHtmlPipe {
    /**
     * @param {?} sanitizer
     */
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
    }
    /**
     * @param {?} content
     * @param {?=} type
     * @return {?}
     */
    transform(content, type) {
        if (!content) {
            return '';
        }
        switch (type) {
            case 'url':
                return this.sanitizer.bypassSecurityTrustUrl(content);
            case 'resource':
                return this.sanitizer.bypassSecurityTrustResourceUrl(content);
            case 'style':
                return this.sanitizer.bypassSecurityTrustStyle(content);
            case 'script':
                return this.sanitizer.bypassSecurityTrustScript(content);
            default:
                return this.sanitizer.bypassSecurityTrustHtml(content);
        }
    }
}
SafeHtmlPipe.decorators = [
    { type: Pipe, args: [{ name: 'erSafeHtml' },] }
];
/** @nocollapse */
SafeHtmlPipe.ctorParameters = () => [
    { type: DomSanitizer }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SplitPipe {
    /**
     * @param {?} data
     * @param {?=} seperator
     * @return {?}
     */
    transform(data, seperator) {
        if (data) {
            return data.split(seperator ? seperator : ',');
        }
        return [];
    }
}
SplitPipe.decorators = [
    { type: Pipe, args: [{ name: 'split' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StylePipe {
    /**
     * @param {?} src
     * @return {?}
     */
    transform(src) {
        if (typeof src === 'string') {
            return src;
        }
        else {
            return JSON.stringify(src);
        }
    }
}
StylePipe.decorators = [
    { type: Pipe, args: [{ name: 'erStyle' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SubPipe {
    /**
     * @param {?} value
     * @param {?=} start
     * @param {?=} end
     * @return {?}
     */
    transform(value, start, end) {
        if (!value) {
            return;
        }
        /** @type {?} */
        const iStart = start || 0;
        /** @type {?} */
        let iEnd = end;
        if (CommonsUtils.isString(value)) {
            if (!iEnd) {
                iEnd = value.length;
            }
            return value.substr(iStart, iEnd) + '...';
        }
        else if (CommonsUtils.isArray(value)) {
            if (!iEnd) {
                iEnd = value.length;
            }
            return ((/** @type {?} */ (value))).slice(iStart, iEnd);
        }
        return value;
    }
}
SubPipe.decorators = [
    { type: Pipe, args: [{
                name: 'erSub'
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TextPipe {
    /**
     * @param {?} data
     * @return {?}
     */
    transform(data) {
        return CommonsUtils.getText(data);
    }
}
TextPipe.decorators = [
    { type: Pipe, args: [{ name: 'erText' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TimerPipe {
    /**
     * @param {?=} start
     * @return {?}
     */
    transform(start) {
        if (!start) {
            start = new Date();
        }
        return timer(0, 1000)
            .pipe(map(() => {
            start.setSeconds(start.getSeconds() + 1);
            return new Date(start.getTime());
        }));
    }
}
TimerPipe.decorators = [
    { type: Pipe, args: [{
                name: 'erTimer'
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TrackerPipe {
    /**
     * @param {?} cd
     */
    constructor(cd) {
        this.cd = cd;
        this.currentNumber = 0;
        this.counter$ = new BehaviorSubject(0);
        //   .subscribe();
    }
    /**
     * @param {?} number
     * @param {?=} offset
     * @return {?}
     */
    transform(number, offset = 20) {
        this.currentNumber = number - CommonsUtils.getRandomNumber(offset);
        this.counter$.next(this.currentNumber);
        this.counter$
            .pipe(switchMap(endRange => {
            return timer(1000, 200)
                .pipe(mapTo(this.positiveOrNegative(endRange, this.currentNumber)), startWith(this.currentNumber), scan((acc, curr) => acc + curr), tap(n => console.log(n))
            //  takeWhile(this.takeUntil(endRange, this.currentNumber))
            );
        })).subscribe(() => this.cd.detectChanges());
        return this.counter$;
    }
    /**
     * @private
     * @param {?} endRange
     * @param {?} currentNumber
     * @return {?}
     */
    positiveOrNegative(endRange, currentNumber) {
        return endRange > currentNumber ? 1 : -1;
    }
    /**
     * @private
     * @param {?} endRange
     * @param {?} currentNumber
     * @return {?}
     */
    takeUntil(endRange, currentNumber) {
        return endRange > currentNumber
            ? val => val <= endRange
            : val => val >= endRange;
    }
}
TrackerPipe.decorators = [
    { type: Pipe, args: [{
                name: 'erTracker'
            },] }
];
/** @nocollapse */
TrackerPipe.ctorParameters = () => [
    { type: ChangeDetectorRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TreeNodesPipe {
    /**
     * @param {?} items
     * @param {?} keyMap
     * @return {?}
     */
    transform(items, keyMap) {
        if (!items) {
            return items;
        }
        return TreeUtils.transNodes(items, keyMap);
    }
}
TreeNodesPipe.decorators = [
    { type: Pipe, args: [{ name: 'erTreeNodes' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UniquePipe {
    /**
     * @param {?} value
     * @param {?=} args
     * @return {?}
     */
    transform(value, args) {
        if (value !== undefined && value !== null) {
            return CommonsUtils.unique(value, args);
        }
        return value;
    }
}
UniquePipe.decorators = [
    { type: Pipe, args: [{
                name: 'unique'
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UnitNumberPipe {
    /**
     * @param {?} ele
     */
    constructor(ele) {
        this.ele = ele;
    }
    /**
     * @param {?} value
     * @param {?=} decimal
     * @return {?}
     */
    transform(value, decimal) {
        if (!value) {
            return null;
        }
        if (typeof value === 'string') {
            value = parseFloat(value);
        }
        /** @type {?} */
        let number;
        /** @type {?} */
        let suffix;
        /** @type {?} */
        const numeral = [
            { thresholds: 1, suffix: '' },
            { thresholds: 1e3, suffix: 'K' },
            { thresholds: 1e6, suffix: 'M' },
            { thresholds: 1e9, suffix: 'B' },
            { thresholds: 1e12, suffix: 'T' },
            { thresholds: 1e15, suffix: 'Q' }
        ];
        for (let i = numeral.length - 1; i >= 0; i--) {
            if (value >= numeral[i].thresholds) {
                number = value / numeral[i].thresholds;
                suffix = numeral[i].suffix;
                break;
            }
        }
        if (value > 1e3) {
            if (!decimal) {
                if (number < 10) {
                    number = number.toFixed(1);
                }
                else {
                    number = number.toFixed(0);
                }
            }
            else {
                if (decimal === 0 || decimal === 1 || decimal === 2) {
                    number = number.toFixed(decimal);
                }
                else {
                    throw new Error('must be integer 0, 1 or 2');
                }
            }
        }
        else {
            if (decimal === 0 || decimal === 1 || decimal === 2) {
                number = number.toFixed(decimal);
            }
            else {
                number = Math.round(number);
            }
        }
        // add hint of original value
        // this.ele.nativeElement;
        return number + suffix;
    }
}
UnitNumberPipe.decorators = [
    { type: Pipe, args: [{
                name: 'erUnitNumber'
            },] }
];
/** @nocollapse */
UnitNumberPipe.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UpToNowPipe {
    /**
     * @param {?} cd
     * @param {?} ngZone
     */
    constructor(cd, ngZone) {
        this.cd = cd;
        this.ngZone = ngZone;
    }
    /**
     * @param {?} value
     * @param {?=} due
     * @return {?}
     */
    transform(value, due) {
        /** @type {?} */
        const d = DateUtils.toDate(value);
        if (!d) {
            return '';
        }
        /** @type {?} */
        const span = DateUtils.getDateByNow(d, due);
        this.removeTimer();
        /** @type {?} */
        const timeToUpdate = (Number.isNaN(span.seconds)) ? 1000 : DateUtils.getUpdateSeconds(span.seconds) * 1000;
        this.timer = this.ngZone.runOutsideAngular(() => {
            if (typeof window !== 'undefined') {
                return window.setTimeout(() => {
                    this.ngZone.run(() => this.cd.detectChanges());
                }, timeToUpdate);
            }
            return null;
        });
        return span.message;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.removeTimer();
    }
    /**
     * @private
     * @return {?}
     */
    removeTimer() {
        if (this.timer) {
            window.clearTimeout(this.timer);
            this.timer = null;
        }
    }
}
UpToNowPipe.decorators = [
    { type: Pipe, args: [{
                name: 'erUpToNow',
                pure: false
            },] }
];
/** @nocollapse */
UpToNowPipe.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: NgZone }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ValuePipe {
    /**
     * @param {?} data
     * @param {?} key
     * @return {?}
     */
    transform(data, key) {
        if (CommonsUtils.isJson(data)) {
            if (key) {
                return CommonsUtils.get(data, key) || '';
            }
            else {
                return CommonsUtils.toString(data);
            }
        }
        else {
            return CommonsUtils.toString(data) || '';
        }
    }
}
ValuePipe.decorators = [
    { type: Pipe, args: [{ name: 'erValue' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CorePipes = [
    UpToNowPipe,
    Base64DecodePipe,
    CommaSeparatedNumberPipe,
    LinkifyPipe,
    NumberToTextPipe,
    UnitNumberPipe,
    SubPipe,
    EmojifyPipe,
    IdCardPipe,
    ObservablePipe,
    StylePipe,
    SafeHtmlPipe,
    HighLightPipe,
    FilterPipe,
    TrackerPipe,
    KeyValuePipe,
    KeysPipe,
    DataItemsPipe,
    TreeNodesPipe,
    JoinPipe,
    OrderByPipe,
    SplitPipe,
    UniquePipe,
    StylePipe,
    TextPipe,
    ValuePipe,
    DefaultPipe,
    TimerPipe,
    PercentPipe
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AuthGuard {
    /**
     * @param {?} route
     * @param {?} state
     * @return {?}
     */
    canActivate(route, state) {
        /** @type {?} */
        const url = state.url;
        return AuthUtils.checkLogin(url);
    }
    /**
     * @param {?} route
     * @param {?} state
     * @return {?}
     */
    canActivateChild(route, state) {
        return this.canActivate(route, state);
    }
    /**
     * @param {?} route
     * @return {?}
     */
    canLoad(route) {
        /** @type {?} */
        const url = `/${route.path}`;
        return AuthUtils.checkLogin(url);
    }
}
AuthGuard.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ AuthGuard.ngInjectableDef = defineInjectable({ factory: function AuthGuard_Factory() { return new AuthGuard(); }, token: AuthGuard, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DeactivateGuard {
    /**
     * @param {?} component
     * @param {?} currentRoute
     * @param {?} currentState
     * @return {?}
     */
    canDeactivate(component, currentRoute, currentState) {
        return component.canDeactivate ? component.canDeactivate() : true;
    }
}
DeactivateGuard.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ DeactivateGuard.ngInjectableDef = defineInjectable({ factory: function DeactivateGuard_Factory() { return new DeactivateGuard(); }, token: DeactivateGuard, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GlobalErrorHandler {
    /**
     * @param {?} injector
     * @param {?} zone
     */
    constructor(injector, zone) {
        this.injector = injector;
        this.zone = zone;
        this.logService = injector.get(LogService);
        this.location = injector.get(LocationStrategy);
    }
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        /** @type {?} */
        const message = error.message ? error.message : error.toString();
        /** @type {?} */
        const url = this.location instanceof PathLocationStrategy
            ? this.location.path() : '';
        this.logService.error(this, message, url, DomUtils.resolveUserAgent());
    }
}
GlobalErrorHandler.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
GlobalErrorHandler.ctorParameters = () => [
    { type: Injector },
    { type: NgZone }
];
/** @nocollapse */ GlobalErrorHandler.ngInjectableDef = defineInjectable({ factory: function GlobalErrorHandler_Factory() { return new GlobalErrorHandler(inject(INJECTOR), inject(NgZone)); }, token: GlobalErrorHandler, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ConfigurablePreloadingStrategy {
    constructor() {
        this.preloadedModules = [];
    }
    /**
     * @param {?} route
     * @param {?} load
     * @return {?}
     */
    preload(route, load) {
        if (route.data && route.data['preload']) {
            this.preloadedModules.push(route.path);
            LogUtils.debug('Preloaded: ', route.path);
            return load();
        }
        else {
            return of(null);
        }
    }
}
ConfigurablePreloadingStrategy.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ ConfigurablePreloadingStrategy.ngInjectableDef = defineInjectable({ factory: function ConfigurablePreloadingStrategy_Factory() { return new ConfigurablePreloadingStrategy(); }, token: ConfigurablePreloadingStrategy, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PathPropsDataResolver {
    /**
     * @param {?} route
     * @param {?} state
     * @return {?}
     */
    resolve(route, state) {
        /** @type {?} */
        const routeData = route.data;
        if (routeData) {
            if (!CommonsUtils.isEmpty(routeData)) {
                /** @type {?} */
                const pathValues = route.url.map(seg => seg.path);
                if (routeData['$props']) {
                    return of(CommonsUtils.get(routeData['$props'], pathValues.join('.')));
                }
            }
        }
        if (routeData.resource) ;
        return EMPTY;
    }
}
PathPropsDataResolver.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ PathPropsDataResolver.ngInjectableDef = defineInjectable({ factory: function PathPropsDataResolver_Factory() { return new PathPropsDataResolver(); }, token: PathPropsDataResolver, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * resolve page model from router
 */
class ResourceResolver {
    /**
     * @param {?} route
     * @param {?} state
     * @return {?}
     */
    resolve(route, state) {
        if (!route.data || !route.data['props']) {
            return;
        }
    }
}
ResourceResolver.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ ResourceResolver.ngInjectableDef = defineInjectable({ factory: function ResourceResolver_Factory() { return new ResourceResolver(); }, token: ResourceResolver, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RouterStateService {
    /**
     * @param {?} router
     */
    constructor(router) {
        this.router = router;
        router.events.subscribe((event) => {
            this.navigationInterceptor(event);
        });
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    navigationInterceptor(event) {
        /** @type {?} */
        const activeRoute = RouteUtils.getActiveRoute();
        if (event instanceof NavigationStart) {
            StatesUtils.create(StateNames.nav, {
                start: true,
                url: activeRoute.url,
                outlet: activeRoute.outlet,
                route: activeRoute
            });
        }
        if (event instanceof NavigationEnd) {
            StatesUtils.update(StateNames.nav, {
                start: false,
                status: 'success',
                url: activeRoute.url,
                outlet: activeRoute.outlet,
                route: activeRoute
            });
            StatesUtils.update(StateNames.currentRoute, { activeRoute });
            /** @type {?} */
            const title = activeRoute.data && activeRoute.data['title'];
            if (title) {
                StatesUtils.update(StateNames.appTitle, { title });
            }
        }
        if (event instanceof NavigationCancel) {
            StatesUtils.update(StateNames.nav, {
                start: false,
                status: 'cancel',
                url: activeRoute.url,
                outlet: activeRoute.outlet,
                route: activeRoute
            });
        }
        if (event instanceof NavigationError) {
            StatesUtils.update(StateNames.nav, {
                start: false,
                status: 'error',
                url: activeRoute.url,
                outlet: activeRoute.outlet,
                route: activeRoute
            });
        }
    }
}
RouterStateService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
RouterStateService.ctorParameters = () => [
    { type: Router }
];
/** @nocollapse */ RouterStateService.ngInjectableDef = defineInjectable({ factory: function RouterStateService_Factory() { return new RouterStateService(inject(Router)); }, token: RouterStateService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const BACKGROUND_TASK_TOKEN = new InjectionToken('BACKGROUND_TASK_TOKEN');
/**
 * used to run background task globally
 */
class TaskService {
    /**
     * @param {?=} tasks
     */
    constructor(tasks = []) {
        this.subs = [];
        StatesUtils.create(StateNames.appTitle, ConfigUtils.getConfig().appTitle, true);
        setTimeout(() => {
            this.cleanStates();
            /** @type {?} */
            const _tasks = CommonsUtils.flatten(tasks);
            if (_tasks && _tasks.length > 0) {
                _tasks.forEach(task => this.startTask((/** @type {?} */ (task))));
            }
        }, 2000);
    }
    /**
     * @return {?}
     */
    updateTitle() {
        this.subs.push(StatesUtils.observe(StateNames.appTitle)
            .pipe(filter(state => state && state.hasOwnProperty('title')), map(state => state.title), distinctUntilChanged())
            .subscribe(title => {
            DiUtils.get(Title).setTitle(title);
        }));
    }
    /**
     * @return {?}
     */
    cleanStates() {
        this.subs.push(timer(30000, 30000)
            .subscribe(() => {
            /** @type {?} */
            let store = StatesUtils.getStore().value;
            Object.keys(store).forEach(key => {
                if (store[key]) {
                    if (!store[key].preserved && (store[key].state && store[key].state.observers.length === 0)) {
                        store = CommonsUtils.omit(store, key);
                    }
                }
            });
            StatesUtils.getStore().next(store);
        }));
    }
    /**
     * @param {?} task
     * @return {?}
     */
    startTask(task) {
        if (CommonsUtils.isFunction(task)) {
            ((/** @type {?} */ (task)))();
        }
        else {
            /** @type {?} */
            const schedule = (/** @type {?} */ (task));
            /** @type {?} */
            let context = schedule.context;
            if (CommonsUtils.isFunction(schedule.context)) {
                context = schedule.context();
            }
            if (schedule.interval) {
                this.subs.push(timer(0, schedule.interval)
                    .subscribe(() => {
                    schedule.run(context);
                }));
            }
            else {
                schedule.run(context);
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subs.forEach(sub => {
            sub.unsubscribe();
        });
    }
}
TaskService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
TaskService.ctorParameters = () => [
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [BACKGROUND_TASK_TOKEN,] }] }
];
/** @nocollapse */ TaskService.ngInjectableDef = defineInjectable({ factory: function TaskService_Factory() { return new TaskService(inject(BACKGROUND_TASK_TOKEN, 8)); }, token: TaskService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CoreServices = [
    LogService,
    ResourceResolver,
    TaskService,
    RouterStateService,
    AuthGuard,
    DeactivateGuard,
    GlobalErrorHandler,
    ConfigurablePreloadingStrategy,
    PathPropsDataResolver
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const updateTitleTask = function () {
    StatesUtils.observe(StateNames.appTitle)
        .pipe(filter(appTitle => appTitle && appTitle.hasOwnProperty('title')), map(appTitle => appTitle.title), distinctUntilChanged())
        .subscribe(title => {
        DiUtils.get(Title).setTitle(title);
    });
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CORE_TASKS = [
    updateTitleTask
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AnnotationsUtils {
    /**
     * @param {?} type
     * @return {?}
     */
    static getFor(type) {
        /** @type {?} */
        const annotations = Reflect.getOwnMetadata('design:type', type);
        if (!Array.isArray(annotations)) {
            throw Error(`Annotations: Annotations not available for type '${type.name}'`);
        }
        return annotations[0];
    }
    /**
     * @param {?} type
     * @return {?}
     */
    static getForDirective(type) {
        return AnnotationsUtils.getFor(type);
    }
    /**
     * @param {?} type
     * @return {?}
     */
    static getForComponent(type) {
        return AnnotationsUtils.getFor(type);
    }
    /**
     * @param {?} type
     * @return {?}
     */
    static getForPipe(type) {
        return AnnotationsUtils.getFor(type);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DataUtils {
    /**
     * @param {?} options
     * @return {?}
     */
    static getNextValue(options) {
        /** @type {?} */
        const opt = CommonsUtils.defaults(options || {}, DataUtils.DEFAULT_PROPS);
        /** @type {?} */
        const q = CommonsUtils.getArrayValue(opt.query) || [];
        if (opt.parent) {
            q.push(termQuery(opt.parentKey, opt.parent));
        }
        return ApiUtils.getByQuery(`${opt.apiEntry}`, (/** @type {?} */ ({
            query: q,
            sort: { [opt.seqKey]: Order.DESC },
            size: 1
        }))).pipe(map((data) => {
            /** @type {?} */
            const prefix = '0'.repeat(opt.seqLen);
            /** @type {?} */
            let next = 1;
            if (data.total !== 0) {
                /** @type {?} */
                const last = data.items[0];
                if (last[opt.seqKey]) {
                    next = parseInt(last[opt.seqKey].replace(/^0+/, '')) + 1;
                }
                else {
                    DialogUtils.error('错误', '无法生成新的序列号');
                    throwError('无法生成新的序列号');
                }
            }
            /** @type {?} */
            const seq = (prefix + next).slice(-prefix.length);
            if (opt.withParent && opt.parent) {
                return opt.parent + seq;
            }
            else {
                return seq;
            }
        }));
    }
    /**
     * @param {?} props
     * @return {?}
     */
    static checkDistinct(props) {
        /** @type {?} */
        const result$ = ApiUtils.fetch(Object.assign({}, props.apiProps, { size: 2 })).pipe(map((data) => !data.items || data.items.length === 0 ||
            (data.items.length === 1 && data.items[0]['id'] === props.id)), tap(distinct => {
            if (!distinct) {
                DialogUtils.error('验证失败', `数值【${props.apiProps.queryValue}】已经存在，请修改后再执行本操作！`);
            }
        }));
        return result$;
    }
    /**
     * @param {?} event
     * @param {?} keyOrQuery
     * @return {?}
     */
    static onNodeSelect(event, keyOrQuery) {
        /** @type {?} */
        const treeProps = event['$from'].$props;
        /** @type {?} */
        const tableId = CommonsUtils.get(treeProps, '$ext.$container.table.$id');
        if (tableId) {
            /** @type {?} */
            let q = keyOrQuery;
            /** @type {?} */
            const nodeCode = event.node.data && event.node.data.code;
            if (nodeCode && CommonsUtils.isString(keyOrQuery)) {
                q = prefixQuery(keyOrQuery, nodeCode);
            }
            StatesUtils.update(tableId, (/** @type {?} */ ({
                query: nodeCode ? q : matchAllQuery()
            })));
        }
    }
}
DataUtils.DEFAULT_ROOT_SEQ = '001';
DataUtils.DEFAULT_PROPS = {
    parentKey: 'parent.code',
    seqKey: 'code',
    seqLen: 3
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DataFieldUtils {
    /**
     * @param {?} dataField
     * @return {?}
     */
    static getFieldDefaultProps(dataField) {
        switch (dataField.dataAttr) {
            case DataAttr.DATA_CODE:
                return DataFieldUtils.getDataCodeFieldProps(dataField);
            case DataAttr.URL:
                dataField.dataType = DataType.STRING;
                dataField.pattern = RegPatterns.url;
                break;
            case DataAttr.PHONE:
                dataField.dataType = DataType.STRING;
                dataField.pattern = RegPatterns.phone;
                break;
            case DataAttr.ID_CARD:
                dataField.dataType = DataType.STRING;
                break;
            case DataAttr.EMAIL:
                dataField.dataType = DataType.STRING;
                dataField.pattern = RegPatterns.email;
                break;
            case DataAttr.CURRENCY:
                dataField.defaultValue = 0;
                dataField.dataType = DataType.NUMBER;
                dataField.pattern = RegPatterns.pNumeric;
                break;
        }
        return dataField;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    static getDefaultFieldName(field) {
        if (field) {
            if (field.defaultKey) {
                return field.defaultKey;
            }
            else {
                return field.key;
            }
        }
    }
    /**
     * @param {?} fieldValue
     * @param {?} field
     * @return {?}
     */
    static getFieldDisplayContent(fieldValue, field) {
        if (!fieldValue) {
            return '';
        }
        if (field) {
            if (CommonsUtils.isJson(fieldValue)) {
                /** @type {?} */
                let key;
                if (field) {
                    key = DataFieldUtils.getDefaultFieldName(field);
                }
                if (key) {
                    return CommonsUtils.get(fieldValue, key);
                }
                else {
                    /** @type {?} */
                    const trans = {};
                    Object.keys(fieldValue).forEach(sub => {
                        /** @type {?} */
                        const label = CommonsUtils.get(field, `fields.${sub}.label`)
                            && CommonsUtils.get(field, `refer.entity.${sub}.label`)
                            && CommonsUtils.get(field, `refer.${sub}.label`);
                        if (label) {
                            trans[label] = fieldValue[sub];
                        }
                        else {
                            trans[sub] = fieldValue[sub];
                        }
                    });
                    fieldValue = trans;
                }
            }
        }
        if (CommonsUtils.isBoolean(fieldValue)) {
            return fieldValue ? '是' : '否';
        }
        else {
            return CommonsUtils.getText(fieldValue);
        }
    }
    /**
     * @private
     * @param {?} dataField
     * @return {?}
     */
    static getDataCodeFieldProps(dataField) {
        /** @type {?} */
        const props = ConfigUtils.getConfig().dataFieldProps.dataCode;
        if (!dataField.catCode) {
            LogUtils.error('DataFieldUtils', `dataCode字段没有定义【catCode】属性`, dataField);
            return;
        }
        return (/** @type {?} */ ({
            dataType: DataType.JSON,
            sortKey: props.codeKey,
            aggKey: props.codeKey,
            defaultKey: props.nameKey,
            apiDataProps: (/** @type {?} */ ({
                apiEntry: props.apiEntry,
                searchFields: [props.nameKey, props.codeKey, props.abbrKey],
                returnFields: [props.nameKey, props.codeKey],
                query: [
                    termQuery(`${props.catKey}.code`, dataField.catCode),
                    props.inUseKey ? boolQuery().mustNot(termQuery(props.inUseKey, false)) : undefined
                ],
                sort: props.codeKey,
                size: 10
            })),
            dataItemProps: {
                labelKey: props.nameKey,
                valueKey: [props.nameKey, props.codeKey],
                idKey: props.codeKey,
                template: (item) => {
                    return `<span><b>${item[props.nameKey]}</b></span>  <span class="badge badge-info"> ${item[props.codeKey]}</span> `;
                }
            }
        }));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ChangesUtils {
    /**
     * @param {?} diff
     * @return {?}
     */
    static getChangeByDiff(diff) {
        if (!diff) {
            return {};
        }
        /** @type {?} */
        const changes = {
            changed: [],
            added: [],
            deleted: []
        };
        if (diff) {
            diff.forEachChangedItem(r => {
                changes.changed.push({
                    key: r.key,
                    value: r.currentValue,
                    from: r.previousValue
                });
            });
            diff.forEachAddedItem(r => {
                changes.added.push({
                    key: r.key,
                    value: r.currentValue
                });
            });
            diff.forEachRemovedItem(r => {
                changes.deleted.push({
                    key: r.key,
                    value: r.previousValue
                });
            });
        }
        return CommonsUtils.omitBy(changes, CommonsUtils.lodash().isEmpty);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ResourceUtils {
    /**
     * @param {?} options
     * @return {?}
     */
    static getConfigs(options) {
        /** @type {?} */
        let root = '';
        /** @type {?} */
        let path;
        /** @type {?} */
        let resourceUri = options.path;
        /** @type {?} */
        const resourcesConfig = Object.assign({}, ConfigUtils.getConfig().resources, options);
        if (resourcesConfig.root) {
            if (!resourceUri.startsWith('/')) {
                root = resourcesConfig.root;
            }
            else {
                resourceUri = resourceUri.substr(1);
            }
            if (!resourceUri.endsWith('.json')) {
                resourceUri += '.json';
            }
        }
        else {
            root = resourcesConfig.uri;
        }
        if (options.state) {
            path = options.state;
        }
        else {
            path = [options.module, options.key];
        }
        /** @type {?} */
        const state = StatesUtils.get(path, true);
        if (!state.value || options.reload) {
            if (options.initial) {
                state.next(options.initial);
            }
            return HttpUtils.request({
                uri: `${root}/${resourceUri}`,
                tag: path,
                onResponse: (response) => response ? CommonsUtils.restoreJsonFn(response) : null
            }).pipe(take(1), tap(response => StatesUtils.create(path, response, resourcesConfig.reserve || resourcesConfig.state !== undefined)));
        }
        else {
            return state;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UrlUtils {
    /**
     * @param {?} url
     * @return {?}
     */
    static parse(url) {
        return UrlUtils.serializer.parse(url.toLowerCase());
    }
    /**
     * @param {?} tree
     * @return {?}
     */
    static serialize(tree) {
        return UrlUtils.serialize(tree);
    }
}
UrlUtils.serializer = new DefaultUrlSerializer();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// https://itnext.io/cache-components-with-angular-routereusestrategy-3e4c8b174d5f
class CachedRouteReuseStrategy {
    constructor() {
        this.storedRouteHandles = new Map();
        this.allowRetrieveCache = {};
    }
    /**
     * @param {?} future
     * @param {?} curr
     * @return {?}
     */
    shouldReuseRoute(future, curr) {
        if (this.isInOutlet(future['_routerState'].url) || this.isInOutlet(curr['_routerState'].url)) {
            return future.routeConfig === curr.routeConfig;
        }
        return future.routeConfig === curr.routeConfig && (false !== (future.data && future.data.$reuse));
    }
    /**
     * @param {?} route
     * @return {?}
     */
    retrieve(route) {
        return (/** @type {?} */ (this.storedRouteHandles.get(this.getPath(route))));
    }
    /**
     * @param {?} route
     * @return {?}
     */
    shouldAttach(route) {
        /** @type {?} */
        const path = this.getPath(route);
        if (this.allowRetrieveCache[path]) {
            return this.storedRouteHandles.has(this.getPath(route));
        }
        return false;
    }
    /**
     * @param {?} route
     * @return {?}
     */
    shouldDetach(route) {
        /** @type {?} */
        const path = this.getPath(route);
        if (this.allowRetrieveCache.hasOwnProperty(path)) {
            return true;
        }
        return false;
    }
    /**
     * @param {?} route
     * @param {?} detachedTree
     * @return {?}
     */
    store(route, detachedTree) {
        this.storedRouteHandles.set(this.getPath(route), detachedTree);
    }
    /**
     * @private
     * @param {?} url
     * @return {?}
     */
    isInOutlet(url) {
        return /.*\(.*:.*\).*/.test(url);
    }
    /**
     * @private
     * @param {?} route
     * @return {?}
     */
    getPath(route) {
        if (route.routeConfig !== null && route.routeConfig.path !== null) {
            return route.routeConfig.path;
        }
        return '';
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const APP_CONFIG = new InjectionToken('APP_CONFIG');
class ErCoreModule {
    /**
     * @param {?} injector
     */
    constructor(injector) {
        this.injector = injector;
        if (!DiUtils.injector) {
            DiUtils.injector = injector;
            // load services
            injector.get(RouterStateService);
            injector.get(TaskService);
            try {
                /** @type {?} */
                const stompService = injector.get(StompService);
                if (stompService && ConfigUtils.getConfig().stomp.enabled) {
                    stompService.state
                        .pipe(distinctUntilChanged(), tap((state) => {
                        StatesUtils.update(StateNames.socket, { state: StompStates[state] });
                        StatesUtils.update(StateNames.notify, {
                            type: state === 0 ? NotifyType.ANNOUNCE : NotifyType.ALERT,
                            message: `消息服务器状态：${StompStates[state]}`,
                            level: state === 0 ? NotifyLevel.ERROR : NotifyLevel.INFO
                        });
                    })).subscribe();
                }
            }
            catch (e) {
            }
        }
    }
    /**
     * @param {?} appConfig
     * @return {?}
     */
    static forRoot(appConfig) {
        return {
            ngModule: ErCoreModule,
            providers: [
                { provide: APP_CONFIG, useValue: appConfig },
                // {
                //   provide: APP_INITIALIZER,
                //   useFactory: initialize,
                //   deps: [APP_CONFIG],
                //   multi: true
                // },
                ...CoreInterceptors,
                appConfig.stomp.enabled ? StompService : [],
                appConfig.stomp.enabled ? { provide: StompConfig, useValue: appConfig.stomp } : [],
                { provide: BACKGROUND_TASK_TOKEN, useValue: DateSyncUtils.start, multi: true },
                { provide: BACKGROUND_TASK_TOKEN, useValue: CORE_TASKS, multi: true },
                {
                    provide: RouteReuseStrategy,
                    useClass: CachedRouteReuseStrategy
                }
            ]
        };
    }
}
ErCoreModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    RouterModule,
                    HttpClientModule,
                    NgPipesModule,
                    DynamicModule.withComponents(CoreComponents)
                ],
                declarations: [
                    ...CoreComponents,
                    ...CoreDirectives,
                    ...CorePipes
                ],
                exports: [
                    CommonModule,
                    RouterModule,
                    HttpClientModule,
                    NgPipesModule,
                    ...CoreComponents,
                    ...CoreDirectives,
                    ...CorePipes
                ]
            },] }
];
/** @nocollapse */
ErCoreModule.ctorParameters = () => [
    { type: Injector }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { ErCoreModule, BaseClass, Unsubscribe, BaseDirective, BaseService, BaseComponent, RouteBindComponent, ControlComponent, WrapperComponent, ControlWrapperComponent, DataAwareControlWrapperComponent, BaseFormComponent, AppConfigComponent, ModuleConfigComponent, AbstractLoginComponent, AbstractRegisterComponent, AbstractChangePwdComponent, AuthBaseComponent, CoreComponents, BreadcrumbsComponent, StateButtonComponent, StateButtonsComponent, DynaContentComponent, ContainerComponent, DataItemComponent, HttpStatusComponent, FluidContainerComponent, LeftRightContainerComponent, MobileType, PhonePreviewComponent, RouteDataPropsBindComponent, QueryBuilderComponent, QueryBuilderRuleComponent, AnimateNumberComponent, DynaCompComponent, JsonViewerDirective, ObjectDiff, CoreDirectives, AnimateDirective, ApiDataDirective, TypedTemplateDirective, DynaTemplateDirective, PropsBindDirective, TagDirective, SelectorDirective, PositionDirective, RemoveMeDirective, HttpSpinnerDirective, NotifySpinnerDirective, HighlightDirective, FocusHighlightDirective, MovableHandleDirective, Position, MovableDirective, HttpAppConfiguredInterceptor, HttpErrorHandlerInterceptor, HttpJwtAuthInterceptor, HttpProgressInterceptor, HttpLogInterceptor, HttpTimeoutInterceptor, CoreInterceptors, esBoundInterceptor, credentialHttpRequestInterceptor, FilterPipe, HighLightPipe, KeysPipe, SafeHtmlPipe, StylePipe, KeyValuePipe, JoinPipe, ObservablePipe, OrderByPipe, IdCardPipe, SplitPipe, UniquePipe, Base64DecodePipe, CommaSeparatedNumberPipe, LinkifyPipe, NumberToTextPipe, UnitNumberPipe, DataItemsPipe, TreeNodesPipe, PercentPipe, SubPipe, TextPipe, TimerPipe, UpToNowPipe, ValuePipe, DefaultPipe, TrackerPipe, EmojifyPipe, CorePipes, GlobalErrorHandler, AuthGuard, DeactivateGuard, ConfigurablePreloadingStrategy, TaskService, BACKGROUND_TASK_TOKEN, RouterStateService, ResourceResolver, LogService, PathPropsDataResolver, CoreServices, updateTitleTask, CORE_TASKS, HTTP_STATE$, HTTP_TAG_STATE$, ROUTE_STATE$, ROUTE_OUTLET_STATE$, WEB_SOCKET_STATES, AnnotationsUtils, DEFAULT_API_REQUEST_OPTIONS, ApiUtils, anyRoleUser, AuthUtils, PermissionUtils, DateSyncUtils, DataUtils, DataFieldUtils, ComponentUtils, ChangesUtils, DiUtils, LogUtils, DynaComponentUtils, HttpUtils, RouteUtils, ResourceUtils, UrlUtils, NgAsyncValidator, FormlyAsyncValidator, WechatQrCodeComponent as ɵb, AnimatedIfDirective as ɵc, SpinnerBaseDirective as ɵd, APP_CONFIG as ɵa, CachedRouteReuseStrategy as ɵe };

//# sourceMappingURL=er-core.js.map