/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
export class TokenizerUtils {
    /**
     * @param {?} str
     * @param {?} format
     * @return {?}
     */
    static extract(str, format) {
        if (str === format) {
            return new ExtractionResult(true);
        }
        /** @type {?} */
        const formatTokens = new FormatStringTokenizer().Tokenize(format);
        if (!formatTokens) {
            return new ExtractionResult(str === '');
        }
        /** @type {?} */
        const result = new ExtractionResult(true);
        for (let i = 0; i < formatTokens.length; i++) {
            /** @type {?} */
            const currentToken = formatTokens[i];
            /** @type {?} */
            const previousToken = i > 0 ? formatTokens[i - 1] : null;
            if (currentToken.Type === FormatStringTokenType.ConstantText) {
                if (i === 0) {
                    if (str.indexOf(currentToken.Text) !== 0) {
                        result.isMatch = false;
                        return result;
                    }
                    str = str.substr(currentToken.Text.length, str.length - currentToken.Text.length);
                }
                else {
                    /** @type {?} */
                    const matchIndex = str.indexOf(currentToken.Text);
                    if (matchIndex < 0) {
                        result.isMatch = false;
                        return result;
                    }
                    result.matches.push({ name: previousToken.Text, value: str.substr(0, matchIndex) });
                    str = str.substring(0, matchIndex + currentToken.Text.length);
                }
            }
        }
        /** @type {?} */
        const lastToken = formatTokens[formatTokens.length - 1];
        if (lastToken.Type === FormatStringTokenType.DynamicValue) {
            result.matches.push({ name: lastToken.Text, value: str });
        }
        return result;
    }
    /**
     * @param {?} str
     * @param {?} format
     * @return {?}
     */
    static matches(str, format) {
        /** @type {?} */
        const result = TokenizerUtils.extract(str, format);
        if (!result.isMatch) {
            return [];
        }
        /** @type {?} */
        const values = [];
        for (let i = 0; i < result.matches.length; i++) {
            values.push(result.matches[i].value);
        }
        return values;
    }
}
export class ExtractionResult {
    /**
     * @param {?} isMatch
     */
    constructor(isMatch) {
        this.isMatch = isMatch;
        this.matches = [];
    }
}
if (false) {
    /** @type {?} */
    ExtractionResult.prototype.isMatch;
    /** @type {?} */
    ExtractionResult.prototype.matches;
}
/** @enum {number} */
const FormatStringTokenType = {
    ConstantText: 0,
    DynamicValue: 1,
};
export { FormatStringTokenType };
FormatStringTokenType[FormatStringTokenType.ConstantText] = 'ConstantText';
FormatStringTokenType[FormatStringTokenType.DynamicValue] = 'DynamicValue';
export class FormatStringToken {
    /**
     * @param {?} text
     * @param {?} type
     */
    constructor(text, type) {
        this.Text = text;
        this.Type = type;
    }
}
if (false) {
    /** @type {?} */
    FormatStringToken.prototype.Text;
    /** @type {?} */
    FormatStringToken.prototype.Type;
}
export class FormatStringTokenizer {
    /**
     * @param {?} format
     * @param {?=} includeBracketsForDynamicValues
     * @return {?}
     */
    Tokenize(format, includeBracketsForDynamicValues = false) {
        /** @type {?} */
        const tokens = [];
        /** @type {?} */
        let currentText = '';
        /** @type {?} */
        let inDynamicValue = false;
        for (let i = 0; i < format.length; i++) {
            /** @type {?} */
            const c = format[i];
            switch (c) {
                case '{':
                    if (inDynamicValue) {
                        throw new Error('Incorrect syntax at char ' + i + '! format string can not contain agg dynamic value expression!');
                    }
                    inDynamicValue = true;
                    if (currentText.length > 0) {
                        tokens.push(new FormatStringToken(currentText, FormatStringTokenType.ConstantText));
                        currentText = '';
                    }
                    break;
                case '}':
                    if (!inDynamicValue) {
                        throw new Error(('Incorrect syntax at char ' + i + '! These is no opening brackets for the closing bracket }.'));
                    }
                    inDynamicValue = false;
                    if (currentText.length <= 0) {
                        throw new Error(('Incorrect syntax at char ' + i + '! Brackets does not containt any chars.'));
                    }
                    /** @type {?} */
                    let dynamicValue = currentText;
                    if (includeBracketsForDynamicValues) {
                        dynamicValue = '{' + dynamicValue + '}';
                    }
                    tokens.push(new FormatStringToken(dynamicValue, FormatStringTokenType.DynamicValue));
                    currentText = '';
                    break;
                default:
                    currentText += c;
                    break;
            }
        }
        if (inDynamicValue) {
            throw new Error(('There is no closing } char for an opened { char.'));
        }
        if (currentText.length > 0) {
            tokens.push(new FormatStringToken(currentText, FormatStringTokenType.ConstantText));
        }
        return tokens;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AZXIvdXRpbHMvIiwic291cmNlcyI6WyJsaWIvdG9rZW5pemVyL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxNQUFNLE9BQU8sY0FBYzs7Ozs7O0lBRXhCLE1BQU0sQ0FBQyxPQUFPLENBQUMsR0FBVyxFQUFFLE1BQWM7UUFDckMsSUFBSSxHQUFHLEtBQUssTUFBTSxFQUFFO1lBQ2hCLE9BQU8sSUFBSSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNyQzs7Y0FFSyxZQUFZLEdBQUcsSUFBSSxxQkFBcUIsRUFBRSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUM7UUFDakUsSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNmLE9BQU8sSUFBSSxnQkFBZ0IsQ0FBQyxHQUFHLEtBQUssRUFBRSxDQUFDLENBQUM7U0FDM0M7O2NBRUssTUFBTSxHQUFHLElBQUksZ0JBQWdCLENBQUMsSUFBSSxDQUFDO1FBRXpDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxZQUFZLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFOztrQkFDcEMsWUFBWSxHQUFHLFlBQVksQ0FBQyxDQUFDLENBQUM7O2tCQUM5QixhQUFhLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSTtZQUV4RCxJQUFJLFlBQVksQ0FBQyxJQUFJLEtBQUsscUJBQXFCLENBQUMsWUFBWSxFQUFFO2dCQUMxRCxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7b0JBQ1QsSUFBSSxHQUFHLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7d0JBQ3RDLE1BQU0sQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO3dCQUN2QixPQUFPLE1BQU0sQ0FBQztxQkFDakI7b0JBRUQsR0FB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Q0FBQyxDQUFDLGtEQUFrRCxDQUFDLENBQUMsQ0FBQztTQUN6RTtRQUVELElBQUksV0FBVyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDeEIsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLGlCQUFpQixDQUFDLFdBQVcsRUFBRSxxQkFBcUIsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO1NBQ3ZGO1FBRUQsT0FBTyxNQUFNLENBQUM7SUFDbEIsQ0FBQztDQUVKIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIFRva2VuaXplclV0aWxzIHtcblxuICAgc3RhdGljIGV4dHJhY3Qoc3RyOiBzdHJpbmcsIGZvcm1hdDogc3RyaW5nKTogRXh0cmFjdGlvblJlc3VsdCB7XG4gICAgICAgIGlmIChzdHIgPT09IGZvcm1hdCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFeHRyYWN0aW9uUmVzdWx0KHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZm9ybWF0VG9rZW5zID0gbmV3IEZvcm1hdFN0cmluZ1Rva2VuaXplcigpLlRva2VuaXplKGZvcm1hdCk7XG4gICAgICAgIGlmICghZm9ybWF0VG9rZW5zKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEV4dHJhY3Rpb25SZXN1bHQoc3RyID09PSAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgRXh0cmFjdGlvblJlc3VsdCh0cnVlKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZvcm1hdFRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFRva2VuID0gZm9ybWF0VG9rZW5zW2ldO1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNUb2tlbiA9IGkgPiAwID8gZm9ybWF0VG9rZW5zW2kgLSAxXSA6IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50VG9rZW4uVHlwZSA9PT0gRm9ybWF0U3RyaW5nVG9rZW5UeXBlLkNvbnN0YW50VGV4dCkge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHIuaW5kZXhPZihjdXJyZW50VG9rZW4uVGV4dCkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5pc01hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc3RyID0gc3RyLnN1YnN0cihjdXJyZW50VG9rZW4uVGV4dC5sZW5ndGgsIHN0ci5sZW5ndGggLSBjdXJyZW50VG9rZW4uVGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoSW5kZXggPSBzdHIuaW5kZXhPZihjdXJyZW50VG9rZW4uVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaEluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmlzTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5tYXRjaGVzLnB1c2goeyBuYW1lOiBwcmV2aW91c1Rva2VuLlRleHQsIHZhbHVlOiBzdHIuc3Vic3RyKDAsIG1hdGNoSW5kZXgpIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIG1hdGNoSW5kZXggKyBjdXJyZW50VG9rZW4uVGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxhc3RUb2tlbiA9IGZvcm1hdFRva2Vuc1tmb3JtYXRUb2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChsYXN0VG9rZW4uVHlwZSA9PT0gRm9ybWF0U3RyaW5nVG9rZW5UeXBlLkR5bmFtaWNWYWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0Lm1hdGNoZXMucHVzaCh7IG5hbWU6IGxhc3RUb2tlbi5UZXh0LCB2YWx1ZTogc3RyIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBzdGF0aWMgbWF0Y2hlcyhzdHI6IHN0cmluZywgZm9ybWF0OiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFRva2VuaXplclV0aWxzLmV4dHJhY3Qoc3RyLCBmb3JtYXQpO1xuICAgICAgICBpZiAoIXJlc3VsdC5pc01hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubWF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2gocmVzdWx0Lm1hdGNoZXNbaV0udmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBFeHRyYWN0aW9uUmVzdWx0IHtcblxuICAgIHB1YmxpYyBpc01hdGNoOiBib29sZWFuO1xuICAgIHB1YmxpYyBtYXRjaGVzOiBhbnlbXTtcblxuXG4gICAgY29uc3RydWN0b3IoaXNNYXRjaDogYm9vbGVhbikge1xuICAgICAgICB0aGlzLmlzTWF0Y2ggPSBpc01hdGNoO1xuICAgICAgICB0aGlzLm1hdGNoZXMgPSBbXTtcbiAgICB9XG59XG5cbmV4cG9ydCBlbnVtIEZvcm1hdFN0cmluZ1Rva2VuVHlwZSB7XG4gICAgQ29uc3RhbnRUZXh0LFxuICAgIER5bmFtaWNWYWx1ZVxufVxuXG5leHBvcnQgY2xhc3MgRm9ybWF0U3RyaW5nVG9rZW4ge1xuXG4gICAgcHVibGljIFRleHQ6IHN0cmluZztcblxuICAgIHB1YmxpYyBUeXBlOiBGb3JtYXRTdHJpbmdUb2tlblR5cGU7XG5cbiAgICBjb25zdHJ1Y3Rvcih0ZXh0OiBzdHJpbmcsIHR5cGU6IEZvcm1hdFN0cmluZ1Rva2VuVHlwZSkge1xuICAgICAgICB0aGlzLlRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLlR5cGUgPSB0eXBlO1xuICAgIH1cblxufVxuXG5leHBvcnQgY2xhc3MgRm9ybWF0U3RyaW5nVG9rZW5pemVyIHtcblxuICAgIFRva2VuaXplKGZvcm1hdDogc3RyaW5nLCBpbmNsdWRlQnJhY2tldHNGb3JEeW5hbWljVmFsdWVzOiBib29sZWFuID0gZmFsc2UpOiBGb3JtYXRTdHJpbmdUb2tlbltdIHtcbiAgICAgICAgY29uc3QgdG9rZW5zOiBGb3JtYXRTdHJpbmdUb2tlbltdID0gW107XG5cbiAgICAgICAgbGV0IGN1cnJlbnRUZXh0ID0gJyc7XG4gICAgICAgIGxldCBpbkR5bmFtaWNWYWx1ZSA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm9ybWF0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gZm9ybWF0W2ldO1xuICAgICAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbkR5bmFtaWNWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IHN5bnRheCBhdCBjaGFyICcgKyBpICsgJyEgZm9ybWF0IHN0cmluZyBjYW4gbm90IGNvbnRhaW4gYWdnIGR5bmFtaWMgdmFsdWUgZXhwcmVzc2lvbiEnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGluRHluYW1pY1ZhbHVlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2gobmV3IEZvcm1hdFN0cmluZ1Rva2VuKGN1cnJlbnRUZXh0LCBGb3JtYXRTdHJpbmdUb2tlblR5cGUuQ29uc3RhbnRUZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGV4dCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnfSc6XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5EeW5hbWljVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoJ0luY29ycmVjdCBzeW50YXggYXQgY2hhciAnICsgaSArICchIFRoZXNlIGlzIG5vIG9wZW5pbmcgYnJhY2tldHMgZm9yIHRoZSBjbG9zaW5nIGJyYWNrZXQgfS4nKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpbkR5bmFtaWNWYWx1ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VGV4dC5sZW5ndGggPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCgnSW5jb3JyZWN0IHN5bnRheCBhdCBjaGFyICcgKyBpICsgJyEgQnJhY2tldHMgZG9lcyBub3QgY29udGFpbnQgYW55IGNoYXJzLicpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBkeW5hbWljVmFsdWUgPSBjdXJyZW50VGV4dDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluY2x1ZGVCcmFja2V0c0ZvckR5bmFtaWNWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR5bmFtaWNWYWx1ZSA9ICd7JyArIGR5bmFtaWNWYWx1ZSArICd9JztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKG5ldyBGb3JtYXRTdHJpbmdUb2tlbihkeW5hbWljVmFsdWUsIEZvcm1hdFN0cmluZ1Rva2VuVHlwZS5EeW5hbWljVmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRleHQgPSAnJztcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGV4dCArPSBjO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbkR5bmFtaWNWYWx1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCgnVGhlcmUgaXMgbm8gY2xvc2luZyB9IGNoYXIgZm9yIGFuIG9wZW5lZCB7IGNoYXIuJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRUZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKG5ldyBGb3JtYXRTdHJpbmdUb2tlbihjdXJyZW50VGV4dCwgRm9ybWF0U3RyaW5nVG9rZW5UeXBlLkNvbnN0YW50VGV4dCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG5cbn1cbiJdfQ==