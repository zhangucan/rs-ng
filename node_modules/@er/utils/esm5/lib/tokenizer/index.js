/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TokenizerUtils = /** @class */ (function () {
    function TokenizerUtils() {
    }
    /**
     * @param {?} str
     * @param {?} format
     * @return {?}
     */
    TokenizerUtils.extract = /**
     * @param {?} str
     * @param {?} format
     * @return {?}
     */
    function (str, format) {
        if (str === format) {
            return new ExtractionResult(true);
        }
        /** @type {?} */
        var formatTokens = new FormatStringTokenizer().Tokenize(format);
        if (!formatTokens) {
            return new ExtractionResult(str === '');
        }
        /** @type {?} */
        var result = new ExtractionResult(true);
        for (var i = 0; i < formatTokens.length; i++) {
            /** @type {?} */
            var currentToken = formatTokens[i];
            /** @type {?} */
            var previousToken = i > 0 ? formatTokens[i - 1] : null;
            if (currentToken.Type === FormatStringTokenType.ConstantText) {
                if (i === 0) {
                    if (str.indexOf(currentToken.Text) !== 0) {
                        result.isMatch = false;
                        return result;
                    }
                    str = str.substr(currentToken.Text.length, str.length - currentToken.Text.length);
                }
                else {
                    /** @type {?} */
                    var matchIndex = str.indexOf(currentToken.Text);
                    if (matchIndex < 0) {
                        result.isMatch = false;
                        return result;
                    }
                    result.matches.push({ name: previousToken.Text, value: str.substr(0, matchIndex) });
                    str = str.substring(0, matchIndex + currentToken.Text.length);
                }
            }
        }
        /** @type {?} */
        var lastToken = formatTokens[formatTokens.length - 1];
        if (lastToken.Type === FormatStringTokenType.DynamicValue) {
            result.matches.push({ name: lastToken.Text, value: str });
        }
        return result;
    };
    /**
     * @param {?} str
     * @param {?} format
     * @return {?}
     */
    TokenizerUtils.matches = /**
     * @param {?} str
     * @param {?} format
     * @return {?}
     */
    function (str, format) {
        /** @type {?} */
        var result = TokenizerUtils.extract(str, format);
        if (!result.isMatch) {
            return [];
        }
        /** @type {?} */
        var values = [];
        for (var i = 0; i < result.matches.length; i++) {
            values.push(result.matches[i].value);
        }
        return values;
    };
    return TokenizerUtils;
}());
export { TokenizerUtils };
var ExtractionResult = /** @class */ (function () {
    function ExtractionResult(isMatch) {
        this.isMatch = isMatch;
        this.matches = [];
    }
    return ExtractionResult;
}());
export { ExtractionResult };
if (false) {
    /** @type {?} */
    ExtractionResult.prototype.isMatch;
    /** @type {?} */
    ExtractionResult.prototype.matches;
}
/** @enum {number} */
var FormatStringTokenType = {
    ConstantText: 0,
    DynamicValue: 1,
};
export { FormatStringTokenType };
FormatStringTokenType[FormatStringTokenType.ConstantText] = 'ConstantText';
FormatStringTokenType[FormatStringTokenType.DynamicValue] = 'DynamicValue';
var FormatStringToken = /** @class */ (function () {
    function FormatStringToken(text, type) {
        this.Text = text;
        this.Type = type;
    }
    return FormatStringToken;
}());
export { FormatStringToken };
if (false) {
    /** @type {?} */
    FormatStringToken.prototype.Text;
    /** @type {?} */
    FormatStringToken.prototype.Type;
}
var FormatStringTokenizer = /** @class */ (function () {
    function FormatStringTokenizer() {
    }
    /**
     * @param {?} format
     * @param {?=} includeBracketsForDynamicValues
     * @return {?}
     */
    FormatStringTokenizer.prototype.Tokenize = /**
     * @param {?} format
     * @param {?=} includeBracketsForDynamicValues
     * @return {?}
     */
    function (format, includeBracketsForDynamicValues) {
        if (includeBracketsForDynamicValues === void 0) { includeBracketsForDynamicValues = false; }
        /** @type {?} */
        var tokens = [];
        /** @type {?} */
        var currentText = '';
        /** @type {?} */
        var inDynamicValue = false;
        for (var i = 0; i < format.length; i++) {
            /** @type {?} */
            var c = format[i];
            switch (c) {
                case '{':
                    if (inDynamicValue) {
                        throw new Error('Incorrect syntax at char ' + i + '! format string can not contain agg dynamic value expression!');
                    }
                    inDynamicValue = true;
                    if (currentText.length > 0) {
                        tokens.push(new FormatStringToken(currentText, FormatStringTokenType.ConstantText));
                        currentText = '';
                    }
                    break;
                case '}':
                    if (!inDynamicValue) {
                        throw new Error(('Incorrect syntax at char ' + i + '! These is no opening brackets for the closing bracket }.'));
                    }
                    inDynamicValue = false;
                    if (currentText.length <= 0) {
                        throw new Error(('Incorrect syntax at char ' + i + '! Brackets does not containt any chars.'));
                    }
                    /** @type {?} */
                    var dynamicValue = currentText;
                    if (includeBracketsForDynamicValues) {
                        dynamicValue = '{' + dynamicValue + '}';
                    }
                    tokens.push(new FormatStringToken(dynamicValue, FormatStringTokenType.DynamicValue));
                    currentText = '';
                    break;
                default:
                    currentText += c;
                    break;
            }
        }
        if (inDynamicValue) {
            throw new Error(('There is no closing } char for an opened { char.'));
        }
        if (currentText.length > 0) {
            tokens.push(new FormatStringToken(currentText, FormatStringTokenType.ConstantText));
        }
        return tokens;
    };
    return FormatStringTokenizer;
}());
export { FormatStringTokenizer };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AZXIvdXRpbHMvIiwic291cmNlcyI6WyJsaWIvdG9rZW5pemVyL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTtJQUFBO0lBNkRBLENBQUM7Ozs7OztJQTNEUyxzQkFBTzs7Ozs7SUFBZCxVQUFlLEdBQVcsRUFBRSxNQUFjO1FBQ3JDLElBQUksR0FBRyxLQUFLLE1BQU0sRUFBRTtZQUNoQixPQUFPLElBQUksZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDckM7O1lBRUssWUFBWSxHQUFHLElBQUkscUJBQXFCLEVBQUUsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDO1FBQ2pFLElBQUksQ0FBQyxZQUFZLEVBQUU7WUFDZixPQUFPLElBQUksZ0JBQWdCLENBQUMsR0FBRyxLQUFLLEVBQUUsQ0FBQyxDQUFDO1NBQzNDOztZQUVLLE1BQU0sR0FBRyxJQUFJLGdCQUFnQixDQUFDLElBQUksQ0FBQztRQUV6QyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsWUFBWSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTs7Z0JBQ3BDLFlBQVksR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDOztnQkFDOUIsYUFBYSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUk7WUFFeEQsSUFBSSxZQUFZLENBQUMsSUFBSSxLQUFLLHFCQUFxQixDQUFDLFlBQVksRUFBRTtnQkFDMUQsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO29CQUNULElBQUksR0FBRyxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO3dCQUN0QyxNQUFNLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQzt3QkFDdkIsT0FBTyxNQUFNLENBQUM7cUJBQ2pCO29CQUVELEdB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QUMsQ0FBQztvQkFDakIsTUFBTTthQUNiO1NBQ0o7UUFFRCxJQUFJLGNBQWMsRUFBRTtZQUNoQixNQUFNLElBQUksS0FBSyxDQUFDLENBQUMsa0RBQWtELENBQUMsQ0FBQyxDQUFDO1NBQ3pFO1FBRUQsSUFBSSxXQUFXLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUN4QixNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksaUJBQWlCLENBQUMsV0FBVyxFQUFFLHFCQUFxQixDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUM7U0FDdkY7UUFFRCxPQUFPLE1BQU0sQ0FBQztJQUNsQixDQUFDO0lBRUwsNEJBQUM7QUFBRCxDQUFDLEFBN0RELElBNkRDIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIFRva2VuaXplclV0aWxzIHtcblxuICAgc3RhdGljIGV4dHJhY3Qoc3RyOiBzdHJpbmcsIGZvcm1hdDogc3RyaW5nKTogRXh0cmFjdGlvblJlc3VsdCB7XG4gICAgICAgIGlmIChzdHIgPT09IGZvcm1hdCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFeHRyYWN0aW9uUmVzdWx0KHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZm9ybWF0VG9rZW5zID0gbmV3IEZvcm1hdFN0cmluZ1Rva2VuaXplcigpLlRva2VuaXplKGZvcm1hdCk7XG4gICAgICAgIGlmICghZm9ybWF0VG9rZW5zKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEV4dHJhY3Rpb25SZXN1bHQoc3RyID09PSAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgRXh0cmFjdGlvblJlc3VsdCh0cnVlKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZvcm1hdFRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFRva2VuID0gZm9ybWF0VG9rZW5zW2ldO1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNUb2tlbiA9IGkgPiAwID8gZm9ybWF0VG9rZW5zW2kgLSAxXSA6IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50VG9rZW4uVHlwZSA9PT0gRm9ybWF0U3RyaW5nVG9rZW5UeXBlLkNvbnN0YW50VGV4dCkge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHIuaW5kZXhPZihjdXJyZW50VG9rZW4uVGV4dCkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5pc01hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc3RyID0gc3RyLnN1YnN0cihjdXJyZW50VG9rZW4uVGV4dC5sZW5ndGgsIHN0ci5sZW5ndGggLSBjdXJyZW50VG9rZW4uVGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoSW5kZXggPSBzdHIuaW5kZXhPZihjdXJyZW50VG9rZW4uVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaEluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmlzTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5tYXRjaGVzLnB1c2goeyBuYW1lOiBwcmV2aW91c1Rva2VuLlRleHQsIHZhbHVlOiBzdHIuc3Vic3RyKDAsIG1hdGNoSW5kZXgpIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIG1hdGNoSW5kZXggKyBjdXJyZW50VG9rZW4uVGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxhc3RUb2tlbiA9IGZvcm1hdFRva2Vuc1tmb3JtYXRUb2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChsYXN0VG9rZW4uVHlwZSA9PT0gRm9ybWF0U3RyaW5nVG9rZW5UeXBlLkR5bmFtaWNWYWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0Lm1hdGNoZXMucHVzaCh7IG5hbWU6IGxhc3RUb2tlbi5UZXh0LCB2YWx1ZTogc3RyIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBzdGF0aWMgbWF0Y2hlcyhzdHI6IHN0cmluZywgZm9ybWF0OiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFRva2VuaXplclV0aWxzLmV4dHJhY3Qoc3RyLCBmb3JtYXQpO1xuICAgICAgICBpZiAoIXJlc3VsdC5pc01hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubWF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2gocmVzdWx0Lm1hdGNoZXNbaV0udmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBFeHRyYWN0aW9uUmVzdWx0IHtcblxuICAgIHB1YmxpYyBpc01hdGNoOiBib29sZWFuO1xuICAgIHB1YmxpYyBtYXRjaGVzOiBhbnlbXTtcblxuXG4gICAgY29uc3RydWN0b3IoaXNNYXRjaDogYm9vbGVhbikge1xuICAgICAgICB0aGlzLmlzTWF0Y2ggPSBpc01hdGNoO1xuICAgICAgICB0aGlzLm1hdGNoZXMgPSBbXTtcbiAgICB9XG59XG5cbmV4cG9ydCBlbnVtIEZvcm1hdFN0cmluZ1Rva2VuVHlwZSB7XG4gICAgQ29uc3RhbnRUZXh0LFxuICAgIER5bmFtaWNWYWx1ZVxufVxuXG5leHBvcnQgY2xhc3MgRm9ybWF0U3RyaW5nVG9rZW4ge1xuXG4gICAgcHVibGljIFRleHQ6IHN0cmluZztcblxuICAgIHB1YmxpYyBUeXBlOiBGb3JtYXRTdHJpbmdUb2tlblR5cGU7XG5cbiAgICBjb25zdHJ1Y3Rvcih0ZXh0OiBzdHJpbmcsIHR5cGU6IEZvcm1hdFN0cmluZ1Rva2VuVHlwZSkge1xuICAgICAgICB0aGlzLlRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLlR5cGUgPSB0eXBlO1xuICAgIH1cblxufVxuXG5leHBvcnQgY2xhc3MgRm9ybWF0U3RyaW5nVG9rZW5pemVyIHtcblxuICAgIFRva2VuaXplKGZvcm1hdDogc3RyaW5nLCBpbmNsdWRlQnJhY2tldHNGb3JEeW5hbWljVmFsdWVzOiBib29sZWFuID0gZmFsc2UpOiBGb3JtYXRTdHJpbmdUb2tlbltdIHtcbiAgICAgICAgY29uc3QgdG9rZW5zOiBGb3JtYXRTdHJpbmdUb2tlbltdID0gW107XG5cbiAgICAgICAgbGV0IGN1cnJlbnRUZXh0ID0gJyc7XG4gICAgICAgIGxldCBpbkR5bmFtaWNWYWx1ZSA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm9ybWF0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gZm9ybWF0W2ldO1xuICAgICAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbkR5bmFtaWNWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IHN5bnRheCBhdCBjaGFyICcgKyBpICsgJyEgZm9ybWF0IHN0cmluZyBjYW4gbm90IGNvbnRhaW4gYWdnIGR5bmFtaWMgdmFsdWUgZXhwcmVzc2lvbiEnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGluRHluYW1pY1ZhbHVlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2gobmV3IEZvcm1hdFN0cmluZ1Rva2VuKGN1cnJlbnRUZXh0LCBGb3JtYXRTdHJpbmdUb2tlblR5cGUuQ29uc3RhbnRUZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGV4dCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnfSc6XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5EeW5hbWljVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoJ0luY29ycmVjdCBzeW50YXggYXQgY2hhciAnICsgaSArICchIFRoZXNlIGlzIG5vIG9wZW5pbmcgYnJhY2tldHMgZm9yIHRoZSBjbG9zaW5nIGJyYWNrZXQgfS4nKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpbkR5bmFtaWNWYWx1ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VGV4dC5sZW5ndGggPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCgnSW5jb3JyZWN0IHN5bnRheCBhdCBjaGFyICcgKyBpICsgJyEgQnJhY2tldHMgZG9lcyBub3QgY29udGFpbnQgYW55IGNoYXJzLicpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBkeW5hbWljVmFsdWUgPSBjdXJyZW50VGV4dDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluY2x1ZGVCcmFja2V0c0ZvckR5bmFtaWNWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR5bmFtaWNWYWx1ZSA9ICd7JyArIGR5bmFtaWNWYWx1ZSArICd9JztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKG5ldyBGb3JtYXRTdHJpbmdUb2tlbihkeW5hbWljVmFsdWUsIEZvcm1hdFN0cmluZ1Rva2VuVHlwZS5EeW5hbWljVmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRleHQgPSAnJztcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGV4dCArPSBjO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbkR5bmFtaWNWYWx1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCgnVGhlcmUgaXMgbm8gY2xvc2luZyB9IGNoYXIgZm9yIGFuIG9wZW5lZCB7IGNoYXIuJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRUZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKG5ldyBGb3JtYXRTdHJpbmdUb2tlbihjdXJyZW50VGV4dCwgRm9ybWF0U3RyaW5nVG9rZW5UeXBlLkNvbnN0YW50VGV4dCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG5cbn1cbiJdfQ==