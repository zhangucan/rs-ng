import { __rest } from 'tslib';
import * as momentNs from 'moment';
import { FormGroup } from '@angular/forms';
import pinyinlite from 'pinyinlite/index_full';
import { from, of, throwError, BehaviorSubject, fromEvent } from 'rxjs';
import * as _ from 'lodash';
import { range, isEqual, cloneDeep, merge, pickBy, pick, defaultsDeep, set, get, extend, compact, omit, omitBy, unset, find, findIndex, remove, forOwn, map, uniqBy, orderBy, union, flatten, flattenDeep, filter, template } from 'lodash';
import { catchError, map as map$1, first, filter as filter$1, delay, retryWhen, scan } from 'rxjs/operators';
import { VarType, RegPatterns, Devices, UI_COLORS, ChartType, StateNames, ReadAs, ApiServerType, LogLevel, NotifyType, DEFAULT_TREE_NODE_KEYS, NotifyLevel, AggInterval, AggIntervalProps, AggMethods, AggMethodsProps, DEFAULT_ES_QUERY_CONDITION, DEFAULT_QUERY_CONDITION, ES_QUERY_OPERATORS, Order } from '@er/types';
import { avgAggregation, cardinalityAggregation, maxAggregation, minAggregation, sumAggregation, valueCountAggregation, wildcardQuery, prefixQuery, termQuery, matchQuery, requestBodySearch, boolQuery, sort, histogramAggregation, dateHistogramAggregation, termsAggregation, RequestBodySearch } from 'elastic-builder';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const Utils = {
// common: CommonsUtils,
// context: ContextUtils,
// config: ConfigUtils,
// object: ObjectUtils,
// states: StatesUtils,
// reg: RegUtils,
// tree: TreeUtils,
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CacheUtils {
    /**
     * @return {?}
     */
    static getSeq() {
        return ++CacheUtils.seq;
    }
    /**
     * @return {?}
     */
    static getModuleId() {
        return ++CacheUtils.moduleId;
    }
    /**
     * @template T
     * @param {?} type
     * @param {?} key
     * @return {?}
     */
    static get(type, key) {
        /** @type {?} */
        const typeCache = CacheUtils.getTypeCache(type);
        if (!typeCache) {
            return null;
        }
        return typeCache.get(key);
    }
    /**
     * @template T
     * @param {?} type
     * @param {?} key
     * @param {?} data
     * @return {?}
     */
    static put(type, key, data) {
        /** @type {?} */
        let typeCache = CacheUtils.getTypeCache(type);
        if (!typeCache) {
            typeCache = new Map();
            CacheUtils.cache.set(type, typeCache);
        }
        typeCache.set(key, data);
    }
    /**
     * @private
     * @param {?} type
     * @return {?}
     */
    static getTypeCache(type) {
        return CacheUtils.cache.get(type);
    }
}
CacheUtils.cache = new Map();
CacheUtils.seq = 0;
CacheUtils.moduleId = 0;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CommonsUtils {
    /**
     * @return {?}
     */
    static lodash() {
        return _;
    }
    /**
     * @return {?}
     */
    static getSeq() {
        return CacheUtils.getSeq();
    }
    /**
     * @param {?=} max
     * @param {?=} min
     * @return {?}
     */
    static getRandomNumber(max = 10, min) {
        /** @type {?} */
        const result = Math.floor(Math.random() * (max + 1) + (min || 0));
        return result;
    }
    /**
     * @template T
     * @param {?} src
     * @param {?} key
     * @return {?}
     */
    static getObjWhenStr(src, key) {
        /** @type {?} */
        const result = (typeof src === 'string') ? (/** @type {?} */ ({ [key]: src })) : src;
        return result;
    }
    /**
     * @param {?} object
     * @return {?}
     */
    static getVarType(object) {
        /** @type {?} */
        let type = VarType.UNKNOWN;
        if (object === null) {
            type = VarType.NULL;
        }
        else if (object === undefined) {
            type = VarType.UNDEFINED;
        }
        else if (object === true || object === false) {
            type = VarType.BOOLEAN;
        }
        if (type !== VarType.UNKNOWN) {
            return type;
        }
        /** @type {?} */
        const objectType = typeof object;
        if (objectType === 'string') {
            // if (DateUtils.isDate(object)) {
            //   return VarType.DATE;
            // }
            type = VarType.STRING;
        }
        else if (objectType === 'number') {
            type = VarType.NUMBER;
        }
        else if (objectType === 'function') {
            type = VarType.FUNCTION;
        }
        if (object.constructor === [].constructor) {
            type = VarType.ARRAY;
        }
        else if (object.constructor === {}.constructor) {
            type = VarType.JSON;
        }
        return type;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    static isNullOrUndefined(value) {
        return value === undefined || value === null;
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    static isString(obj) {
        return CommonsUtils.getVarType(obj) === VarType.STRING;
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    static isBoolean(obj) {
        return CommonsUtils.getVarType(obj) === VarType.BOOLEAN;
    }
    /**
     * @param {?} s
     * @return {?}
     */
    static isEmptyString(s) {
        return !s || CommonsUtils.isString(s) && s.trim().length === 0;
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    static isArray(obj) {
        return CommonsUtils.getVarType(obj) === VarType.ARRAY;
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    static isNumber(obj) {
        return CommonsUtils.getVarType(obj) === VarType.NUMBER;
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    static isJson(obj) {
        return CommonsUtils.getVarType(obj) === VarType.JSON;
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    static isFunction(obj) {
        return CommonsUtils.getVarType(obj) === VarType.FUNCTION;
    }
    /**
     * @param {?} str
     * @return {?}
     */
    static isUrl(str) {
        /** @type {?} */
        const regexp = /(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?/;
        return regexp.test(str);
    }
    /**
     * @param {?} str
     * @return {?}
     */
    static isInteger(str) {
        return !CommonsUtils.isNullOrUndefined(str) && /^\d+$/.test(str);
    }
    /**
     * @param {?} value
     * @param {?} other
     * @return {?}
     */
    static isEqual(value, other) {
        return isEqual(value, other);
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    static copy(obj) {
        return cloneDeep(obj);
    }
    /**
     * @param {?} obj1
     * @param {...?} obj2
     * @return {?}
     */
    static merge(obj1, ...obj2) {
        return merge.apply(null, [obj1, ...obj2]);
    }
    /**
     * @param {?} obj
     * @param {?} predicate
     * @return {?}
     */
    static pickBy(obj, predicate) {
        return pickBy(obj, predicate);
    }
    /**
     * @param {?} obj
     * @param {?} keys
     * @return {?}
     */
    static pick(obj, keys) {
        return pick(obj, keys);
    }
    /**
     * @param {?} obj1
     * @param {...?} obj2
     * @return {?}
     */
    static defaults(obj1, ...obj2) {
        return defaultsDeep.apply(undefined, [obj1, ...obj2]);
    }
    /**
     * @param {?} obj1
     * @param {?} obj2
     * @return {?}
     */
    static equals(obj1, obj2) {
        return isEqual(obj1, obj2);
    }
    /**
     * @param {?} obj
     * @param {?} path
     * @param {?} value
     * @return {?}
     */
    static set(obj, path, value) {
        return set(obj, path, value);
    }
    /**
     * @param {?} obj
     * @param {?} path
     * @param {?=} defaultValue
     * @return {?}
     */
    static get(obj, path, defaultValue) {
        return get(obj, path, defaultValue);
    }
    /**
     * @param {?} obj
     * @param {?} source
     * @return {?}
     */
    static extend(obj, source) {
        return extend(obj, source);
    }
    /**
     * @param {?} collection
     * @return {?}
     */
    static compact(collection) {
        return compact(collection);
    }
    /**
     * @param {?} obj
     * @param {?} path
     * @return {?}
     */
    static omit(obj, path) {
        return omit(obj, path);
    }
    /**
     * @param {?} obj
     * @param {?} predicate
     * @return {?}
     */
    static omitBy(obj, predicate) {
        return omitBy(obj, predicate);
    }
    /**
     * @param {?} obj
     * @param {?} path
     * @return {?}
     */
    static unset(obj, path) {
        return unset(obj, path);
    }
    /**
     * @param {?} collection
     * @param {?} predicate
     * @return {?}
     */
    static find(collection, predicate) {
        return find(collection, predicate);
    }
    /**
     * @param {?} collection
     * @param {?} predicate
     * @return {?}
     */
    static findIndex(collection, predicate) {
        return findIndex(collection, predicate);
    }
    /**
     * @param {?} collection
     * @param {?} predicate
     * @return {?}
     */
    static remove(collection, predicate) {
        return remove(collection, predicate);
    }
    /**
     * @param {?} obj
     * @param {?} iteratee
     * @return {?}
     */
    static forOwn(obj, iteratee) {
        return forOwn(obj, iteratee);
    }
    /**
     * @param {?} obj
     * @param {?} iteratee
     * @return {?}
     */
    static map(obj, iteratee) {
        return map(obj, iteratee);
    }
    /**
     * @param {?} obj
     * @param {?} by
     * @return {?}
     */
    static unique(obj, by) {
        return uniqBy(obj, by);
    }
    /**
     * @param {?} obj
     * @param {?} iteratees
     * @param {?=} orders
     * @return {?}
     */
    static orderBy(obj, iteratees, orders) {
        return orderBy(obj, iteratees, orders);
    }
    /**
     * @param {...?} obj
     * @return {?}
     */
    static union(...obj) {
        return union(obj);
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    static flatten(obj) {
        return flatten(obj);
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    static flattenDeep(obj) {
        return flattenDeep(obj);
    }
    /**
     * @param {?} src
     * @param {?} format
     * @return {?}
     */
    static format(src, format) {
        return src;
    }
    /**
     * @param {?} o1
     * @param {?} o2
     * @return {?}
     */
    static jsonConcat(o1, o2) {
        for (const key in o2) {
            o1[key] = o2[key];
        }
        return o1;
    }
    /**
     * @param {?} obj
     * @param {?} key
     * @return {?}
     */
    static escape(obj, key) {
        const _a = key, deletedItem = obj[_a], rest = __rest(obj, [typeof _a === "symbol" ? _a : _a + ""]);
        return rest;
    }
    /**
     * @param {?} collection
     * @param {?} predicate
     * @return {?}
     */
    static filter(collection, predicate) {
        return filter(collection, predicate);
    }
    /**
     * @param {?} obj
     * @param {?} predicate
     * @return {?}
     */
    static where(obj, predicate) {
        if (Object.keys(predicate).every(key => obj && obj[key] === predicate[key])) {
            return obj;
        }
        else {
            return null;
        }
    }
    /**
     * @param {?} s
     * @return {?}
     */
    static capitalize(s) {
        if (s) {
            return s.charAt(0).toUpperCase() + s.slice(1);
        }
        else {
            return s;
        }
    }
    /**
     * @param {?} s
     * @param {?} vars
     * @return {?}
     */
    static templateStr(s, vars) {
        /** @type {?} */
        const compiled = template(s);
        return compiled(vars);
    }
    /**
     * @param {?} s
     * @return {?}
     */
    static isTemplateStr(s) {
        /** @type {?} */
        const isMatch = /.*\${.*}.*/.test(s) || /.*<%=(.*)%>.*/.test(s);
        return isMatch;
    }
    /**
     * @template T
     * @param {?} item
     * @param {?=} keyName
     * @return {?}
     */
    static getArray(item, keyName) {
        /** @type {?} */
        const items = [];
        if (item) {
            if (CommonsUtils.isArray(item)) {
                return (/** @type {?} */ (item));
            }
            else if (CommonsUtils.isJson(item)) {
                for (const key in item) {
                    if (key) {
                        /** @type {?} */
                        let c = item[key];
                        if (keyName) {
                            c = Object.assign({ [keyName]: key }, c);
                        }
                        items.push(c);
                    }
                }
            }
            else {
                items.push(item);
            }
        }
        return items;
    }
    /**
     * @param {?} obj
     * @param {...?} keys
     * @return {?}
     */
    static removeKeys(obj, ...keys) {
        /** @type {?} */
        let o = obj;
        while (keys.length > 0) {
            o = CommonsUtils.set(o, keys, undefined);
            CommonsUtils.unset(o, keys);
            keys.pop();
            /** @type {?} */
            const v = CommonsUtils.get(o, keys);
            if (!CommonsUtils.isEmpty(v)) {
                break;
            }
        }
        return o;
    }
    /**
     * @param {?} value
     * @param {?} from
     * @param {?} to
     * @return {?}
     */
    static extract(value, from$$1, to) {
        /** @type {?} */
        let target;
        if (value && (from$$1 !== to)) {
            if (to >= value.length) {
                target = to - value.length;
                while ((target--) + 1) {
                    value.push(undefined);
                }
            }
            value.splice(to, 0, value.splice(from$$1, 1)[0]);
        }
    }
    /**
     * @param {?} srcArray
     * @param {?} item
     * @param {?=} index
     * @return {?}
     */
    static addItem(srcArray, item, index) {
        /** @type {?} */
        let toAdd = item;
        if (!CommonsUtils.isArray(item)) {
            toAdd = [item];
        }
        if (index) {
            return [].concat(srcArray.slice(0, index), toAdd, srcArray.slice(index));
        }
        else {
            return [].concat(srcArray, toAdd);
        }
    }
    /**
     * @param {?} a
     * @param {?} index
     * @return {?}
     */
    static removeByIndex(a, index) {
        return [].concat(a.slice(0, index), a.slice(index + 1));
    }
    /**
     * @template T
     * @param {?} a
     * @param {?} index
     * @param {?} element
     * @return {?}
     */
    static replace(a, index, element) {
        return [].concat(a.slice(0, index), element, a.slice(index + 1));
    }
    /**
     * @template T
     * @param {?} a
     * @param {?} from
     * @param {?} to
     * @return {?}
     */
    static move(a, from$$1, to) {
        /** @type {?} */
        const element = a[from$$1];
        /** @type {?} */
        const forward = from$$1 < to;
        /** @type {?} */
        const head = a.slice(0, forward ? from$$1 : to);
        /** @type {?} */
        const mid = a.slice(forward ? from$$1 + 1 : to, forward ? to + 1 : from$$1);
        /** @type {?} */
        const tail = a.slice(forward ? to + 1 : from$$1 + 1);
        return forward ?
            [].concat(head, mid, element, tail) :
            [].concat(head, element, mid, tail);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    static restoreFn(value) {
        if ((typeof value === 'string') && value.toLocaleLowerCase().trim().indexOf('function') === 0) {
            return new Function('return ' + value.replace(/_this/g, 'this')
                .replace(/__assign/g, 'Object.assign'))();
        }
        else {
            return value;
        }
    }
    /**
     * 排除key为k，value为v 的数据项
     * @param {?} src
     * @param {?} k
     * @param {?} v
     * @return {?}
     */
    static exclude(src, k, v) {
        /** @type {?} */
        const result = Object.keys(src).reduce((acc, key) => (src[key][k] === v ? acc : Object.assign({}, acc, { [key]: src[key] })), {});
        return result;
    }
    /**
     * 替换src中的 {k,o} 元素 为 {k,v}
     * @param {?} src
     * @param {?} k
     * @param {?} o
     * @param {?} v
     * @return {?}
     */
    static replaceObj(src, k, o, v) {
        /** @type {?} */
        const index = find(src, { [k]: o });
        return [
            ...src.slice(0, index),
            Object.assign({}, src[index], { [k]: v }),
            ...src.slice(index + 1)
        ];
    }
    /**
     * 合并 {} 和 []
     * @param {?} src1
     * @param {?} src2
     * @param {?} k
     * @return {?}
     */
    static concat(src1, src2, k) {
        return Object.assign({}, src1, src2.reduce((acc, item) => (Object.assign({}, acc, { [item[k]]: item })), {}));
    }
    /**
     * @param {?} json
     * @return {?}
     */
    static restoreJsonFn(json) {
        /** @type {?} */
        let jsonStr;
        if (typeof json === 'string') {
            jsonStr = json;
        }
        else {
            jsonStr = CommonsUtils.stringify(json);
        }
        return JSON.parse(jsonStr, (key, value) => CommonsUtils.restoreFn(value));
    }
    /**
     * @param {?} json
     * @return {?}
     */
    static stringify(json) {
        /**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
        function replacer(key, value) {
            if (typeof value === 'function') {
                return value.toString();
            }
            else {
                return value;
            }
        }
        return JSON.stringify(json, replacer);
    }
    /**
     * @param {?} str
     * @return {?}
     */
    static hash(str) {
        /** @type {?} */
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            /** @type {?} */
            const character = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + character;
            hash = hash & hash; // Convert to 32bit integer
        }
        return hash;
    }
    /**
     * 根据options定义，转换src
     *  options:{
     *    src-key: tar-key | {key:tar-key,options:{}} | Function
     *  }
     * @param {?} src
     * @param {?} options
     * @return {?}
     */
    static adaptObject(src, options) {
        if (CommonsUtils.isArray(src)) {
            return CommonsUtils.adaptArray(src, options);
        }
        else {
            return CommonsUtils.adaptJson(src, options);
        }
    }
    /**
     * @param {?} src
     * @param {?} options
     * @return {?}
     */
    static adaptJson(src, options) {
        /** @type {?} */
        const result = {};
        Object.keys(options).forEach((key) => {
            /** @type {?} */
            const srcValue = CommonsUtils.get(src, key);
            if (srcValue) {
                if (CommonsUtils.isArray(srcValue)) {
                    /** @type {?} */
                    let tarKey = null;
                    if (CommonsUtils.isString(options[key])) {
                        tarKey = options[key];
                    }
                    else {
                        tarKey = options[key]['key'];
                    }
                    CommonsUtils.set(result, tarKey, CommonsUtils.adaptArray(srcValue, options[key]['options'] || options));
                }
                else if (CommonsUtils.isJson(srcValue)) {
                    CommonsUtils.set(result, options[key], CommonsUtils.adaptJson(srcValue, options[key]['options'] || {}));
                }
                else {
                    if (CommonsUtils.isString(options[key])) {
                        CommonsUtils.set(result, options[key], srcValue);
                    }
                    else if (CommonsUtils.isFunction(options[key])) {
                        CommonsUtils.set(result, options[key], options[key].apply(undefined, src, options));
                    }
                }
            }
        });
        return result;
    }
    /**
     * @param {?} src
     * @param {?} options
     * @return {?}
     */
    static adaptArray(src, options) {
        /** @type {?} */
        const result = [];
        src.forEach(item => {
            result.push(CommonsUtils.adaptObject(item, options));
        });
        return result;
    }
    /**
     * @param {?} dateString
     * @return {?}
     */
    static getAge(dateString) {
        /** @type {?} */
        const today = new Date();
        /** @type {?} */
        const birthDate = new Date(dateString);
        /** @type {?} */
        let age = today.getFullYear() - birthDate.getFullYear();
        /** @type {?} */
        const m = today.getMonth() - birthDate.getMonth();
        if (m < 0 || (m === 0 && today.getDate() < birthDate.getDate())) {
            age--;
        }
        return age;
    }
    /**
     * @param {?} target
     * @return {?}
     */
    static toDate(target) {
        if (target instanceof Date) {
            return target;
        }
        if (CommonsUtils.isString(target)) {
            /** @type {?} */
            const dateNumber = Date.parse(target);
            return !isNaN(dateNumber) ? new Date(dateNumber) : null;
        }
        return null;
    }
    /**
     * @param {?} tar
     * @param {?=} date
     * @return {?}
     */
    static isBefore(tar, date = new Date()) {
        /** @type {?} */
        const src = CommonsUtils.toDate(date);
        /** @type {?} */
        const original = CommonsUtils.toDate(tar);
        return !!(original && src && original < src);
    }
    /**
     * @param {?} tar
     * @param {?=} date
     * @return {?}
     */
    static isAfter(tar, date = new Date()) {
        /** @type {?} */
        const src = CommonsUtils.toDate(date);
        /** @type {?} */
        const original = CommonsUtils.toDate(tar);
        return !!(original && src && original > src);
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    static toString(obj) {
        switch (CommonsUtils.getVarType(obj)) {
            case VarType.NULL:
            case VarType.UNDEFINED:
                return '';
            case VarType.ARRAY: {
                /** @type {?} */
                const a = [];
                obj.forEach(o => a.push(CommonsUtils.toString(o)));
                return `[${a.join(',')}]`;
            }
            case VarType.JSON:
                return CommonsUtils.stringify(obj);
            default:
                return obj.toString();
        }
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    static isEmpty(obj) {
        switch (CommonsUtils.getVarType(obj)) {
            case VarType.NULL:
            case VarType.UNDEFINED:
                return true;
            case VarType.STRING:
                return obj.length === 0;
            case VarType.ARRAY:
                return ((/** @type {?} */ (obj))).length === 0;
            case VarType.JSON:
                return Object.keys(obj).length === 0;
            default:
                return obj.toString().length === 0;
        }
    }
    /**
     * @param {?} attributes
     * @param {?} keys
     * @return {?}
     */
    static convertToBoolean(attributes, keys) {
        /** @type {?} */
        const l_attributes = Object.assign({}, attributes);
        if (keys && keys.length > 0) {
            keys.forEach(key => {
                if (l_attributes.hasOwnProperty(key) && l_attributes[key] === '') {
                    l_attributes[key] = true;
                }
            });
        }
        return l_attributes;
    }
    /**
     * @param {?} path
     * @return {?}
     */
    static flatPath(path) {
        if (CommonsUtils.isArray(path)) {
            return ((/** @type {?} */ (path))).join('-').replace('.', '-');
        }
        return ((/** @type {?} */ (path))).replace('.', '-');
    }
    /**
     * @param {?} arr
     * @param {?=} seperator
     * @return {?}
     */
    static join(arr, seperator) {
        /** @type {?} */
        const joiner = seperator || ',';
        if (!arr) {
            return '';
        }
        if (!CommonsUtils.isArray(arr)) {
            return arr;
        }
        switch (arr.length) {
            case 0:
                return '';
            case 1:
                return arr[0];
            default:
                return arr.join(joiner);
        }
    }
    /**
     * @param {?} obj
     * @param {...?} predicates
     * @return {?}
     */
    static deepFind(obj, ...predicates) {
        /** @type {?} */
        const _find = (o) => {
            if (o instanceof Array) {
                ((/** @type {?} */ (o))).forEach(i => _find(i));
            }
            else {
                for (const prop in o) {
                    if (o[prop] instanceof Array) {
                        _find(o[prop]);
                    }
                }
                predicates.some((predicate) => {
                    /** @type {?} */
                    const found = CommonsUtils.where(o, predicate);
                    if (found !== null) {
                        foundResults.push(o);
                    }
                    return found !== null;
                });
            }
        };
        /** @type {?} */
        const foundResults = [];
        _find(obj);
        return foundResults;
    }
    /**
     * @param {?} milliseconds
     * @return {?}
     */
    static sleep(milliseconds) {
        /** @type {?} */
        const start = new Date().getTime();
        for (let i = 0; i < 1e7; i++) {
            if ((new Date().getTime() - start) > milliseconds) {
                break;
            }
        }
    }
    /**
     * @param {?} data
     * @return {?}
     */
    static getArrayValue(data) {
        if (!data) {
            return data;
        }
        if (CommonsUtils.isArray(data)) {
            return data;
        }
        else if (CommonsUtils.isString(data)) {
            return ((/** @type {?} */ (data))).split(',');
        }
        else {
            return [data];
        }
    }
    /**
     * @param {?} data
     * @return {?}
     */
    static getText(data) {
        if (CommonsUtils.isArray(data)) {
            return ((/** @type {?} */ (data))).map(v => CommonsUtils.getText(v)).join(',');
        }
        else if (CommonsUtils.isJson(data)) {
            return JSON.stringify(data);
        }
        else if (CommonsUtils.isBoolean(data)) {
            return data ? '是' : '否';
        }
        else {
            return data;
        }
    }
    /**
     * @param {?} exp
     * @param {...?} context
     * @return {?}
     */
    static getValue(exp, ...context) {
        /** @type {?} */
        const fn = exp && (exp['method'] || exp);
        if (CommonsUtils.isFunction(fn)) {
            return (/** @type {?} */ (fn.apply(undefined, context)));
        }
        if (CommonsUtils.isString(exp) && exp.startsWith('@')) {
            return CommonsUtils.get(context && context[0], exp.substr(1));
        }
        return exp;
    }
    /**
     * @param {?} obj
     * @param {?} prop
     * @param {?} defaultValue
     * @return {?}
     */
    static defineHiddenProp(obj, prop, defaultValue) {
        Object.defineProperty(obj, prop, { enumerable: false, writable: true, configurable: true });
        obj[prop] = defaultValue;
    }
    /**
     * @param {?} str
     * @param {?} size
     * @return {?}
     */
    static splitBySize(str, size) {
        /** @type {?} */
        const results = [];
        /** @type {?} */
        let i = size;
        while (i <= str.length) {
            results.push(str.substr(0, i));
            i += size;
        }
        return results;
    }
    /**
     * @param {?} url
     * @param {?=} params
     * @return {?}
     */
    static resolveUrl(url, params = {}) {
        /** @type {?} */
        const _url = Object.keys(params)
            .reduce((acc, key) => acc.replace(`:${key}`, params[key]), url);
        return _url;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RegUtils {
    /**
     * @param {?} regexStr
     * @return {?}
     */
    static escapeRegexp(regexStr) {
        /** @type {?} */
        const result = regexStr.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
        return result;
    }
    /**
     * @param {?} pattern
     * @return {?}
     */
    static getRegexps(pattern) {
        if (!pattern) {
            return [];
        }
        /** @type {?} */
        const exps = [];
        /** @type {?} */
        const patterns = [];
        if (CommonsUtils.isString(pattern)) {
            patterns.push(pattern);
        }
        for (const p of patterns) {
            if (p) {
                if (p.indexOf(',') > 0) {
                    exps.concat(RegUtils.getRegexps(p.split(',')));
                }
                else {
                    exps.push(RegUtils.getRegexp(p));
                }
            }
        }
        return exps;
    }
    /**
     * @param {?} src
     * @param {?} pattern
     * @return {?}
     */
    static test(src, pattern) {
        /** @type {?} */
        let regex;
        if (typeof pattern === 'string') {
            regex = new RegExp(pattern);
        }
        else {
            regex = pattern;
        }
        if (regex instanceof RegExp) {
            return regex.test(src);
        }
        else if (regex && Array.isArray(regex)) {
            return regex.every((item) => {
                return RegUtils.test(src, item);
            });
        }
        else if (regex && Array.isArray(regex.and)) {
            return regex.and.every((item) => {
                return RegUtils.test(src, item);
            });
        }
        else if (regex && Array.isArray(regex.or)) {
            return regex.or.some((item) => {
                return RegUtils.test(src, item);
            });
        }
        else if (regex && regex.not) {
            return !RegUtils.test(src, regex.not);
        }
        else {
            return false;
        }
    }
    /**
     * @param {?} string
     * @param {?} regex
     * @return {?}
     */
    static exec(string, regex) {
        /** @type {?} */
        const self = this;
        if (typeof regex === 'string') {
            regex = new RegExp(regex);
        }
        if (regex instanceof RegExp) {
            return regex.exec(string);
        }
        else if (regex && Array.isArray(regex)) {
            return regex.reduce(function (res, item) {
                return (!!res) ? res : self.exec(string, item);
            }, null);
        }
        else {
            return null;
        }
    }
    /**
     * @private
     * @param {?} pattern
     * @return {?}
     */
    static getRegexp(pattern) {
        /** @type {?} */
        let exp = null;
        if (!pattern) {
            return null;
        }
        if (CommonsUtils.isString(pattern)) {
            if (pattern === 'letter') {
                exp = RegPatterns.letter;
            }
            else if (pattern === 'digit') {
                exp = RegPatterns.digit;
            }
            else if (pattern === 'character') {
                exp = RegPatterns.character;
            }
            else if (pattern === 'integer') {
                exp = RegPatterns.integer;
            }
            else if (pattern === 'numeric') {
                exp = RegPatterns.numeric;
            }
            else {
                exp = new RegExp((/** @type {?} */ (pattern)));
            }
        }
        else {
            exp = (/** @type {?} */ (pattern));
        }
        return exp;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const bowser = require('bowser');
class BrowserOsUtils {
    /**
     * @return {?}
     */
    static isMobile() {
        /** @type {?} */
        const result = [
            Devices.DEVICES.ANDROID,
            Devices.DEVICES.IPHONE,
            Devices.DEVICES.I_POD,
            Devices.DEVICES.BLACKBERRY,
            Devices.DEVICES.FIREFOX_OS,
            Devices.DEVICES.WINDOWS_PHONE,
            Devices.DEVICES.VITA
        ].some((item) => {
            return BrowserOsUtils.device_info.device === item;
        });
        return result;
    }
    /**
     * @return {?}
     */
    static isTablet() {
        /** @type {?} */
        const result = [
            Devices.DEVICES.I_PAD,
            Devices.DEVICES.FIREFOX_OS
        ].some((item) => {
            return BrowserOsUtils.device_info.device === item;
        });
        return result;
    }
    /**
     * @return {?}
     */
    static isDesktop() {
        /** @type {?} */
        const result = [
            Devices.DEVICES.PS4,
            Devices.DEVICES.CHROME_BOOK,
            Devices.DEVICES.UNKNOWN
        ].some((item) => {
            return BrowserOsUtils.device_info.device === item;
        });
        return result;
    }
    /**
     * @return {?}
     */
    static getDeviceInfo() {
        if (BrowserOsUtils.device_info) {
            return BrowserOsUtils.device_info;
        }
        if (window && window.navigator) {
            BrowserOsUtils.ua = window.navigator.userAgent;
        }
        BrowserOsUtils.userAgent = BrowserOsUtils.ua;
        /** @type {?} */
        const mappings = [
            { const: 'OS', prop: 'os' },
            { const: 'BROWSERS', prop: 'browser' },
            { const: 'DEVICES', prop: 'device' },
            { const: 'OS_VERSIONS', prop: 'os_version' }
        ];
        mappings.forEach((mapping) => {
            BrowserOsUtils[mapping.prop] = Object.keys(Devices[mapping.const]).reduce((obj, item) => {
                obj[Devices[mapping.const][item]] = RegUtils.test(BrowserOsUtils.ua, Devices[`${mapping.const}_RE`][item]);
                return obj;
            }, {});
        });
        mappings.forEach((mapping) => {
            BrowserOsUtils[mapping.prop] = Object.keys(Devices[mapping.const])
                .map((key) => {
                return Devices[mapping.const][key];
            }).reduce((previousValue, currentValue) => {
                return (previousValue === Devices[mapping.const].UNKNOWN && BrowserOsUtils[mapping.prop][currentValue])
                    ? currentValue : previousValue;
            }, Devices[mapping.const].UNKNOWN);
        });
        BrowserOsUtils.browser_version = '0';
        if (BrowserOsUtils.browser !== Devices.BROWSERS.UNKNOWN) {
            /** @type {?} */
            const re = Devices.BROWSER_VERSIONS_RE[BrowserOsUtils.browser];
            /** @type {?} */
            const res = RegUtils.exec(BrowserOsUtils.ua, re);
            if (!!res) {
                BrowserOsUtils.browser_version = res[1];
            }
        }
        BrowserOsUtils.device_info = {
            userAgent: BrowserOsUtils.userAgent,
            os: BrowserOsUtils.os,
            browser: BrowserOsUtils.browser,
            device: BrowserOsUtils.device,
            os_version: BrowserOsUtils.os_version,
            browser_version: BrowserOsUtils.browser_version
        };
        return BrowserOsUtils.device_info;
    }
    /**
     * @return {?}
     */
    static checkBrowser() {
        if (BrowserOsUtils.isBrowserVersionValid()) {
            /** @type {?} */
            const features = BrowserOsUtils.isBrowserFeaturesValid();
            return {
                version: true,
                features
            };
        }
        return {
            version: false
        };
    }
    /**
     * @private
     * @return {?}
     */
    static isBrowserVersionValid() {
        /** @type {?} */
        const browser = bowser.getParser(window.navigator.userAgent);
        return browser.satisfies({
            windows: {
                'internet explorer': '>10'
            },
            macos: {
                safari: '>10.1'
            },
            chrome: '>20.1.1432',
            firefox: '>31',
            opera: '>22'
        });
    }
    /**
     * @private
     * @return {?}
     */
    static isBrowserFeaturesValid() {
        /** @type {?} */
        let supported = true;
        for (const feature in Modernizr) {
            if (Modernizr.hasOwnProperty(feature) &&
                typeof Modernizr[feature] === 'boolean' && Modernizr[feature] === false) {
                supported = false;
                break;
            }
        }
        return supported;
    }
}
BrowserOsUtils.ua = '';
BrowserOsUtils.userAgent = '';
BrowserOsUtils.os = '';
BrowserOsUtils.browser = '';
BrowserOsUtils.device = '';
BrowserOsUtils.os_version = '';
BrowserOsUtils.browser_version = '';
BrowserOsUtils.device_info = undefined;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let UI_COLORS_COUNT = -1;
class ColorUtils {
    /**
     * @return {?}
     */
    static getColorsCount() {
        if (UI_COLORS_COUNT === -1) {
            UI_COLORS_COUNT = Object.keys(UI_COLORS).length;
        }
        return UI_COLORS_COUNT;
    }
    /**
     * @param {?=} by
     * @param {?=} offset
     * @return {?}
     */
    static getColor(by, offset = 0) {
        /** @type {?} */
        let colorIndex;
        if (!by) {
            by = CommonsUtils.getRandomNumber(ColorUtils.getColorsCount());
        }
        if (CommonsUtils.isString(by)) {
            colorIndex = (((/** @type {?} */ (by))).charCodeAt(0) + ((/** @type {?} */ (by))).charCodeAt(((/** @type {?} */ (by))).length - 1) + ((/** @type {?} */ (by))).length + offset) % ColorUtils.getColorsCount();
        }
        else {
            colorIndex = by;
        }
        /** @type {?} */
        let matched = 'pink';
        Object.keys(UI_COLORS).some((color, index) => {
            if (index === colorIndex) {
                matched = UI_COLORS[color];
                return true;
            }
            else {
                return false;
            }
        });
        return matched;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DataItemUtils {
    /**
     * @param {?} items
     * @param {?} config
     * @return {?}
     */
    static transItems(items, config) {
        if (!config) {
            return items;
        }
        /** @type {?} */
        let _data = [];
        /** @type {?} */
        const groups = {};
        items.map((item) => {
            _data.push(DataItemUtils.transItem(item, config));
        });
        if (config.groupKey) {
            _data.map(item => {
                /** @type {?} */
                const group = DataItemUtils.getItemLabel(item, config.groupKey || 'group');
                if (!groups[group]) {
                    groups[group] = [];
                }
                groups[group].push(item);
            });
            _data = [];
            Object.keys(groups).forEach(group => {
                _data.push({
                    label: group,
                    items: groups[group]
                });
            });
        }
        return _data;
    }
    /**
     * @param {?} item
     * @param {?} config
     * @return {?}
     */
    static transItem(item, config) {
        /** @type {?} */
        const _item = {
            [DataItemUtils.ITEM_LABEL_KEY]: DataItemUtils.getItemLabel(item, config.labelKey || DataItemUtils.ITEM_LABEL_KEY),
            [DataItemUtils.ITEM_VALUE_KEY]: DataItemUtils.getItemValue(item, config.valueKey),
            [DataItemUtils.ITEM_DATA_KEY]: item
        };
        return _item;
    }
    /**
     * @param {?} item
     * @param {?} valueKey
     * @return {?}
     */
    static getItemValue(item, valueKey) {
        if (CommonsUtils.isString(item)) {
            return item;
        }
        if (CommonsUtils.isArray(item)) {
            return item.map(data => DataItemUtils.getItemValue(data, valueKey));
        }
        else {
            if (typeof valueKey === 'function') {
                return valueKey(item);
            }
            else if (CommonsUtils.isArray(valueKey)) {
                /** @type {?} */
                const value = {};
                valueKey.forEach(p => {
                    /** @type {?} */
                    const val = CommonsUtils.get(item, p);
                    if (val) {
                        value[p] = val;
                    }
                });
                return value;
            }
            return valueKey ? CommonsUtils.get(item, valueKey) : item;
        }
    }
    /**
     * @param {?} item
     * @param {?} label
     * @return {?}
     */
    static getItemLabel(item, label) {
        if (CommonsUtils.isFunction(label)) {
            return label(item);
        }
        else if (item) {
            if (CommonsUtils.isArray(label)) {
                /** @type {?} */
                const s = [];
                ((/** @type {?} */ (label))).forEach(key => {
                    /** @type {?} */
                    const lb = DataItemUtils.getLabel(item, key);
                    if (lb) {
                        s.push(lb);
                    }
                });
                return s;
            }
            else {
                return DataItemUtils.getLabel(item, label);
            }
        }
    }
    /**
     * @param {?} item
     * @param {?} labelKey
     * @return {?}
     */
    static getLabel(item, labelKey) {
        /** @type {?} */
        const aLabel = CommonsUtils.get(item, labelKey);
        if (aLabel) {
            return aLabel;
        }
        else if (item[DataItemUtils.ITEM_DATA_KEY]) {
            return CommonsUtils.get(item[DataItemUtils.ITEM_DATA_KEY], labelKey);
        }
        else {
            return item[Object.keys(item)[0]];
        }
    }
}
DataItemUtils.ITEM_LABEL_KEY = 'label';
DataItemUtils.ITEM_VALUE_KEY = 'value';
DataItemUtils.ITEM_GROUP_KEY = 'group';
DataItemUtils.ITEM_GROUP_ITEMS_KEY = 'items';
DataItemUtils.ITEM_DATA_KEY = 'data';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ChartUtils {
    /**
     * @param {?} rawData
     * @param {?} chartOptions
     * @param {?=} dimensionsIndex
     * @return {?}
     */
    static buildChartData(rawData, chartOptions, dimensionsIndex = 0) {
        /** @type {?} */
        const type = chartOptions.type;
        /** @type {?} */
        let data = rawData;
        /** @type {?} */
        const dimension = chartOptions.dimension || {};
        if (dimension.dataSrcPath) {
            data = CommonsUtils.get(rawData, dimension.dataSrcPath);
        }
        /** @type {?} */
        const dataItemProps = dimension.dataItemProps || chartOptions.dataItemProps;
        /** @type {?} */
        const label = dimension.title || '';
        switch (type || ChartType.BAR) {
            case ChartType.BAR:
                data = ChartUtils.buildBarChart(data, dataItemProps, label, dimensionsIndex);
                break;
            case ChartType.LINE:
                data = ChartUtils.buildLineChart(data, dataItemProps, label, dimensionsIndex);
                break;
            case ChartType.PIE:
                data = ChartUtils.buildPieChart(data, dataItemProps, label, dimensionsIndex);
                break;
            case ChartType.AREA:
                data = ChartUtils.buildAreaChart(data, dataItemProps, label, dimensionsIndex);
                break;
            case ChartType.RADAR:
                data = ChartUtils.buildRadarChart(data, dataItemProps, label, dimensionsIndex);
                break;
            case ChartType.DOUGHNUT:
                data = ChartUtils.buildPieChart(data, dataItemProps, label, dimensionsIndex);
                break;
        }
        return data;
    }
    /**
     * @param {?} dataItems
     * @param {?} config
     * @param {?=} label
     * @param {?=} colorIndex
     * @return {?}
     */
    static buildBarChart(dataItems, config, label = '', colorIndex = 0) {
        /** @type {?} */
        const _data = DataItemUtils.transItems(dataItems, config);
        /** @type {?} */
        const labels = [];
        /** @type {?} */
        const datasets = [];
        /** @type {?} */
        const data = [];
        /** @type {?} */
        const backgroundColor = [];
        /** @type {?} */
        const hoverBackgroundColor = [];
        /** @type {?} */
        const items = _data;
        items.forEach(item => {
            if (item['group']) {
                datasets.push({
                    label: items[''].label,
                    data: items[''].items,
                    backgroundColor: ColorUtils.getColor(items[''].label)
                });
                labels.push('');
            }
            else {
                /** @type {?} */
                const lb = item['key_as_string'] || item['label'];
                labels.push(lb);
                data.push(item['value']);
                backgroundColor.push(ColorUtils.getColor(lb, colorIndex));
                hoverBackgroundColor.push(ColorUtils.getColor(lb, colorIndex + 10));
            }
        });
        datasets.push({
            label: label,
            backgroundColor,
            hoverBackgroundColor,
            data
        });
        return {
            labels,
            datasets
        };
    }
    /**
     * @param {?} dataItems
     * @param {?} config
     * @param {?=} label
     * @param {?=} colorIndex
     * @return {?}
     */
    static buildPieChart(dataItems, config, label = '', colorIndex = 0) {
        /** @type {?} */
        const _data = DataItemUtils.transItems(dataItems, config);
        /** @type {?} */
        const labels = [];
        /** @type {?} */
        const datasets = [];
        /** @type {?} */
        const data = [];
        /** @type {?} */
        const backgroundColor = [];
        /** @type {?} */
        const hoverBackgroundColor = [];
        /** @type {?} */
        const items = _data;
        items.forEach(item => {
            if (item['group']) {
                datasets.push({
                    label: items[''].label,
                    data: items[''].items,
                    backgroundColor: ColorUtils.getColor(items[''].label)
                });
                labels.push('');
            }
            else {
                /** @type {?} */
                const lb = item['key_as_string'] || item['label'];
                labels.push(lb);
                data.push(item['value']);
                backgroundColor.push(ColorUtils.getColor(lb, colorIndex));
                hoverBackgroundColor.push(ColorUtils.getColor(lb, colorIndex + 10));
            }
        });
        datasets.push({
            label: label || '',
            backgroundColor,
            hoverBackgroundColor,
            data
        });
        return {
            labels,
            datasets
        };
    }
    /**
     * @param {?} dataItems
     * @param {?} config
     * @param {?=} label
     * @param {?=} colorIndex
     * @return {?}
     */
    static buildAreaChart(dataItems, config, label = '', colorIndex = 0) {
        /** @type {?} */
        const _data = DataItemUtils.transItems(dataItems, config);
        /** @type {?} */
        const labels = [];
        /** @type {?} */
        const datasets = [];
        /** @type {?} */
        const backgroundColor = [];
        /** @type {?} */
        const data = [];
        /** @type {?} */
        const items = _data;
        items.forEach(item => {
            if (item['group']) {
                datasets.push({
                    label: items[''].label,
                    data: items[''].items,
                    backgroundColor: ColorUtils.getColor(items[''].label)
                });
                labels.push('');
            }
            else {
                /** @type {?} */
                const lb = item['key_as_string'] || item['label'];
                labels.push(lb);
                data.push(item['value']);
                backgroundColor.push(ColorUtils.getColor(lb, colorIndex));
            }
        });
        datasets.push({
            label: label || '',
            data,
            backgroundColor
        });
        return {
            labels,
            datasets
        };
    }
    /**
     * @param {?} dataItems
     * @param {?} config
     * @param {?=} label
     * @param {?=} colorIndex
     * @return {?}
     */
    static buildLineChart(dataItems, config, label = '', colorIndex = 0) {
        /** @type {?} */
        const _data = DataItemUtils.transItems(dataItems, config);
        /** @type {?} */
        const labels = [];
        /** @type {?} */
        const datasets = [];
        /** @type {?} */
        const data = [];
        /** @type {?} */
        const items = _data;
        items.forEach(item => {
            if (item['group']) {
                datasets.push({
                    label: items[''].label,
                    data: items[''].items,
                    backgroundColor: ColorUtils.getColor(items[''].label)
                });
                labels.push('');
            }
            else {
                /** @type {?} */
                const lb = item['key_as_string'] || item['label'];
                labels.push(lb);
                data.push(item['value']);
            }
        });
        datasets.push({
            label: label || '',
            data,
            fill: false,
            borderColor: ColorUtils.getColor(colorIndex)
        });
        return {
            labels,
            datasets
        };
    }
    /**
     * @param {?} dataItems
     * @param {?} config
     * @param {?=} label
     * @param {?=} colorIndex
     * @return {?}
     */
    static buildRadarChart(dataItems, config, label = '', colorIndex = 0) {
        /** @type {?} */
        const _data = DataItemUtils.transItems(dataItems, config);
        /** @type {?} */
        const labels = [];
        /** @type {?} */
        const datasets = [];
        /** @type {?} */
        const backgroundColor = [];
        /** @type {?} */
        const borderColor = [];
        /** @type {?} */
        const pointBackgroundColor = [];
        /** @type {?} */
        const pointHoverBorderColor = [];
        /** @type {?} */
        const data = [];
        /** @type {?} */
        const items = _data;
        items.forEach(item => {
            if (item['group']) {
                datasets.push({
                    label: items[''].label,
                    data: items[''].items,
                    backgroundColor: ColorUtils.getColor(items[''].label)
                });
                labels.push('');
            }
            else {
                /** @type {?} */
                const lb = item['key_as_string'] || item['label'];
                labels.push(lb);
                data.push(item['value']);
                backgroundColor.push(ColorUtils.getColor(lb, colorIndex));
                borderColor.push(ColorUtils.getColor(lb, colorIndex + 5));
                pointBackgroundColor.push(ColorUtils.getColor(lb, colorIndex + 5));
                pointHoverBorderColor.push(ColorUtils.getColor(lb, colorIndex + 5));
            }
        });
        datasets.push({
            label: label || '',
            data,
            backgroundColor,
            borderColor,
            pointBackgroundColor,
            pointHoverBorderColor,
            pointBorderColor: '#fff',
            pointHoverBackgroundColor: '#fff'
        });
        return {
            labels,
            datasets
        };
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CopierUtils {
    /**
     * Copy the text value to the clipboard.
     * @param {?} text
     * @return {?}
     */
    copyText(text) {
        this.createTextareaAndSelect(text);
        /** @type {?} */
        const copySuccessful = document.execCommand('copy');
        this.removeFake();
        return copySuccessful;
    }
    /**
     * Creates a hidden textarea element, sets its value from `text` property,
     * and makes a selection on it.
     * @private
     * @param {?} text
     * @return {?}
     */
    createTextareaAndSelect(text) {
        // Create a fake element to hold the contents to copy
        this.textarea = document.createElement('textarea');
        // Prevent zooming on iOS
        this.textarea.style.fontSize = '12pt';
        // Hide the element
        this.textarea.style.setProperty('display', 'none');
        // Move element to the same position vertically
        /** @type {?} */
        const yPosition = window.pageYOffset || document.documentElement.scrollTop;
        this.textarea.style.top = yPosition + 'px';
        this.textarea.setAttribute('readonly', '');
        this.textarea.value = text;
        document.body.appendChild(this.textarea);
        this.textarea.select();
        this.textarea.setSelectionRange(0, this.textarea.value.length);
    }
    /**
     * Remove the text area from the DOM.
     * @private
     * @return {?}
     */
    removeFake() {
        if (this.textarea) {
            document.body.removeChild(this.textarea);
            this.textarea = null;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DevicesUtils {
    /**
     * @return {?}
     */
    static getMediaDevices() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
            console.error('Can\'t enumerate devices, method not supported.');
        }
        return from(navigator.mediaDevices.enumerateDevices())
            .pipe(map$1((devices) => {
            /** @type {?} */
            const mediaDevices = [];
            for (const deviceI of devices) {
                console.log(deviceI);
                /** @type {?} */
                const device = {};
                for (const key in deviceI) {
                    if (key) {
                        device[key] = deviceI[key];
                    }
                }
                if (!device.deviceId) {
                    device.deviceId = ((/** @type {?} */ (device))).id;
                }
                if (!device.label) {
                    device.label = 'device (no-permission)';
                }
                mediaDevices.push(device);
            }
            return mediaDevices;
        }));
    }
    /**
     * @return {?}
     */
    static getVideoDevices() {
        /** @type {?} */
        const videos = DevicesUtils.getMediaDevices().pipe(map$1(devices => devices.filter(device => device.kind === 'videoinput')));
        return videos;
    }
    /**
     * @return {?}
     */
    static getAudioDevices() {
        /** @type {?} */
        const audios = DevicesUtils.getMediaDevices().pipe(map$1(devices => devices.filter(device => device.kind === 'audioinput')));
        return audios;
    }
    /**
     * @return {?}
     */
    static playBeepSound() {
        /** @type {?} */
        const snd = new Audio('data:audio/wav;base64,//uQRAAAAWMSLwUIYAAsYkXgoQwAEaYLWfkWgAI0wWs/ItAAAGDgYtAgAyN+QWaAAihwMWm4G8QQRDiMcCBcH3Cc+CDv/7xA4Tvh9Rz/y8QADBwMWgQAZG/ILNAARQ4GLTcDeIIIhxGOBAuD7hOfBB3/94gcJ3w+o5/5eIAIAAAVwWgQAVQ2ORaIQwEMAJiDg95G4nQL7mQVWI6GwRcfsZAcsKkJvxgxEjzFUgfHoSQ9Qq7KNwqHwuB13MA4a1q/DmBrHgPcmjiGoh//EwC5nGPEmS4RcfkVKOhJf+WOgoxJclFz3kgn//dBA+ya1GhurNn8zb//9NNutNuhz31f////9vt///z+IdAEAAAK4LQIAKobHItEIYCGAExBwe8jcToF9zIKrEdDYIuP2MgOWFSE34wYiR5iqQPj0JIeoVdlG4VD4XA67mAcNa1fhzA1jwHuTRxDUQ//iYBczjHiTJcIuPyKlHQkv/LHQUYkuSi57yQT//uggfZNajQ3Vmz+Zt//+mm3Wm3Q576v////+32///5/EOgAAADVghQAAAAA//uQZAUAB1WI0PZugAAAAAoQwAAAEk3nRd2qAAAAACiDgAAAAAAABCqEEQRLCgwpBGMlJkIz8jKhGvj4k6jzRnqasNKIeoh5gI7BJaC1A1AoNBjJgbyApVS4IDlZgDU5WUAxEKDNmmALHzZp0Fkz1FMTmGFl1FMEyodIavcCAUHDWrKAIA4aa2oCgILEBupZgHvAhEBcZ6joQBxS76AgccrFlczBvKLC0QI2cBoCFvfTDAo7eoOQInqDPBtvrDEZBNYN5xwNwxQRfw8ZQ5wQVLvO8OYU+mHvFLlDh05Mdg7BT6YrRPpCBznMB2r//xKJjyyOh+cImr2/4doscwD6neZjuZR4AgAABYAAAABy1xcdQtxYBYYZdifkUDgzzXaXn98Z0oi9ILU5mBjFANmRwlVJ3/6jYDAmxaiDG3/6xjQQCCKkRb/6kg/wW+kSJ5//rLobkLSiKmqP/0ikJuDaSaSf/6JiLYLEYnW/+kXg1WRVJL/9EmQ1YZIsv/6Qzwy5qk7/+tEU0nkls3/zIUMPKNX/6yZLf+kFgAfgGyLFAUwY//uQZAUABcd5UiNPVXAAAApAAAAAE0VZQKw9ISAAACgAAAAAVQIygIElVrFkBS+Jhi+EAuu+lKAkYUEIsmEAEoMeDmCETMvfSHTGkF5RWH7kz/ESHWPAq/kcCRhqBtMdokPdM7vil7RG98A2sc7zO6ZvTdM7pmOUAZTnJW+NXxqmd41dqJ6mLTXxrPpnV8avaIf5SvL7pndPvPpndJR9Kuu8fePvuiuhorgWjp7Mf/PRjxcFCPDkW31srioCExivv9lcwKEaHsf/7ow2Fl1T/9RkXgEhYElAoCLFtMArxwivDJJ+bR1HTKJdlEoTELCIqgEwVGSQ+hIm0NbK8WXcTEI0UPoa2NbG4y2K00JEWbZavJXkYaqo9CRHS55FcZTjKEk3NKoCYUnSQ0rWxrZbFKbKIhOKPZe1cJKzZSaQrIyULHDZmV5K4xySsDRKWOruanGtjLJXFEmwaIbDLX0hIPBUQPVFVkQkDoUNfSoDgQGKPekoxeGzA4DUvnn4bxzcZrtJyipKfPNy5w+9lnXwgqsiyHNeSVpemw4bWb9psYeq//uQZBoABQt4yMVxYAIAAAkQoAAAHvYpL5m6AAgAACXDAAAAD59jblTirQe9upFsmZbpMudy7Lz1X1DYsxOOSWpfPqNX2WqktK0DMvuGwlbNj44TleLPQ+Gsfb+GOWOKJoIrWb3cIMeeON6lz2umTqMXV8Mj30yWPpjoSa9ujK8SyeJP5y5mOW1D6hvLepeveEAEDo0mgCRClOEgANv3B9a6fikgUSu/DmAMATrGx7nng5p5iimPNZsfQLYB2sDLIkzRKZOHGAaUyDcpFBSLG9MCQALgAIgQs2YunOszLSAyQYPVC2YdGGeHD2dTdJk1pAHGAWDjnkcLKFymS3RQZTInzySoBwMG0QueC3gMsCEYxUqlrcxK6k1LQQcsmyYeQPdC2YfuGPASCBkcVMQQqpVJshui1tkXQJQV0OXGAZMXSOEEBRirXbVRQW7ugq7IM7rPWSZyDlM3IuNEkxzCOJ0ny2ThNkyRai1b6ev//3dzNGzNb//4uAvHT5sURcZCFcuKLhOFs8mLAAEAt4UWAAIABAAAAAB4qbHo0tIjVkUU//uQZAwABfSFz3ZqQAAAAAngwAAAE1HjMp2qAAAAACZDgAAAD5UkTE1UgZEUExqYynN1qZvqIOREEFmBcJQkwdxiFtw0qEOkGYfRDifBui9MQg4QAHAqWtAWHoCxu1Yf4VfWLPIM2mHDFsbQEVGwyqQoQcwnfHeIkNt9YnkiaS1oizycqJrx4KOQjahZxWbcZgztj2c49nKmkId44S71j0c8eV9yDK6uPRzx5X18eDvjvQ6yKo9ZSS6l//8elePK/Lf//IInrOF/FvDoADYAGBMGb7FtErm5MXMlmPAJQVgWta7Zx2go+8xJ0UiCb8LHHdftWyLJE0QIAIsI+UbXu67dZMjmgDGCGl1H+vpF4NSDckSIkk7Vd+sxEhBQMRU8j/12UIRhzSaUdQ+rQU5kGeFxm+hb1oh6pWWmv3uvmReDl0UnvtapVaIzo1jZbf/pD6ElLqSX+rUmOQNpJFa/r+sa4e/pBlAABoAAAAA3CUgShLdGIxsY7AUABPRrgCABdDuQ5GC7DqPQCgbbJUAoRSUj+NIEig0YfyWUho1VBBBA//uQZB4ABZx5zfMakeAAAAmwAAAAF5F3P0w9GtAAACfAAAAAwLhMDmAYWMgVEG1U0FIGCBgXBXAtfMH10000EEEEEECUBYln03TTTdNBDZopopYvrTTdNa325mImNg3TTPV9q3pmY0xoO6bv3r00y+IDGid/9aaaZTGMuj9mpu9Mpio1dXrr5HERTZSmqU36A3CumzN/9Robv/Xx4v9ijkSRSNLQhAWumap82WRSBUqXStV/YcS+XVLnSS+WLDroqArFkMEsAS+eWmrUzrO0oEmE40RlMZ5+ODIkAyKAGUwZ3mVKmcamcJnMW26MRPgUw6j+LkhyHGVGYjSUUKNpuJUQoOIAyDvEyG8S5yfK6dhZc0Tx1KI/gviKL6qvvFs1+bWtaz58uUNnryq6kt5RzOCkPWlVqVX2a/EEBUdU1KrXLf40GoiiFXK///qpoiDXrOgqDR38JB0bw7SoL+ZB9o1RCkQjQ2CBYZKd/+VJxZRRZlqSkKiws0WFxUyCwsKiMy7hUVFhIaCrNQsKkTIsLivwKKigsj8XYlwt/WKi2N4d//uQRCSAAjURNIHpMZBGYiaQPSYyAAABLAAAAAAAACWAAAAApUF/Mg+0aohSIRobBAsMlO//Kk4soosy1JSFRYWaLC4qZBYWFRGZdwqKiwkNBVmoWFSJkWFxX4FFRQWR+LsS4W/rFRb/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////VEFHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAU291bmRib3kuZGUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMjAwNGh0dHA6Ly93d3cuc291bmRib3kuZGUAAAAAAAAAACU=');
        snd.play();
    }
    /**
     * @param {?} constrains
     * @param {?} deviceId
     * @return {?}
     */
    static getMediaStream(constrains, deviceId) {
        if (!navigator.mediaDevices) {
            throwError('Can\'t get user media, this is not supported.');
        }
        /** @type {?} */
        const video = deviceId === undefined
            ? { facingMode: { exact: 'environment' } }
            : { deviceId: { exact: deviceId } };
        constrains.video = video;
        return from(navigator.mediaDevices.getUserMedia(constrains))
            .pipe(map$1((stream) => stream), catchError(err => throwError(err)));
    }
    /**
     * @param {?} mediaStream
     * @return {?}
     */
    static stopMedia(mediaStream) {
        if (mediaStream && mediaStream.getTracks) {
            mediaStream.getTracks()
                .forEach((track) => track.stop());
        }
    }
    /**
     * @param {?} videoEle
     * @param {?} canvasEle
     * @return {?}
     */
    static takeImage(videoEle, canvasEle) {
        /** @type {?} */
        const dimensions = {};
        if (videoEle.videoWidth) {
            dimensions['width'] = videoEle.videoWidth;
            dimensions['height'] = videoEle.videoHeight;
        }
        canvasEle.width = dimensions['width'];
        canvasEle.height = dimensions['height'];
        canvasEle.getContext('2d').drawImage(videoEle, 0, 0);
        /** @type {?} */
        const mimeType = 'image/jpeg';
        /** @type {?} */
        const dataUrl = canvasEle.toDataURL(mimeType);
        return of({ dataUrl, mimeType });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const APP_STORE = new BehaviorSubject({});
class StatesUtils {
    /**
     * @return {?}
     */
    static getStore() {
        return APP_STORE;
    }
    /**
     * @param {?} path
     * @param {?=} value
     * @param {?=} preserved
     * @return {?}
     */
    static create(path, value, preserved) {
        /** @type {?} */
        const storeItem = StatesUtils.getStoreItem(path, true);
        storeItem.state.next(value);
        if (preserved) {
            storeItem.preserved = preserved;
        }
        return storeItem.state;
    }
    /**
     * @param {?} path
     * @param {?=} createWhenAbsent
     * @return {?}
     */
    static get(path, createWhenAbsent) {
        /** @type {?} */
        const storeItem = StatesUtils.getStoreItem(path, createWhenAbsent);
        if (storeItem) {
            return storeItem.state;
        }
        else {
            return undefined;
        }
    }
    /**
     * @param {...?} path
     * @return {?}
     */
    static observe(...path) {
        return StatesUtils.get(path, true);
    }
    /**
     * @param {...?} path
     * @return {?}
     */
    static toggle(...path) {
        /** @type {?} */
        const state = StatesUtils.get(path);
        state.next(!!!state.value);
        return state;
    }
    /**
     * @param {?} path
     * @return {?}
     */
    static inc(path) {
        /** @type {?} */
        const state = StatesUtils.get(path, true);
        /** @type {?} */
        let newValue = 0;
        if (state.value) {
            newValue = state.value + 1;
        }
        state.next(newValue);
        return state;
    }
    /**
     * @param {?} path
     * @return {?}
     */
    static dec(path) {
        /** @type {?} */
        const state = StatesUtils.get(path, true);
        /** @type {?} */
        let newValue = 0;
        if (state.value) {
            newValue = state.value - 1;
        }
        state.next(newValue);
        return state;
    }
    /**
     * @param {?} path
     * @param {?} offset
     * @return {?}
     */
    static add(path, offset) {
        /** @type {?} */
        const state = StatesUtils.get(path, true);
        /** @type {?} */
        let newValue = 0;
        if (state.value) {
            newValue = state.value + offset;
        }
        state.next(newValue);
        return state;
    }
    /**
     * used to clear some state properties
     * @param {?} path
     * @param {?} final
     * @return {?}
     */
    static set(path, final) {
        /** @type {?} */
        const state = StatesUtils.get(path, true);
        if (!state.value) {
            return StatesUtils.create(path, final);
        }
        else {
            state.next(final);
            return state;
        }
    }
    /**
     * @param {?} path
     * @param {?} key
     * @return {?}
     */
    static delete(path, key) {
        /** @type {?} */
        const state = StatesUtils.get(path);
        if (state.value) {
            state.next(CommonsUtils.unset(state.value, key));
        }
    }
    /**
     * used to update state properties when patch has no undefined values
     * @param {?} path
     * @param {?} patch
     * @return {?}
     */
    static update(path, patch) {
        /** @type {?} */
        const state = StatesUtils.get(path, true);
        if (!state.value) {
            return StatesUtils.create(path, patch);
        }
        else {
            state.next(CommonsUtils.merge({}, state.value, patch));
            return state;
        }
    }
    /**
     * @param {...?} path
     * @return {?}
     */
    static getValue(...path) {
        /** @type {?} */
        const state = StatesUtils.get(path);
        return state ? Object.assign({}, state.value) : undefined;
    }
    /**
     * @param {...?} path
     * @return {?}
     */
    static deleteState(...path) {
        /** @type {?} */
        const state = StatesUtils.get(path);
        CommonsUtils.unset(APP_STORE.value, CommonsUtils.flatPath(path));
        if (state) {
            state.next(undefined);
            state.complete();
        }
        APP_STORE.next(APP_STORE.value);
    }
    /**
     * @private
     * @param {?} path
     * @param {?=} createWhenAbsent
     * @return {?}
     */
    static getStoreItem(path, createWhenAbsent) {
        /** @type {?} */
        const key = CommonsUtils.flatPath(path);
        /** @type {?} */
        let storeItem = CommonsUtils.get(APP_STORE.value, key);
        if (!storeItem && createWhenAbsent) {
            storeItem = {
                state: new BehaviorSubject(undefined),
                createdAt: new Date().getMilliseconds()
            };
            /** @type {?} */
            const value = CommonsUtils.set(APP_STORE.value, key, storeItem);
            APP_STORE.next(value);
        }
        return storeItem;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const moment = momentNs;
class DateUtils {
    /**
     * @param {?} data
     * @return {?}
     */
    static getMoment(data) {
        if (moment.isMoment(data)) {
            return data;
        }
        /** @type {?} */
        const date = DateUtils.toDate(data);
        if (date) {
            return moment(data);
        }
        return null;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    static isDate(v) {
        return !!DateUtils.toDate(v);
    }
    /**
     * @param {?} v
     * @return {?}
     */
    static toDate(v) {
        if (CommonsUtils.isString(v)) {
            /** @type {?} */
            const date = Date.parse(v);
            if (!isNaN(date)) {
                return new Date(date);
            }
        }
        else {
            if (v && typeof v.getMonth === 'function') {
                return v;
            }
        }
        return undefined;
    }
    /**
     * @param {?=} date
     * @param {?=} format
     * @return {?}
     */
    static getFormattedDate(date, format = 'YYYY-MM-DD') {
        return DateUtils.getFormattedDateTime(format, date);
    }
    /**
     * @param {?=} date
     * @param {?=} format
     * @return {?}
     */
    static getFormattedTime(date, format = 'HH:mm:ss') {
        return DateUtils.getFormattedDateTime(format, date);
    }
    /**
     * @param {?=} format
     * @param {?=} date
     * @return {?}
     */
    static getFormattedDateTime(format = 'YYYY-MM-DD HH:mm:ss', date) {
        if (!date) {
            date = DateUtils.getDate();
        }
        else {
            date = DateUtils.toDate(date);
        }
        /** @type {?} */
        const momentData = DateUtils.getMoment(date);
        if (momentData) {
            return momentData.format(format);
        }
        return '';
    }
    /**
     * @return {?}
     */
    static getDate() {
        /** @type {?} */
        let date;
        /** @type {?} */
        const dateState = StatesUtils.getValue(StateNames.serverTime);
        if (dateState) {
            date = dateState.date;
        }
        else {
            date = new Date();
        }
        return date;
    }
    /**
     * @return {?}
     */
    static getStamp() {
        return DateUtils.getDate().getTime();
    }
    /**
     * @param {?} present
     * @param {?=} due
     * @return {?}
     */
    static getDateByNow(present, due) {
        if (!present) {
            return { seconds: 0, message: '' };
        }
        if (!DateUtils.isDate(present)) {
            try {
                present = new Date(present);
            }
            catch (e) {
                present = null;
            }
        }
        if (!present) {
            return { seconds: 0, message: '' };
        }
        /** @type {?} */
        let _due = due;
        if (!_due) {
            _due = new Date();
        }
        if (!DateUtils.isDate(_due)) {
            _due = new Date(_due);
        }
        /** @type {?} */
        const seconds = Math.round(Math.abs((_due.getTime() - present.getTime()) / 1000));
        /** @type {?} */
        const minutes = Math.round(Math.abs(seconds / 60));
        /** @type {?} */
        const hours = Math.round(Math.abs(minutes / 60));
        /** @type {?} */
        const days = Math.round(Math.abs(hours / 24));
        /** @type {?} */
        const months = Math.round(Math.abs(days / 30.416));
        /** @type {?} */
        const years = Math.round(Math.abs(days / 365));
        /** @type {?} */
        let message = '';
        if (seconds <= 10) {
            message = (_due > present) ? '刚刚' : '马上';
        }
        else if (seconds <= 30) {
            message = '30秒';
        }
        else if (seconds <= 90) {
            message = '1分钟';
        }
        else if (minutes <= 45) {
            message = minutes + '分钟';
        }
        else if (minutes <= 90) {
            message = '1小时';
        }
        else if (hours <= 22) {
            message = hours + '小时';
        }
        else if (hours <= 36) {
            message = '1天';
        }
        else if (days <= 25) {
            message = days + '天';
        }
        else if (days <= 45) {
            message = '1个月';
        }
        else if (days <= 345) {
            message = months + '月';
        }
        else if (days <= 545) {
            message = '1年';
        }
        else { // (days > 545)
            message = years + '年';
        }
        if (seconds > 10) {
            message += (_due > present) ? '前' : '后';
        }
        return {
            seconds,
            message
        };
    }
    /**
     * @param {?} seconds
     * @return {?}
     */
    static getUpdateSeconds(seconds) {
        /** @type {?} */
        const min = 60;
        /** @type {?} */
        const hr = min * 60;
        /** @type {?} */
        const day = hr * 24;
        if (seconds < min) { // less than 1 min, update every 2 secs
            return 2;
        }
        else if (seconds < hr) { // less than an hour, update every 30 secs
            return 30;
        }
        else if (seconds < day) { // less then a day, update every 5 mins
            return 300;
        }
        else { // update every hour
            return 3600;
        }
    }
    /**
     * @param {?=} date
     * @return {?}
     */
    static getYear(date) {
        return (date || DateUtils.getDate()).getFullYear();
    }
    /**
     * @param {?=} date
     * @return {?}
     */
    static getMonth(date) {
        return (date || DateUtils.getDate()).getMonth() + 1;
    }
    /**
     * @param {?=} date
     * @return {?}
     */
    static getDay(date) {
        return (date || DateUtils.getDate()).getDate();
    }
    /**
     * @return {?}
     */
    static getYesterday() {
        return DateUtils.getDay(new Date(DateUtils.getDate().getTime() - 24 * 60 * 60 * 1000));
    }
    /**
     * @return {?}
     */
    static getTomorrow() {
        return DateUtils.getDay(new Date(DateUtils.getDate().getTime() + 24 * 60 * 60 * 1000));
    }
    /**
     * @return {?}
     */
    static getLastMonth() {
        /** @type {?} */
        const month = DateUtils.getMonth() - 1;
        return month < 1 ? 12 : month;
    }
    /**
     * @return {?}
     */
    static getNextMonth() {
        /** @type {?} */
        const month = DateUtils.getMonth() + 1;
        return month > 12 ? 1 : month;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DataEntityUtils {
    /**
     * @param {?} entity
     * @param {?} data
     * @param {...?} keys
     * @return {?}
     */
    static getEntityData(entity, data, ...keys) {
        /** @type {?} */
        const keysData = {};
        if (keys && keys.length > 0) {
            keys.forEach(key => {
                keysData[entity.fields[key].label || key] = data[key];
            });
        }
        else {
            Object.keys(data).filter(key => ['_index', '_type', 'id'].indexOf(key) === -1)
                .forEach(key => {
                keysData[entity.fields[key] && entity.fields[key].label || key] = data[key];
            });
        }
        return keysData;
    }
    /**
     * @param {?} entity
     * @return {?}
     */
    static getDataEntityDefaultFieldName(entity) {
        if (entity.defaultField) {
            return entity.fields[entity.defaultField] && entity.fields[entity.defaultField].key;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ObjectUtils {
    /**
     * @template T
     * @param {?} target
     * @param {?} value
     * @return {?}
     */
    static patch(target, value) {
        /** @type {?} */
        let hasChanged = false;
        for (const key in value) {
            if (!Object.prototype.hasOwnProperty.call(value, key))
                continue;
            if (value[key] !== ((/** @type {?} */ (target)))[key]) {
                hasChanged = true;
                break;
            }
        }
        return !hasChanged ? target : Object.assign({}, target, value);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template V
 * @return {?}
 */
function createDict() {
    return Object.create(null);
}
/**
 * @template V
 * @param {?} dict
 * @return {?}
 */
function copyDict(dict) {
    return Object.assign(createDict(), dict);
}
/**
 * @param {?} dict
 * @param {?} key
 * @return {?}
 */
function hasKey(dict, key) {
    return Object.prototype.hasOwnProperty.call(dict, key.toString());
}
/**
 * @template T, R
 * @param {?} dict
 * @param {?} map
 * @return {?}
 */
function mapValues(dict, map$$1) {
    /** @type {?} */
    const ret = createDict();
    /** @type {?} */
    let changed = false;
    for (const key of Object.keys(dict)) {
        ret[key] = map$$1(dict[key]);
        if ((/** @type {?} */ (ret[key])) !== dict[key]) {
            changed = true;
        }
    }
    return changed ? ret : (/** @type {?} */ (dict));
}
/**
 * @template V
 * @param {?} target
 * @param {?} source
 * @return {?}
 */
function union$1(target, source) {
    return ObjectUtils.patch(target, source);
}
/**
 * @template V
 * @param {?} dict
 * @param {?} key
 * @param {?} value
 * @return {?}
 */
function setKey(dict, key, value) {
    if (dict[key] === value) {
        return dict;
    }
    /** @type {?} */
    const ret = copyDict(dict);
    ret[key] = value;
    return ret;
}
/**
 * @template V
 * @param {?} dict
 * @param {...?} keys
 * @return {?}
 */
function removeKey(dict, ...keys) {
    /** @type {?} */
    const ret = copyDict(dict);
    /** @type {?} */
    let changed = false;
    for (const key of keys) {
        if (hasKey(ret, key.toString())) {
            changed = true;
            delete ret[key];
        }
    }
    return changed ? ret : dict;
}
/**
 * @template V
 * @param {?} keys
 * @param {?} values
 * @return {?}
 */
function fromKeys(keys, values) {
    /** @type {?} */
    const ret = createDict();
    /** @type {?} */
    const isFunction = typeof values === 'function';
    for (const key of keys) {
        ret[key] = isFunction ? ((/** @type {?} */ (values)))(key) : values;
    }
    return ret;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FileUtils {
    /**
     * @param {?} file
     * @param {?=} readAs
     * @return {?}
     */
    static readFile(file, readAs) {
        /** @type {?} */
        const reader = new FileReader();
        /** @type {?} */
        const fileReader$ = fromEvent(reader, 'load').pipe(map$1((e) => e.target.result), first());
        switch (readAs || ReadAs.BINARY) {
            case ReadAs.ARRAY:
                reader.readAsArrayBuffer(file);
                break;
            case ReadAs.BINARY:
                reader.readAsBinaryString(file);
                break;
            case ReadAs.URL:
                reader.readAsDataURL(file);
                break;
            case ReadAs.TEXT:
                reader.readAsText(file);
                break;
        }
        return fileReader$;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IdCardUtils {
    /**
     * @param {?} idCardNo
     * @return {?}
     */
    static test(idCardNo) {
        /** @type {?} */
        const format = /^(([1][1-5])|([2][1-3])|([3][1-7])|([4][1-6])|([5][0-4])|([6][1-5])|([7][1])|([8][1-2]))\d{4}(([1][9]\d{2})|([2]\d{3}))(([0][1-9])|([1][0-2]))(([0][1-9])|([1-2][0-9])|([3][0-1]))\d{3}[0-9xX]$/;
        if (!format.test(idCardNo)) {
            return { status: false, 'msg': '身份证号码不合规' };
        }
        /** @type {?} */
        const year = idCardNo.substr(6, 4);
        /** @type {?} */
        const month = idCardNo.substr(10, 2);
        /** @type {?} */
        const date = idCardNo.substr(12, 2);
        /** @type {?} */
        const time = Date.parse(month + '-' + date + '-' + year);
        /** @type {?} */
        const now_time = Date.parse(DateUtils.getDate());
        /** @type {?} */
        const dates = (new Date(year, month, 0)).getDate();
        if (time > now_time || date > dates) {
            return { status: false, msg: '出生日期不合规' };
        }
        /** @type {?} */
        const c = new Array(7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2);
        /** @type {?} */
        const b = new Array('1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2');
        /** @type {?} */
        const id_array = idCardNo.split('');
        /** @type {?} */
        let sum = 0;
        for (let k = 0; k < 17; k++) {
            sum += parseInt(id_array[k]) * c[k];
        }
        if (id_array[17].toUpperCase() !== b[sum % 11].toUpperCase()) {
            return { status: false, msg: '身份证校验码不合规' };
        }
        return { status: true };
    }
    /**
     * @param {?} idCardNo
     * @return {?}
     */
    static parse(idCardNo) {
        if (!IdCardUtils.test(idCardNo).status) {
            return {};
        }
        /** @type {?} */
        const res = {};
        /** @type {?} */
        const idxSexStart = idCardNo.length === 15 ? 14 : 16;
        /** @type {?} */
        const birthYearSpan = idCardNo.length === 15 ? 2 : 4;
        /** @type {?} */
        const idxSex = 1 - idCardNo.substr(idxSexStart, 1) % 2;
        res.gender = (idxSex === 1 ? '女' : '男');
        /** @type {?} */
        const year = (birthYearSpan === 2 ? '19' : '') + idCardNo.substr(6, birthYearSpan);
        /** @type {?} */
        const month = idCardNo.substr(6 + birthYearSpan, 2);
        /** @type {?} */
        const day = idCardNo.substr(8 + birthYearSpan, 2);
        res.birthday = year + '-' + month + '-' + day;
        /** @type {?} */
        const d = DateUtils.getDate();
        /** @type {?} */
        const monthFloor = ((d.getMonth() + 1) < parseInt(month, 10) || (d.getMonth() + 1) === parseInt(month, 10) && d.getDate() < parseInt(day, 10)) ? 1 : 0;
        res.age = d.getFullYear() - parseInt(year, 10) - monthFloor;
        return res;
    }
    ;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormUtils {
    /**
     * @param {?} form
     * @param {...?} path
     * @return {?}
     */
    static getFormControl(form, ...path) {
        /** @type {?} */
        let _form = form;
        /** @type {?} */
        let control = null;
        if (path.length > 0) {
            path.forEach(p => {
                control = _form.controls[p];
                if (control instanceof FormGroup) {
                    _form = control;
                }
            });
        }
        return (/** @type {?} */ (control));
    }
    /**
     * @param {?} control
     * @param {?} value
     * @return {?}
     */
    static setValue(control, value) {
        control.setValue(value, {
            emitEvent: false,
            emitModelToViewChange: false,
            emitViewToModelChange: false
        });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ContextUtils {
    /**
     * @param {?=} date
     * @return {?}
     */
    static context(date) {
        return Object.assign({ now: DateUtils.getFormattedDateTime(), today: DateUtils.getFormattedDate(), year: DateUtils.getYear(date), lastYear: DateUtils.getYear(date) - 1, month: DateUtils.getMonth(date), lastMonth: DateUtils.getLastMonth(), day: DateUtils.getDay(date), yesterday: DateUtils.getYesterday() }, (/** @type {?} */ (StatesUtils.getValue(StateNames.user))) || {});
    }
    /**
     * @param {?} key
     * @return {?}
     */
    static get(key) {
        return ContextUtils.context()[key] || '';
    }
    /**
     * @param {?} data
     * @return {?}
     */
    static resolveVariables(data) {
        /** @type {?} */
        let resolved;
        if (CommonsUtils.isJson(data)) {
            resolved = ContextUtils.resolveJson(data);
        }
        else if (CommonsUtils.isArray(data)) {
            resolved = ContextUtils.resolveArray(data);
        }
        else if (CommonsUtils.isString(data)) {
            resolved = ContextUtils.resolveValue(data);
        }
        else {
            resolved = data;
        }
        return resolved;
    }
    /**
     * @private
     * @param {?} template
     * @return {?}
     */
    static resolveValue(template$$1) {
        /** @type {?} */
        let resolved = template$$1;
        if (CommonsUtils.isTemplateStr(template$$1)) {
            resolved = CommonsUtils.templateStr(template$$1, ContextUtils.context());
        }
        return resolved;
    }
    /**
     * @private
     * @param {?} data
     * @return {?}
     */
    static resolveJson(data) {
        /** @type {?} */
        const resolved = {};
        for (const prop in data) {
            if (data[prop] !== undefined) {
                if (CommonsUtils.isJson(data[prop])) {
                    resolved[prop] = ContextUtils.resolveJson(data[prop]);
                }
                else if (CommonsUtils.isArray(data[prop])) {
                    resolved[prop] = ContextUtils.resolveArray(data[prop]);
                }
                else if (CommonsUtils.isString(data[prop])) {
                    resolved[prop] = ContextUtils.resolveValue(data[prop]);
                }
                else {
                    resolved[prop] = data[prop];
                }
            }
        }
        return resolved;
    }
    /**
     * @private
     * @param {?} arr
     * @return {?}
     */
    static resolveArray(arr) {
        /** @type {?} */
        const resolved = [];
        arr.forEach(a => resolved.push(ContextUtils.resolveVariables(a)));
        return resolved;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_APP_CONFIG = {
    version: '0.0.1',
    stomp: {
        enabled: false,
        destination: '/message/push',
        headers: {},
        heartbeat_in: 0,
        // Typical value 0 - disabled
        heartbeat_out: 20000,
        // Typical value 20000 - every 20 seconds
        reconnect_delay: 5000,
        debug: false
    },
    auth: {
        storageKey: 'erCurrentUser',
        headerName: 'Authorization',
        authScheme: 'Bearer ',
        userTokenKey: 'userName',
        passwordKey: 'password',
        rememberMeKey: 'rememberMe',
        requiredUserProps: 'org',
        loginRouter: 'user/login',
        loginApiOptions: { serverType: ApiServerType.App },
        loginSuccessRouter: '/',
        logoutSuccessRouter: 'user/login'
    },
    alert: {},
    announce: {},
    notify: NotifyType.ALERT,
    onLoading: 'fa fa-cog fa-spin fa-3x indigo',
    enableLogger: true,
    dataFieldProps: {
        dataCode: {
            apiEntry: 'data_code',
            codeKey: 'code',
            nameKey: 'name',
            parentKey: 'parent',
            catKey: 'codeCat'
        }
    },
    wechat: {
        self_redirect: true,
        scope: 'snsapi_login',
        state: '',
        style: 'black',
        href: ''
    },
    log: {
        enableApp: true,
        enableRoute: false,
        level: LogLevel.DEBUG,
        httpPost: false,
        blackLList: ['PropsBindDirective']
    }
};
class ConfigUtils {
    /**
     * @return {?}
     */
    static getConfig() {
        return ConfigUtils.moduleConfig || ConfigUtils.appConfig;
    }
    /**
     * @param {?} customer
     * @return {?}
     */
    static configApp(customer) {
        ConfigUtils.appConfig = CommonsUtils.merge({}, DEFAULT_APP_CONFIG, customer);
        return ConfigUtils.appConfig;
    }
    /**
     * @param {?} moduleConf
     * @param {?} url
     * @return {?}
     */
    static configModule(moduleConf, url) {
        /** @type {?} */
        let config = moduleConf;
        if (url && url === ConfigUtils.lastUrl) {
            config = CommonsUtils.merge(ConfigUtils.lastConfig, moduleConf);
        }
        else {
            ConfigUtils.lastUrl = url;
            ConfigUtils.lastConfig = moduleConf;
        }
        ConfigUtils.moduleConfig = CommonsUtils.merge({}, ConfigUtils.appConfig, config);
        return ConfigUtils.moduleConfig;
    }
    /**
     * @param {?} namePath
     * @param {?=} defaultValue
     * @return {?}
     */
    static get(namePath, defaultValue) {
        return CommonsUtils.get(ConfigUtils.getConfig(), namePath, defaultValue);
    }
}
ConfigUtils.lastUrl = undefined;
ConfigUtils.lastConfig = {};
ConfigUtils.appConfig = Object.assign({}, DEFAULT_APP_CONFIG);
ConfigUtils.moduleConfig = undefined;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DialogUtils {
    /**
     * @param {?=} header
     * @param {?=} content
     * @param {?=} options
     * @return {?}
     */
    static confirm(header, content, options) {
        /** @type {?} */
        const state = StatesUtils.create(StateNames.confirm, Object.assign({ header,
            content }, options, { open: true }));
        return state.pipe(filter$1(stateValue => stateValue && !stateValue.open), map$1(({ accept }) => accept === true));
    }
    /**
     * @param {?} header
     * @param {?} content
     * @param {?=} options
     * @return {?}
     */
    static error(header, content, options) {
        /** @type {?} */
        const html = `
                 <div class="d-flex align-items-center">
                  <i class="fa fa-exclamation-circle fa-2x text-danger mr-2"></i>
                  <span style="font-size: 1.2em">${content}</span>
                </div>                 
    `;
        return DialogUtils.popup(header, html, Object.assign({}, options || {}, { maximizable: false }));
    }
    /**
     * @param {?} header
     * @param {?} content
     * @param {?=} options
     * @return {?}
     */
    static info(header, content, options) {
        /** @type {?} */
        const html = `
                 <div class="d-flex align-items-center">
                  <i class="fa fa-info-circle fa-2x text-primary mr-2"></i>
                  <span style="font-size: 1.2em">${content}</span>
                </div>                 
    `;
        return DialogUtils.popup(header, html, Object.assign({}, options || {}, { maximizable: false, minWidth: 200, closeLabel: '确定' }));
    }
    /**
     * @private
     * @param {?=} header
     * @param {?=} content
     * @param {?=} options
     * @return {?}
     */
    static popup(header, content, options) {
        /** @type {?} */
        const state = StatesUtils.create(StateNames.popup, Object.assign({ header,
            content }, options, { maximizable: false, visible: true }));
        return state;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MenuUtils {
    /**
     * @param {?} menuItems
     * @param {?=} roles
     * @param {?=} permissions
     * @return {?}
     */
    static getUserMenuItems(menuItems, roles, permissions) {
        /** @type {?} */
        const filtered = [];
        permissions = CommonsUtils.getArrayValue(permissions);
        if (!roles || roles.length === 0) {
            roles = [];
        }
        if (!permissions || permissions.length === 0) {
            permissions = [];
        }
        if (roles.length === 0 && permissions.length === 0) {
            return menuItems;
        }
        if (menuItems && menuItems.length > 0) {
            menuItems.forEach(menuItem => {
                /** @type {?} */
                const item = menuItem;
                if (item.roles || item.permissions) {
                    if (item.roles && roles.length > 0) {
                        /** @type {?} */
                        const menuRoles = CommonsUtils.getArrayValue(item.roles);
                        /** @type {?} */
                        const matched = menuRoles.filter(menuRole => roles.indexOf(menuRole) >= 0);
                        if (matched.length > 0) {
                            filtered.push(item);
                        }
                    }
                    if (filtered.indexOf(item) === -1 && item.permissions && permissions.length > 0) {
                        /** @type {?} */
                        const menuPermissions = CommonsUtils.getArrayValue(item.permissions);
                        /** @type {?} */
                        const matched = menuPermissions.filter(menuPermission => permissions.indexOf(menuPermission) >= 0);
                        if (matched.length > 0) {
                            filtered.push(item);
                        }
                    }
                }
                else {
                    filtered.push(item);
                }
                if (item.items) {
                    /** @type {?} */
                    const subItems = MenuUtils.getUserMenuItems(item.items, permissions, roles);
                    if (subItems.length > 0) {
                        item.items = subItems;
                    }
                }
            });
            return filtered;
        }
    }
    /**
     * @param {?} menuItems
     * @return {?}
     */
    static transMenuItems(menuItems) {
        /** @type {?} */
        let nodes;
        nodes = CommonsUtils.orderBy(menuItems, ['parent', 'code'], ['asc']);
        nodes.forEach(item => {
            /** @type {?} */
            const children = nodes.filter(item2 => item2['parent'] && item2['parent'] === item['code']);
            if (children.length > 0) {
                item['items'] = children;
            }
            if (item.icon && item.icon.startsWith('fa-')) {
                item.icon = 'fa ' + item.icon;
            }
        });
        return nodes = nodes.filter(node => !node['parent']);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DomUtils {
    constructor() {
        this.calculatedScrollbarWidth = null;
    }
    /**
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    static addClass(element, className) {
        if (element.classList) {
            element.classList.add(className);
        }
        else {
            element.className += ' ' + className;
        }
    }
    /**
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    static addClasses(element, className) {
        /** @type {?} */
        const styles = className.split(' ');
        for (let i = 0; i < styles.length; i++) {
            DomUtils.addClass(element, styles[i]);
        }
    }
    /**
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    static removeClass(element, className) {
        if (element.classList) {
            element.classList.remove(className);
        }
        else {
            element.className = element.className.replace(new RegExp('(^|\\b)' + className.split(' ').join('|') + '(\\b|$)', 'gi'), ' ');
        }
    }
    /**
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    static hasClass(element, className) {
        if (element.classList) {
            return element.classList.contains(className);
        }
        else {
            return new RegExp('(^| )' + className + '( |$)', 'gi').test(element.className);
        }
    }
    /**
     * @param {?} element
     * @return {?}
     */
    static siblings(element) {
        /** @type {?} */
        const children = element.parentNode.children.filter(child => child !== element);
        return children;
    }
    /**
     * @param {?} element
     * @param {?} selector
     * @return {?}
     */
    static find(element, selector) {
        return element.querySelectorAll(selector);
    }
    /**
     * @param {?} element
     * @param {?} selector
     * @return {?}
     */
    static findSingle(element, selector) {
        return element.querySelector(selector);
    }
    /**
     * @param {?} element
     * @return {?}
     */
    static index(element) {
        /** @type {?} */
        const children = element.parentNode.childNodes;
        /** @type {?} */
        let num = 0;
        for (let i = 0; i < children.length; i++) {
            if (children[i] == element)
                return num;
            if (children[i].nodeType == 1)
                num++;
        }
        return -1;
    }
    /**
     * @param {?} element
     * @param {?} target
     * @return {?}
     */
    static relativePosition(element, target) {
        /** @type {?} */
        const elementDimensions = element.offsetParent ? {
            width: element.offsetWidth,
            height: element.offsetHeight
        } : this.getHiddenElementDimensions(element);
        /** @type {?} */
        const targetHeight = target.offsetHeight;
        /** @type {?} */
        const targetWidth = target.offsetWidth;
        /** @type {?} */
        const targetOffset = target.getBoundingClientRect();
        /** @type {?} */
        const windowScrollTop = this.getWindowScrollTop();
        /** @type {?} */
        const viewport = this.getViewport();
        /** @type {?} */
        let top;
        /** @type {?} */
        let left;
        if ((targetOffset.top + targetHeight + elementDimensions.height) > viewport.height) {
            top = -1 * (elementDimensions.height);
            if (targetOffset.top + top < 0) {
                top = 0;
            }
        }
        else {
            top = targetHeight;
        }
        if ((targetOffset.left + elementDimensions.width) > viewport.width) {
            left = targetWidth - elementDimensions.width;
        }
        else {
            left = 0;
        }
        element.style.top = top + 'px';
        element.style.left = left + 'px';
    }
    /**
     * @param {?} element
     * @param {?} target
     * @return {?}
     */
    static absolutePosition(element, target) {
        /** @type {?} */
        const elementDimensions = element.offsetParent ? {
            width: element.offsetWidth,
            height: element.offsetHeight
        } : this.getHiddenElementDimensions(element);
        /** @type {?} */
        const elementOuterHeight = elementDimensions.height;
        /** @type {?} */
        const elementOuterWidth = elementDimensions.width;
        /** @type {?} */
        const targetOuterHeight = target.offsetHeight;
        /** @type {?} */
        const targetOuterWidth = target.offsetWidth;
        /** @type {?} */
        const targetOffset = target.getBoundingClientRect();
        /** @type {?} */
        const windowScrollTop = this.getWindowScrollTop();
        /** @type {?} */
        const windowScrollLeft = this.getWindowScrollLeft();
        /** @type {?} */
        const viewport = this.getViewport();
        /** @type {?} */
        let top;
        /** @type {?} */
        let left;
        if (targetOffset.top + targetOuterHeight + elementOuterHeight > viewport.height) {
            top = targetOffset.top + windowScrollTop - elementOuterHeight;
            if (top < 0) {
                top = 0 + windowScrollTop;
            }
        }
        else {
            top = targetOuterHeight + targetOffset.top + windowScrollTop;
        }
        if (targetOffset.left + targetOuterWidth + elementOuterWidth > viewport.width) {
            left = targetOffset.left + windowScrollLeft + targetOuterWidth - elementOuterWidth;
        }
        else {
            left = targetOffset.left + windowScrollLeft;
        }
        element.style.top = top + 'px';
        element.style.left = left + 'px';
    }
    /**
     * @param {?} element
     * @return {?}
     */
    static getHiddenElementOuterHeight(element) {
        element.style.visibility = 'hidden';
        element.style.display = 'block';
        /** @type {?} */
        const elementHeight = element.offsetHeight;
        element.style.display = 'none';
        element.style.visibility = 'visible';
        return elementHeight;
    }
    /**
     * @param {?} element
     * @return {?}
     */
    static getHiddenElementOuterWidth(element) {
        element.style.visibility = 'hidden';
        element.style.display = 'block';
        /** @type {?} */
        const elementWidth = element.offsetWidth;
        element.style.display = 'none';
        element.style.visibility = 'visible';
        return elementWidth;
    }
    /**
     * @param {?} element
     * @return {?}
     */
    static getHiddenElementDimensions(element) {
        /** @type {?} */
        const dimensions = {};
        element.style.visibility = 'hidden';
        element.style.display = 'block';
        dimensions.width = element.offsetWidth;
        dimensions.height = element.offsetHeight;
        element.style.display = 'none';
        element.style.visibility = 'visible';
        return dimensions;
    }
    /**
     * @param {?} container
     * @param {?} item
     * @return {?}
     */
    static scrollInView(container, item) {
        /** @type {?} */
        const borderTopValue = getComputedStyle(container).getPropertyValue('borderTopWidth');
        /** @type {?} */
        const borderTop = borderTopValue ? parseFloat(borderTopValue) : 0;
        /** @type {?} */
        const paddingTopValue = getComputedStyle(container).getPropertyValue('paddingTop');
        /** @type {?} */
        const paddingTop = paddingTopValue ? parseFloat(paddingTopValue) : 0;
        /** @type {?} */
        const containerRect = container.getBoundingClientRect();
        /** @type {?} */
        const itemRect = item.getBoundingClientRect();
        /** @type {?} */
        const offset = (itemRect.top + document.body.scrollTop) - (containerRect.top + document.body.scrollTop) - borderTop - paddingTop;
        /** @type {?} */
        const scroll = container.scrollTop;
        /** @type {?} */
        const elementHeight = container.clientHeight;
        /** @type {?} */
        const itemHeight = this.getOuterHeight(item);
        if (offset < 0) {
            container.scrollTop = scroll + offset;
        }
        else if ((offset + itemHeight) > elementHeight) {
            container.scrollTop = scroll + offset - elementHeight + itemHeight;
        }
    }
    /**
     * @param {?} element
     * @param {?} duration
     * @return {?}
     */
    static fadeIn(element, duration) {
        element.style.opacity = 0;
        /** @type {?} */
        let last = +new Date();
        /** @type {?} */
        let opacity = 0;
        /** @type {?} */
        const tick = function () {
            opacity = +element.style.opacity.replace(',', '.') + (new Date().getTime() - last) / duration;
            element.style.opacity = opacity;
            last = +new Date();
            if (+opacity < 1) {
                (window.requestAnimationFrame && requestAnimationFrame(tick)) || setTimeout(tick, 16);
            }
        };
        tick();
    }
    /**
     * @param {?} element
     * @param {?} ms
     * @return {?}
     */
    static fadeOut(element, ms) {
        /** @type {?} */
        let opacity = 1;
        /** @type {?} */
        const interval = 50;
        /** @type {?} */
        const duration = ms;
        /** @type {?} */
        const gap = interval / duration;
        /**
         * @return {?}
         */
        function intervalCallback() {
            opacity = opacity - gap;
            if (opacity <= 0) {
                opacity = 0;
                clearInterval(fading);
            }
            element.style.opacity = opacity;
        }
        /** @type {?} */
        const fading = setInterval(intervalCallback, interval);
    }
    /**
     * @return {?}
     */
    static getWindowScrollTop() {
        /** @type {?} */
        const doc = document.documentElement;
        return (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
    }
    /**
     * @return {?}
     */
    static getWindowScrollLeft() {
        /** @type {?} */
        const doc = document.documentElement;
        return (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
    }
    /**
     * @param {?} element
     * @param {?} selector
     * @return {?}
     */
    static matches(element, selector) {
        /** @type {?} */
        const p = Element.prototype;
        /** @type {?} */
        const f = p['matches'] || p.webkitMatchesSelector || function (s) {
            return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
        };
        return f.call(element, selector);
    }
    /**
     * @param {?} el
     * @param {?=} margin
     * @return {?}
     */
    static getOuterWidth(el, margin) {
        /** @type {?} */
        let width = el.offsetWidth;
        if (margin) {
            /** @type {?} */
            const style = getComputedStyle(el);
            width += parseFloat(style.marginLeft) + parseFloat(style.marginRight);
        }
        return width;
    }
    /**
     * @param {?} el
     * @return {?}
     */
    static getHorizontalPadding(el) {
        /** @type {?} */
        const style = getComputedStyle(el);
        return parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
    }
    /**
     * @param {?} el
     * @return {?}
     */
    static getHorizontalMargin(el) {
        /** @type {?} */
        const style = getComputedStyle(el);
        return parseFloat(style.marginLeft) + parseFloat(style.marginRight);
    }
    /**
     * @param {?} el
     * @return {?}
     */
    static innerWidth(el) {
        /** @type {?} */
        let width = el.offsetWidth;
        /** @type {?} */
        const style = getComputedStyle(el);
        width += parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
        return width;
    }
    /**
     * @param {?} el
     * @return {?}
     */
    static width(el) {
        /** @type {?} */
        let width = el.offsetWidth;
        /** @type {?} */
        const style = getComputedStyle(el);
        width -= parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
        return width;
    }
    /**
     * @param {?} el
     * @return {?}
     */
    static getInnerHeight(el) {
        /** @type {?} */
        let height = el.offsetHeight;
        /** @type {?} */
        const style = getComputedStyle(el);
        height += parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);
        return height;
    }
    /**
     * @param {?} el
     * @param {?=} margin
     * @return {?}
     */
    static getOuterHeight(el, margin) {
        /** @type {?} */
        let height = el.offsetHeight;
        if (margin) {
            /** @type {?} */
            const style = getComputedStyle(el);
            height += parseFloat(style.marginTop) + parseFloat(style.marginBottom);
        }
        return height;
    }
    /**
     * @param {?} el
     * @return {?}
     */
    static getHeight(el) {
        /** @type {?} */
        let height = el.offsetHeight;
        /** @type {?} */
        const style = getComputedStyle(el);
        height -= parseFloat(style.paddingTop) + parseFloat(style.paddingBottom) + parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
        return height;
    }
    /**
     * @param {?} el
     * @return {?}
     */
    static getWidth(el) {
        /** @type {?} */
        let width = el.offsetWidth;
        /** @type {?} */
        const style = getComputedStyle(el);
        width -= parseFloat(style.paddingLeft) + parseFloat(style.paddingRight) + parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth);
        return width;
    }
    /**
     * @return {?}
     */
    static getViewport() {
        /** @type {?} */
        const win = window;
        /** @type {?} */
        const d = document;
        /** @type {?} */
        const e = d.documentElement;
        /** @type {?} */
        const g = d.getElementsByTagName('body')[0];
        /** @type {?} */
        const w = win.innerWidth || e.clientWidth || g.clientWidth;
        /** @type {?} */
        const h = win.innerHeight || e.clientHeight || g.clientHeight;
        return { width: w, height: h };
    }
    /**
     * @param {?} el
     * @return {?}
     */
    static getOffset(el) {
        /** @type {?} */
        const rect = el.getBoundingClientRect();
        return {
            top: rect.top + document.body.scrollTop,
            left: rect.left + document.body.scrollLeft
        };
    }
    /**
     * @return {?}
     */
    static getUserAgent() {
        return navigator.userAgent;
    }
    /**
     * @return {?}
     */
    static resolveUserAgent() {
        /** @type {?} */
        const ua = navigator.userAgent.toLowerCase();
        /** @type {?} */
        const match = /(chrome)[ \/]([\w.]+)/.exec(ua) ||
            /(webkit)[ \/]([\w.]+)/.exec(ua) ||
            /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) ||
            /(msie) ([\w.]+)/.exec(ua) ||
            ua.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) ||
            [];
        return {
            browser: match[1] || '',
            version: match[2] || '0'
        };
    }
    /**
     * @param {?} tag
     * @param {?=} classNames
     * @return {?}
     */
    static createElement(tag, classNames) {
        /** @type {?} */
        const element = document.createElement(tag);
        if (classNames) {
            DomUtils.addClasses(element, classNames);
        }
        return element;
    }
    /**
     * @param {?} element
     * @return {?}
     */
    static remove(element) {
        element.parentElement.removeChild(element);
    }
    /**
     * @param {?} element
     * @return {?}
     */
    static removeHost(element) {
        /** @type {?} */
        const nativeElement = element;
        /** @type {?} */
        const parentElement = nativeElement.parentElement;
        while (nativeElement.firstChild) {
            parentElement.insertBefore(nativeElement.firstChild, nativeElement);
        }
        parentElement.removeChild(nativeElement);
    }
    /**
     * @return {?}
     */
    isIE() {
        /** @type {?} */
        const ua = window.navigator.userAgent;
        /** @type {?} */
        const msie = ua.indexOf('MSIE ');
        if (msie > 0) {
            // IE 10 or older => return version number
            return true;
        }
        /** @type {?} */
        const trident = ua.indexOf('Trident/');
        if (trident > 0) {
            // IE 11 => return version number
            /** @type {?} */
            const rv = ua.indexOf('rv:');
            return true;
        }
        /** @type {?} */
        const edge = ua.indexOf('Edge/');
        if (edge > 0) {
            // Edge (IE 12+) => return version number
            return true;
        }
        // other browser
        return false;
    }
    /**
     * @param {?} element
     * @param {?} target
     * @return {?}
     */
    appendChild(element, target) {
        if (this.isElement(target)) {
            target.appendChild(element);
        }
        else if (target.el && target.el.nativeElement) {
            target.el.nativeElement.appendChild(element);
        }
        else {
            throw new Error('Cannot append ' + target + ' to ' + element);
        }
    }
    /**
     * @param {?} element
     * @param {?} target
     * @return {?}
     */
    removeChild(element, target) {
        if (this.isElement(target)) {
            target.removeChild(element);
        }
        else if (target.el && target.el.nativeElement) {
            target.el.nativeElement.removeChild(element);
        }
        else {
            throw new Error('Cannot remove ' + element + ' from ' + target);
        }
    }
    /**
     * @param {?} element
     * @param {?} methodName
     * @param {?=} args
     * @return {?}
     */
    invokeElementMethod(element, methodName, args) {
        ((/** @type {?} */ (element)))[methodName].apply(element, args);
    }
    /**
     * @return {?}
     */
    clearSelection() {
        if (window.getSelection) {
            if (window.getSelection().empty) {
                window.getSelection().empty();
            }
            else if (window.getSelection().removeAllRanges && window.getSelection().rangeCount > 0 && window.getSelection().getRangeAt(0).getClientRects().length > 0) {
                window.getSelection().removeAllRanges();
            }
        }
        else if (document['selection'] && document['selection'].empty) {
            try {
                document['selection'].empty();
            }
            catch (error) {
                //ignore IE bug
            }
        }
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    isElement(obj) {
        return (typeof HTMLElement === 'object' ? obj instanceof HTMLElement :
            obj && typeof obj === 'object' && obj !== null && obj.nodeType === 1 && typeof obj.nodeName === 'string');
    }
    /**
     * @return {?}
     */
    getBrowser() {
        if (!this.browser) {
            /** @type {?} */
            const matched = DomUtils.resolveUserAgent();
            this.browser = {};
            if (matched.browser) {
                this.browser[matched.browser] = true;
                this.browser['version'] = matched.version;
            }
            if (this.browser['chrome']) {
                this.browser['webkit'] = true;
            }
            else if (this.browser['webkit']) {
                this.browser['safari'] = true;
            }
        }
        return this.browser;
    }
    /**
     * @return {?}
     */
    calculateScrollbarWidth() {
        if (this.calculatedScrollbarWidth !== null) {
            return this.calculatedScrollbarWidth;
        }
        /** @type {?} */
        const scrollDiv = document.createElement('div');
        scrollDiv.className = 'ui-scrollbar-measure';
        document.body.appendChild(scrollDiv);
        /** @type {?} */
        const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        document.body.removeChild(scrollDiv);
        this.calculatedScrollbarWidth = scrollbarWidth;
        return scrollbarWidth;
    }
}
DomUtils.zindex = 1000;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class EncodeUtils {
    // credits for decoder goes to https://github.com/atk
    /**
     * @param {?} str
     * @return {?}
     */
    static base64decode(str) {
        /** @type {?} */
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
        /** @type {?} */
        let output = '';
        str = String(str).replace(/=+$/, '');
        if (str.length % 4 === 1) {
            throw new Error('\'atob\' failed: The string to be decoded is not correctly encoded.');
        }
        for (
        // initialize result and counters
        let bc = 0, bs, buffer, idx = 0; 
        // get next character
        (buffer = str.charAt(idx++)); 
        // character found in table? initialize bit storage and add its ascii value;
        ~buffer &&
            ((bs = bc % 4 ? bs * 64 + buffer : buffer),
                // and if not first of each 4 characters,
                // convert the first 8 bits to one ascii character
                bc++ % 4)
            ? (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6))))
            : 0) {
            // try to find character in table (0-63, not found => -1)
            buffer = chars.indexOf(buffer);
        }
        return output;
    }
    /**
     * @param {?} str
     * @return {?}
     */
    static base64DecodeUnicode(str) {
        /** @type {?} */
        const decoded = decodeURIComponent(Array.prototype.map
            .call(EncodeUtils.base64decode(str), (c) => {
            return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
        })
            .join(''));
        return decoded;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class JwtUtils {
    /**
     * @param {?} str
     * @return {?}
     */
    static urlBase64Decode(str) {
        /** @type {?} */
        let output = str.replace(/-/g, '+').replace(/_/g, '/');
        switch (output.length % 4) {
            case 0: {
                break;
            }
            case 2: {
                output += '==';
                break;
            }
            case 3: {
                output += '=';
                break;
            }
            default: {
                throw new Error('Illegal base64url string!');
            }
        }
        return EncodeUtils.base64decode(output);
    }
    /**
     * @param {?} token
     * @return {?}
     */
    static decodeToken(token) {
        if (token === null) {
            return null;
        }
        /** @type {?} */
        const parts = token.split('.');
        if (parts.length !== 3) {
            throw new Error('The inspected token doesn\'t appear to be a JWT. Check to make sure it has three parts and see https://jwt.io for more.');
        }
        /** @type {?} */
        const decoded = JwtUtils.urlBase64Decode(parts[1]);
        if (!decoded) {
            throw new Error('Cannot decode the token.');
        }
        return JSON.parse(decoded);
    }
    /**
     * @param {?} token
     * @return {?}
     */
    static getTokenExpirationDate(token) {
        /** @type {?} */
        let decoded;
        decoded = this.decodeToken(token);
        if (!decoded.hasOwnProperty('exp')) {
            return null;
        }
        /** @type {?} */
        const date = new Date(0);
        date.setUTCSeconds(decoded.exp);
        return date;
    }
    /**
     * @param {?} token
     * @param {?=} offsetSeconds
     * @return {?}
     */
    static isValid(token, offsetSeconds) {
        if (token === null || token === '')
            return false;
        /** @type {?} */
        const date = JwtUtils.getTokenExpirationDate(token);
        offsetSeconds = offsetSeconds || 0;
        if (date === null) {
            return false;
        }
        return date.valueOf() > (new Date().valueOf() + offsetSeconds * 1000);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IdUtils {
    /**
     * @return {?}
     */
    static getRandom() {
        return Math.floor(Math.random() * 10000000000) + '';
    }
    /**
     * @return {?}
     */
    static getUUID() {
        if (typeof (window) !== 'undefined' &&
            typeof (window.crypto) !== 'undefined' &&
            typeof (window.crypto.getRandomValues) !== 'undefined') {
            /** @type {?} */
            const buf = new Uint16Array(8);
            window.crypto.getRandomValues(buf);
            return (IdUtils._pad4(buf[0]) + IdUtils._pad4(buf[1])
                + '-' + IdUtils._pad4(buf[2])
                + '-' + IdUtils._pad4(buf[3])
                + '-' + IdUtils._pad4(buf[4])
                + '-' + IdUtils._pad4(buf[5]) + IdUtils._pad4(buf[6]) + IdUtils._pad4(buf[7]));
        }
        else {
            return IdUtils._random4() + IdUtils._random4()
                + '-' + IdUtils._random4()
                + '-' + IdUtils._random4()
                + '-' + IdUtils._random4()
                + '-' + IdUtils._random4() + IdUtils._random4() + IdUtils._random4();
        }
    }
    /**
     * @private
     * @param {?} num
     * @return {?}
     */
    static _pad4(num) {
        /** @type {?} */
        let ret = num.toString(16);
        while (ret.length < 4) {
            ret = '0' + ret;
        }
        return ret;
    }
    /**
     * @private
     * @return {?}
     */
    static _random4() {
        return Math.floor((1 + Math.random()) * 0x10000)
            .toString(16)
            .substring(1);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PinyinUtil {
    /**
     * 获取汉字的拼音首字母
     * @param {?} str 汉字字符串，如果遇到非汉字则原样返回
     * @return {?}
     */
    static getFirstLetter(str) {
        /** @type {?} */
        const pys = pinyinlite(str);
        /** @type {?} */
        const fpy = pys.map(py => py[0] && py[0].substr(0, 1));
        return fpy.join('').toLowerCase();
    }
    /**
     * @param {?} str
     * @return {?}
     */
    static getPinYin(str) {
        /** @type {?} */
        const pys = pinyinlite(str);
        /** @type {?} */
        const fpy = pys.map(py => py[0] ? py[0] : '');
        return fpy.join('').toLowerCase();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ImageUtil {
    /**
     * @param {?} file
     * @return {?}
     */
    static getBase64(file) {
        if (typeof file === 'string' && file.startsWith('data:')) {
            return of(file);
        }
        else {
            /** @type {?} */
            const reader = new FileReader();
            /** @type {?} */
            const fileContent$ = fromEvent(reader, 'load')
                .pipe(map$1((e) => {
                console.log(e.target['result']);
                return e.target['result'];
            }));
            // (<File>file).type
            reader.readAsDataURL((/** @type {?} */ (file)));
            return fileContent$;
        }
    }
    /**
     * @param {?} file
     * @return {?}
     */
    static upload(file) {
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PagerUtil {
    /**
     * @param {?} totalItems
     * @param {?=} currentPage
     * @param {?=} pageSize
     * @return {?}
     */
    static getPagerModel(totalItems, currentPage = 1, pageSize = 10) {
        /** @type {?} */
        const totalPages = Math.ceil(totalItems / pageSize);
        /** @type {?} */
        let startPage;
        /** @type {?} */
        let endPage;
        if (totalPages <= 10) {
            startPage = 1;
            endPage = totalPages;
        }
        else {
            if (currentPage <= 6) {
                startPage = 1;
                endPage = 10;
            }
            else if (currentPage + 4 >= totalPages) {
                startPage = totalPages - 9;
                endPage = totalPages;
            }
            else {
                startPage = currentPage - 5;
                endPage = currentPage + 4;
            }
        }
        /** @type {?} */
        const startIndex = (currentPage - 1) * pageSize;
        /** @type {?} */
        const endIndex = Math.min(startIndex + pageSize - 1, totalItems - 1);
        /** @type {?} */
        const pages = range(startPage, endPage + 1);
        return {
            totalItems: totalItems,
            currentPage: currentPage,
            pageSize: pageSize,
            totalPages: totalPages,
            startPage: startPage,
            endPage: endPage,
            startIndex: startIndex,
            endIndex: endIndex,
            pages: pages
        };
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TreeUtils {
    /**
     * @param {?} dataItems
     * @param {?} keyMap
     * @param {?=} root
     * @param {?=} lazy
     * @return {?}
     */
    static transNodes(dataItems, keyMap, root, lazy) {
        /** @type {?} */
        const treeKeys = Object.keys(keyMap.node).map(key => keyMap.node[key]);
        /** @type {?} */
        let nodes;
        /** @type {?} */
        let rootNode;
        if (keyMap.src.levelIdLength) {
            nodes = CommonsUtils.orderBy(dataItems, [keyMap.src.orderKey || keyMap.src.idKey], ['asc']);
            nodes = nodes.map(item => {
                if (item[keyMap.src.idKey]) {
                    /** @type {?} */
                    const parentId = item[keyMap.src.idKey].substr(0, item[keyMap.src.idKey].length - keyMap.src.levelIdLength);
                    if (parentId && parentId !== item[keyMap.src.idKey]) {
                        item[keyMap.src.parentKey] = parentId;
                    }
                    if (!item[keyMap.node.dataKey]) {
                        item[keyMap.node.dataKey] = Object.assign({}, item);
                    }
                    item[keyMap.node.idKey] = item[keyMap.src.idKey];
                    item = CommonsUtils.pick(item, treeKeys);
                    return item;
                }
            });
        }
        else if (keyMap.src.parentKey) {
            nodes = CommonsUtils.orderBy(dataItems, [keyMap.src.parentKey, keyMap.src.idKey], ['asc']);
            nodes = nodes.map(item => {
                if (!item[keyMap.node.dataKey]) {
                    item[keyMap.node.dataKey] = Object.assign({}, item);
                }
                item[keyMap.node.idKey] = item[keyMap.src.idKey];
                item = CommonsUtils.pick(item, treeKeys);
                return item;
            });
        }
        nodes.forEach(item => {
            item[keyMap.node.dataKey] = item[keyMap.node.dataKey] || Object.assign({}, item);
            /** @type {?} */
            const children = nodes.filter(item2 => item2 && item2[keyMap.src.parentKey] && item2[keyMap.src.parentKey] === item['data'][keyMap.src.idKey]);
            if (children.length > 0) {
                item[keyMap.node.childrenKey] = children;
            }
            item[keyMap.node.labelKey] = DataItemUtils.getItemLabel(item, keyMap.src.labelKey);
            if (item[keyMap.src.parentKey]) {
                item[keyMap.node.parentKey] = item[keyMap.src.parentKey];
            }
            if (lazy) {
                item[keyMap.node.leafKey] = false;
            }
            if (root && CommonsUtils.isString(root) && root === item[keyMap.src.idKey]) {
                rootNode = [item];
            }
        });
        if (root && CommonsUtils.isJson(root)) {
            root['children'] = nodes;
            return [root];
        }
        else {
            return nodes = rootNode ? rootNode : nodes.filter(node => !node[keyMap.node.parentKey]);
        }
    }
    /**
     * @param {?} treeNodes
     * @param {?} value
     * @param {?} props
     * @return {?}
     */
    static findNode(treeNodes, value, props) {
        /** @type {?} */
        let found;
        if (treeNodes) {
            for (let i = 0; i < treeNodes.length; i++) {
                if (value[props.dataItemProps.idKey] === treeNodes[i][DEFAULT_TREE_NODE_KEYS.dataKey][props.dataItemProps.idKey]) {
                    found = treeNodes[i];
                    break;
                }
                if (treeNodes[i].hasOwnProperty(DEFAULT_TREE_NODE_KEYS.childrenKey)) {
                    /** @type {?} */
                    const children = treeNodes[i][DEFAULT_TREE_NODE_KEYS.childrenKey];
                    found = TreeUtils.findNode(children, value, props);
                    if (found) {
                        break;
                    }
                }
            }
        }
        return found;
    }
    /**
     * @param {?} nodes
     * @param {?} predicate
     * @return {?}
     */
    static filter(nodes, predicate) {
        /** @type {?} */
        const result = !nodes ? null : nodes.reduce((list, node) => {
            /** @type {?} */
            let clone = null;
            if (predicate(node)) {
                // if the object matches the filter, clone it as it is
                clone = CommonsUtils.copy(Object.assign({}, node, { matched: true }));
            }
            else if (node.children != null) {
                // if the object has childrens, filter the list of children
                /** @type {?} */
                const children = TreeUtils.filter(node.children, predicate);
                if (children.length > 0) {
                    // if any of the children matches, clone the parent object, overwrite
                    // the children list with the filtered list
                    clone = Object.assign({}, node, { children: children });
                }
            }
            if (clone) {
                list.push(clone);
            }
            return list;
        }, []);
        return result;
    }
    /**
     * @param {?} node
     * @param {?} isExpand
     * @param {?=} props
     * @param {?=} toExpandLevel
     * @param {?=} currentLevel
     * @param {?=} id
     * @return {?}
     */
    static expandNode(node, isExpand, props = {}, toExpandLevel = 100, currentLevel = 1, id) {
        if (!node) {
            return;
        }
        if (toExpandLevel >= currentLevel) {
            if (id && (currentLevel === toExpandLevel)) {
                node.expanded = node['id'] === id;
            }
            else if (!id || (id && currentLevel < toExpandLevel)) {
                node.expanded = isExpand;
            }
            TreeUtils.initNode(node, props);
            currentLevel++;
            if (node.children) {
                node.children.forEach(childNode => {
                    TreeUtils.initNode(childNode, props);
                    if (toExpandLevel >= currentLevel) {
                        TreeUtils.expandNode(childNode, isExpand, props, toExpandLevel, currentLevel, id);
                    }
                });
            }
        }
    }
    /**
     * @param {?} node
     * @param {?=} props
     * @return {?}
     */
    static initNode(node, props = {}) {
        if (!node._inited) {
            ['expandedIcon', 'collapsedIcon'].forEach(iconType => TreeUtils.initIcon(node, iconType, props));
            if (props['selectable']) {
                node.selectable = CommonsUtils.getValue(props['selectable'], node);
            }
            node = Object.assign({}, node, { '_inited': true });
        }
    }
    /**
     * @param {?} node
     * @param {?} iconType
     * @param {?} props
     * @return {?}
     */
    static initIcon(node, iconType, props) {
        if (!props) {
            node[iconType] = TreeUtils.DEFAULT_NODE_PROPS[iconType];
        }
        else if (props[iconType] && props[iconType].method) {
            node[iconType] = ((/** @type {?} */ (props[iconType].method)))(node);
        }
        else {
            node[iconType] = props[iconType] || TreeUtils.DEFAULT_NODE_PROPS[iconType];
        }
    }
    /**
     * @param {?} siblingId
     * @return {?}
     */
    static getSelectedTreeState(siblingId) {
        if (!siblingId) {
            return null;
        }
        /** @type {?} */
        const sibling = siblingId && StatesUtils.getValue(siblingId);
        if (sibling && sibling.component) {
            /** @type {?} */
            const treeId = CommonsUtils.get(sibling.component, '$props.$ext.$container.tree.$id');
            /** @type {?} */
            const treeState = StatesUtils.getValue(treeId);
            return treeState;
        }
    }
    /**
     * @param {?} siblingId
     * @return {?}
     */
    static getSelectedNode(siblingId) {
        /** @type {?} */
        const treeState = TreeUtils.getSelectedTreeState(siblingId);
        return treeState && treeState['selectedNode'];
    }
    /**
     * @param {?} siblingId
     * @return {?}
     */
    static getSelectedNodeValue(siblingId) {
        /** @type {?} */
        const treeState = TreeUtils.getSelectedTreeState(siblingId);
        return treeState && treeState['selectedNodeValue'];
    }
}
TreeUtils.DEFAULT_NODE_PROPS = {
    lazy: false,
    autoExpandLevel: 0,
    expandedIcon: 'fa fa-folder-open',
    collapsedIcon: 'fa fa-folder',
    icon: 'fa fa-leaf'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AnnounceUtils {
    /**
     * @param {?} options
     * @return {?}
     */
    static info(options) {
        /** @type {?} */
        const notify = CommonsUtils.getObjWhenStr(options, 'message');
        StatesUtils.create(StateNames.notify, Object.assign({}, notify, { type: NotifyType.ANNOUNCE }));
    }
    /**
     * @param {?} options
     * @return {?}
     */
    static error(options) {
        /** @type {?} */
        const notify = CommonsUtils.getObjWhenStr(options, 'message');
        StatesUtils.create(StateNames.notify, (/** @type {?} */ (Object.assign({}, notify, { level: NotifyLevel.ERROR, type: NotifyType.ANNOUNCE }))));
    }
    /**
     * @param {?} options
     * @return {?}
     */
    static success(options) {
        /** @type {?} */
        const notify = CommonsUtils.getObjWhenStr(options, 'message');
        StatesUtils.create(StateNames.notify, (/** @type {?} */ (Object.assign({}, notify, { level: NotifyLevel.SUCCESS, type: NotifyType.ANNOUNCE }))));
    }
    /**
     * @param {?} options
     * @return {?}
     */
    static warn(options) {
        /** @type {?} */
        const notify = CommonsUtils.getObjWhenStr(options, 'message');
        StatesUtils.create(StateNames.notify, (/** @type {?} */ (Object.assign({}, notify, { level: NotifyLevel.WARN, type: NotifyType.ANNOUNCE }))));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NotifyUtils {
    /**
     * @param {?} options
     * @return {?}
     */
    static info(options) {
        /** @type {?} */
        const notify = CommonsUtils.getObjWhenStr(options, 'message');
        StatesUtils.create(StateNames.notify, notify);
    }
    /**
     * @param {?} options
     * @return {?}
     */
    static error(options) {
        /** @type {?} */
        const notify = CommonsUtils.getObjWhenStr(options, 'message');
        StatesUtils.create(StateNames.notify, (/** @type {?} */ (Object.assign({}, notify, { level: NotifyLevel.ERROR }))));
    }
    /**
     * @param {?} options
     * @return {?}
     */
    static success(options) {
        /** @type {?} */
        const notify = CommonsUtils.getObjWhenStr(options, 'message');
        StatesUtils.create(StateNames.notify, (/** @type {?} */ (Object.assign({}, notify, { level: NotifyLevel.SUCCESS }))));
    }
    /**
     * @param {?} options
     * @return {?}
     */
    static warn(options) {
        /** @type {?} */
        const notify = CommonsUtils.getObjWhenStr(options, 'message');
        StatesUtils.create(StateNames.notify, (/** @type {?} */ (Object.assign({}, notify, { level: NotifyLevel.WARN }))));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RxUtils {
    /**
     * @template T
     * @param {?} count
     * @param {?} wait
     * @return {?}
     */
    static retry(count, wait) {
        /** @type {?} */
        const tap = retryWhen(errors => errors.pipe(scan((acc, error) => {
            if (acc >= count || -1) {
                throw error;
            }
            return acc + 1;
        }, 0), delay(wait)));
        return tap;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UrlUtils {
    /**
     * @return {?}
     */
    static getQueryParameters() {
        return UrlUtils.getQueryParametersUsingParameters(document.location.search);
    }
    /**
     * @param {?} search
     * @return {?}
     */
    static getQueryParametersUsingParameters(search) {
        /** @type {?} */
        const r = search.replace(/(^\?)/, '').split('&').map(function (n) { return n = n.split('='), this[n[0]] = n[1], this; }.bind({}))[0];
        return r;
    }
    /**
     * @return {?}
     */
    static getInitialUrlParameters() {
        /** @type {?} */
        const questionMarkIndex = UrlUtils.initialUrl.indexOf('?');
        if (questionMarkIndex >= 0) {
            return UrlUtils.initialUrl.substr(questionMarkIndex, UrlUtils.initialUrl.length - questionMarkIndex);
        }
        return '';
    }
    /**
     * @return {?}
     */
    static getReturnUrl() {
        /** @type {?} */
        const queryStringObj = UrlUtils.getQueryParametersUsingParameters(UrlUtils.getInitialUrlParameters());
        if (queryStringObj.returnUrl) {
            return decodeURIComponent(queryStringObj.returnUrl);
        }
        return null;
    }
    /**
     * @return {?}
     */
    static getSingleSignIn() {
        /** @type {?} */
        const queryStringObj = UrlUtils.getQueryParametersUsingParameters(UrlUtils.getInitialUrlParameters());
        if (queryStringObj.ss) {
            return queryStringObj.ss;
        }
        return false;
    }
}
/**
 * The URL requested, before initial routing.
 */
UrlUtils.initialUrl = location.href;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TokenizerUtils {
    /**
     * @param {?} str
     * @param {?} format
     * @return {?}
     */
    static extract(str, format) {
        if (str === format) {
            return new ExtractionResult(true);
        }
        /** @type {?} */
        const formatTokens = new FormatStringTokenizer().Tokenize(format);
        if (!formatTokens) {
            return new ExtractionResult(str === '');
        }
        /** @type {?} */
        const result = new ExtractionResult(true);
        for (let i = 0; i < formatTokens.length; i++) {
            /** @type {?} */
            const currentToken = formatTokens[i];
            /** @type {?} */
            const previousToken = i > 0 ? formatTokens[i - 1] : null;
            if (currentToken.Type === FormatStringTokenType.ConstantText) {
                if (i === 0) {
                    if (str.indexOf(currentToken.Text) !== 0) {
                        result.isMatch = false;
                        return result;
                    }
                    str = str.substr(currentToken.Text.length, str.length - currentToken.Text.length);
                }
                else {
                    /** @type {?} */
                    const matchIndex = str.indexOf(currentToken.Text);
                    if (matchIndex < 0) {
                        result.isMatch = false;
                        return result;
                    }
                    result.matches.push({ name: previousToken.Text, value: str.substr(0, matchIndex) });
                    str = str.substring(0, matchIndex + currentToken.Text.length);
                }
            }
        }
        /** @type {?} */
        const lastToken = formatTokens[formatTokens.length - 1];
        if (lastToken.Type === FormatStringTokenType.DynamicValue) {
            result.matches.push({ name: lastToken.Text, value: str });
        }
        return result;
    }
    /**
     * @param {?} str
     * @param {?} format
     * @return {?}
     */
    static matches(str, format) {
        /** @type {?} */
        const result = TokenizerUtils.extract(str, format);
        if (!result.isMatch) {
            return [];
        }
        /** @type {?} */
        const values = [];
        for (let i = 0; i < result.matches.length; i++) {
            values.push(result.matches[i].value);
        }
        return values;
    }
}
class ExtractionResult {
    /**
     * @param {?} isMatch
     */
    constructor(isMatch) {
        this.isMatch = isMatch;
        this.matches = [];
    }
}
/** @enum {number} */
const FormatStringTokenType = {
    ConstantText: 0,
    DynamicValue: 1,
};
FormatStringTokenType[FormatStringTokenType.ConstantText] = 'ConstantText';
FormatStringTokenType[FormatStringTokenType.DynamicValue] = 'DynamicValue';
class FormatStringToken {
    /**
     * @param {?} text
     * @param {?} type
     */
    constructor(text, type) {
        this.Text = text;
        this.Type = type;
    }
}
class FormatStringTokenizer {
    /**
     * @param {?} format
     * @param {?=} includeBracketsForDynamicValues
     * @return {?}
     */
    Tokenize(format, includeBracketsForDynamicValues = false) {
        /** @type {?} */
        const tokens = [];
        /** @type {?} */
        let currentText = '';
        /** @type {?} */
        let inDynamicValue = false;
        for (let i = 0; i < format.length; i++) {
            /** @type {?} */
            const c = format[i];
            switch (c) {
                case '{':
                    if (inDynamicValue) {
                        throw new Error('Incorrect syntax at char ' + i + '! format string can not contain agg dynamic value expression!');
                    }
                    inDynamicValue = true;
                    if (currentText.length > 0) {
                        tokens.push(new FormatStringToken(currentText, FormatStringTokenType.ConstantText));
                        currentText = '';
                    }
                    break;
                case '}':
                    if (!inDynamicValue) {
                        throw new Error(('Incorrect syntax at char ' + i + '! These is no opening brackets for the closing bracket }.'));
                    }
                    inDynamicValue = false;
                    if (currentText.length <= 0) {
                        throw new Error(('Incorrect syntax at char ' + i + '! Brackets does not containt any chars.'));
                    }
                    /** @type {?} */
                    let dynamicValue = currentText;
                    if (includeBracketsForDynamicValues) {
                        dynamicValue = '{' + dynamicValue + '}';
                    }
                    tokens.push(new FormatStringToken(dynamicValue, FormatStringTokenType.DynamicValue));
                    currentText = '';
                    break;
                default:
                    currentText += c;
                    break;
            }
        }
        if (inDynamicValue) {
            throw new Error(('There is no closing } char for an opened { char.'));
        }
        if (currentText.length > 0) {
            tokens.push(new FormatStringToken(currentText, FormatStringTokenType.ConstantText));
        }
        return tokens;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} _num
 * @return {?}
 */
function numToText(_num) {
    /** @type {?} */
    const units = ['', '万', '亿'];
    /** @type {?} */
    const _units = ['千', '百', '十', ''];
    /** @type {?} */
    const zero2Nine = ['零', '一', '二', '三', '四', '五', '六', '七', '八', '九'];
    /** @type {?} */
    const num = _num.toString().split('').reverse().join('');
    /** @type {?} */
    const unitsLen = units.length;
    /** @type {?} */
    const numLen = num.length;
    if (numLen > unitsLen * 4) {
        return '请不要传入过大的数字';
    }
    /** @type {?} */
    let str = '';
    for (let i = 0; i < numLen / 4; i++) {
        /** @type {?} */
        const __num = num.slice(i * 4, i * 4 + 4).split('').reverse().join('');
        if (__num === '0000') {
            continue;
        }
        /** @type {?} */
        let __str = '';
        for (let j = 0; j < __num.length; j++) {
            /** @type {?} */
            const currentNum = zero2Nine[parseInt(__num[j], 10)];
            /** @type {?} */
            const currentUnit = _units[j + 4 - __num.length];
            if (currentNum === '零' && currentUnit === '') {
                continue;
            }
            else {
                __str += currentNum + currentUnit;
            }
        }
        str = __str + units[i] + str;
    }
    return str.replace(/零[\D]/g, '@').replace(/[@]+/g, '@').replace(/@$/, '').replace(/@([万亿]+)/, '$1').replace(/@/g, '零');
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class EsUtils {
    /**
     * @param {?} obj
     * @return {?}
     */
    static parseEsbObject(obj) {
        if (!obj) {
            return obj;
        }
        if (CommonsUtils.isArray(obj)) {
            return obj.forEach(o => EsUtils.parseEsbObject(o));
        }
        else {
            if (CommonsUtils.isFunction(obj['toJSON'])) {
                return obj['toJSON']();
            }
            else {
                return obj;
            }
        }
    }
    /**
     * @param {?} key
     * @param {?} aggMethods
     * @return {?}
     */
    static getFieldAggs(key, aggMethods) {
        if (aggMethods) {
            /** @type {?} */
            let aggs = {};
            aggMethods.forEach(method => {
                switch (method) {
                    case AggMethodsProps.avg.key:
                        aggs = CommonsUtils.merge(aggs, avgAggregation(`${key}-${method}`, key).toJSON());
                        break;
                    case AggMethodsProps.distinct.key:
                        aggs = CommonsUtils.merge(aggs, cardinalityAggregation(`${key}-${method}`, key).toJSON());
                        break;
                    case AggMethodsProps.max.key:
                        aggs = CommonsUtils.merge(aggs, maxAggregation(`${key}-${method}`, key).toJSON());
                        break;
                    case AggMethodsProps.min.key:
                        aggs = CommonsUtils.merge(aggs, minAggregation(`${key}-${method}`, key).toJSON());
                        break;
                    case AggMethodsProps.sum.key:
                        aggs = CommonsUtils.merge(aggs, sumAggregation(`${key}-${method}`, key).toJSON());
                        break;
                    case AggMethodsProps.count.key:
                        aggs = CommonsUtils.merge(aggs, valueCountAggregation(`${key}-${method}`, key).toJSON());
                        break;
                    default:
                        aggs = CommonsUtils.merge(aggs, valueCountAggregation(`${key}-${method}`, key).toJSON());
                }
            });
            return aggs;
        }
        else {
            return undefined;
        }
    }
    /**
     * @param {?} query
     * @return {?}
     */
    static resolveQuery(query) {
        /** @type {?} */
        let must = [];
        /** @type {?} */
        let should = [];
        /** @type {?} */
        let not = [];
        if (query) {
            if (CommonsUtils.isArray(query)) {
                must = must.concat(query);
            }
            else if (CommonsUtils.isJson(query)) {
                if (query.hasOwnProperty('$and')) {
                    /** @type {?} */
                    const and = query['$and'];
                    if (CommonsUtils.isArray(and)) {
                        must = must.concat(and);
                    }
                    else {
                        must.push(and);
                    }
                }
                if (query.hasOwnProperty('$or')) {
                    /** @type {?} */
                    const or = query['$or'];
                    if (CommonsUtils.isArray(or)) {
                        should = should.concat(or);
                    }
                    else {
                        should.push(or);
                    }
                }
                if (query.hasOwnProperty('$not')) {
                    /** @type {?} */
                    const but = query['$not'];
                    if (CommonsUtils.isArray(but)) {
                        not = not.concat(but);
                    }
                    else {
                        not.push(but);
                    }
                }
            }
            else {
                must.push(query);
            }
        }
        return {
            must: CommonsUtils.compact(must),
            should: CommonsUtils.compact(should),
            not: CommonsUtils.compact(not)
        };
    }
    /**
     * @param {?} options
     * @return {?}
     */
    static resolveSearchFields(options) {
        /** @type {?} */
        const searchFields = CommonsUtils.getArrayValue(options.searchFields);
        if (CommonsUtils.isEmpty(searchFields)) {
            DialogUtils.error('数据错误', '没有定义查询字段');
            throw new Error('not found search fields');
        }
        /** @type {?} */
        const qs = [];
        searchFields.filter(field => !!field).forEach(field => {
            if (options.withPy) {
                if (options.withWildcard) {
                    qs.push(wildcardQuery(`${field}.py`, `*${options.queryValue}*`));
                }
                else {
                    qs.push(prefixQuery(`${field}.py`, options.queryValue));
                }
            }
            if (options.withZh) {
                qs.push(wildcardQuery(`${field}.zh`, `*${options.queryValue}*`));
            }
            if (options.withTerm) {
                qs.push(termQuery(field, options.queryValue));
            }
            if (options.withPrefix) {
                qs.push(prefixQuery(field, options.queryValue));
            }
            if (options.withWildcard) {
                qs.push(wildcardQuery(field, `*${options.queryValue}*`));
            }
            if (qs.length === 0) {
                qs.push(matchQuery(field, options.queryValue));
            }
        });
        return qs;
    }
    /**
     * @param {?} options
     * @return {?}
     */
    static buildQueryBody(options) {
        /** @type {?} */
        const query = requestBodySearch();
        /** @type {?} */
        const boolQuery$$1 = boolQuery();
        /** @type {?} */
        const queries = EsUtils.resolveQuery(options.query);
        if (options.queryValue) {
            /** @type {?} */
            const qs = EsUtils.resolveSearchFields(options);
            if (qs.length === 1) {
                queries.must.push(qs[0]);
            }
            else {
                queries.should = queries.should.concat(qs);
            }
        }
        if (queries.must.length > 0) {
            boolQuery$$1.must(queries.must);
        }
        if (queries.should.length > 0) {
            boolQuery$$1.should(queries.should).minimumShouldMatch(1);
        }
        if (queries.not.length > 0) {
            boolQuery$$1.mustNot(queries.not);
        }
        query.query(boolQuery$$1);
        if (!CommonsUtils.isEmpty(options.filter)) {
            boolQuery$$1.filter(options.filter);
        }
        if (!(options.returnFields && options.returnFields.length === 0)) {
            /** @type {?} */
            const returnFields = options.returnFields || options.searchFields;
            query.source(returnFields);
        }
        if (options.sort) {
            /** @type {?} */
            const sorts = EsUtils.resolveSort(options.sort);
            /** @type {?} */
            const esSorts = [];
            Object.keys(sorts).forEach(key => {
                esSorts.push(sort(key, sorts[key] || Order.ASC).unmappedType('string'));
            });
            query.sorts(esSorts);
        }
        if (options.aggProps) {
            /** @type {?} */
            const aggs = EsUtils.parseAggProps(options.aggProps);
            if (aggs.length > 0) {
                ((/** @type {?} */ (query))).aggs(aggs);
                ((/** @type {?} */ (query))).size(options.size || 0);
            }
        }
        if (options.from) {
            query.from(options.from);
        }
        if (options.size) {
            query.size(options.size);
        }
        return query;
    }
    /**
     * @param {?} aggProps
     * @return {?}
     */
    static parseAggProps(aggProps) {
        /** @type {?} */
        const props = CommonsUtils.getArrayValue(aggProps);
        /** @type {?} */
        const aggs = [];
        /** @type {?} */
        let agg;
        props.forEach(item => {
            /** @type {?} */
            let aggProp = item;
            if (CommonsUtils.isString(aggProp)) {
                aggProp = { field: item };
            }
            /** @type {?} */
            const aggName = aggProp.name || `${aggProp.field}-${aggProp.method || 'terms'}`;
            if (aggProp.aggs) {
                aggProp.method = AggMethods.CUSTOMER;
            }
            switch (aggProp.method) {
                case AggMethods.AVG:
                    agg = avgAggregation(aggName, aggProp.field).missing('0');
                    break;
                case AggMethods.MIN:
                    agg = minAggregation(aggName, aggProp.field);
                    break;
                case AggMethods.MAX:
                    agg = maxAggregation(aggName, aggProp.field);
                    break;
                case AggMethods.SUM:
                    agg = sumAggregation(aggName, aggProp.field).missing('0');
                    break;
                case AggMethods.DISTINCT:
                    agg = cardinalityAggregation(aggName, aggProp.field);
                    break;
                case AggMethods.HISTOGRAM:
                    agg = histogramAggregation(aggName, aggProp.field);
                    if (aggProp.format) {
                        ((/** @type {?} */ (agg))).interval(aggProp.interval);
                    }
                    ((/** @type {?} */ (agg))).minDocCount(aggProp.minCount || 1);
                    if (aggProp.format) {
                        ((/** @type {?} */ (agg))).format(aggProp.format);
                    }
                    if (aggProp.missing) {
                        ((/** @type {?} */ (agg))).missing(aggProp.missing);
                    }
                    break;
                case AggMethods.DATE_HISTOGRAM:
                    agg = dateHistogramAggregation(aggName, aggProp.field);
                    if (aggProp.interval) {
                        ((/** @type {?} */ (agg))).interval(aggProp.interval);
                    }
                    /** @type {?} */
                    const interval = aggProp.interval || AggInterval.DAY;
                    /** @type {?} */
                    const intervalProp = AggIntervalProps[interval];
                    ((/** @type {?} */ (agg))).interval(interval);
                    ((/** @type {?} */ (agg))).minDocCount(aggProp.minCount || 1);
                    /** @type {?} */
                    const format = aggProp.format || (intervalProp && intervalProp.format);
                    if (format) {
                        ((/** @type {?} */ (agg))).format(format);
                    }
                    if (aggProp.missing) {
                        ((/** @type {?} */ (agg))).missing(aggProp.missing);
                    }
                    break;
                case AggMethods.CUSTOMER:
                    agg = CommonsUtils.getValue(aggProp.aggs, aggProp);
                    break;
                case AggMethods.COUNT:
                    agg = valueCountAggregation(aggName, aggProp.field);
                    break;
                default:
                    agg = termsAggregation(aggName, aggProp.field).size(aggProp.size || 10);
                    break;
            }
            aggs.push(agg);
        });
        return aggs;
    }
    /**
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    static resolveRequestBody(body, options) {
        if (!body || typeof body === 'string') {
            return body || {};
        }
        if (body instanceof RequestBodySearch) {
            return CommonsUtils.merge({}, body.toJSON() || {}, options.payload || {}, options.body || options.params || {});
        }
        /** @type {?} */
        const _body = Object.assign({}, body);
        if (!CommonsUtils.isEmpty(_body.sort)) {
            /** @type {?} */
            const sorts = EsUtils.resolveSort(_body.sort);
            /** @type {?} */
            const esSorts = [];
            Object.keys(sorts).forEach(key => {
                esSorts.push({ [key]: { order: sorts[key] || Order.ASC, 'unmapped_type': 'string' } });
            });
            _body.sort = esSorts;
        }
        if (_body.size && _body.page) {
            _body.from = _body.page * _body.size;
        }
        if (_body.from && _body.to) {
            _body.size = _body.to - _body.from;
        }
        delete _body.to;
        delete _body.page;
        if (!CommonsUtils.isEmpty(_body.query) ||
            !CommonsUtils.isEmpty(_body.filter)) {
            /** @type {?} */
            let esQuery = {};
            if (!CommonsUtils.isEmpty(_body.query)) {
                if (CommonsUtils.isArray(_body.query)) {
                    _body.query['$and'] = _body.query;
                }
                else {
                    _body.query = EsUtils.parseEsbObject(_body.query);
                }
                /** @type {?} */
                const queryBody = _body.query;
                if (Object.keys(queryBody).length > 0) {
                    Object.keys(queryBody).forEach(key => {
                        if (key === '$and') {
                            /** @type {?} */
                            const must = EsUtils.queryResolver(queryBody, '$and');
                            if (must) {
                                esQuery['must'] = must;
                            }
                        }
                        else if (key === '$or') {
                            /** @type {?} */
                            const should = EsUtils.queryResolver(queryBody, '$or');
                            if (should) {
                                esQuery['should'] = should;
                            }
                        }
                        else if (key === '$not') {
                            /** @type {?} */
                            const must_not = EsUtils.queryResolver(queryBody, '$not');
                            if (must_not) {
                                esQuery['must_not'] = must_not;
                            }
                        }
                        else if (queryBody[key]) {
                            if (esQuery['must']) {
                                esQuery['must'].push({ [key]: queryBody[key] });
                            }
                            else {
                                esQuery['must'] = [{ [key]: queryBody[key] }];
                            }
                        }
                    });
                    esQuery = Object.assign({}, esQuery);
                }
                if (esQuery['should'] && !esQuery['minimum_should_match']) {
                    esQuery['minimum_should_match'] = 1;
                }
            }
            if (!CommonsUtils.isEmpty(_body.filter)) {
                /** @type {?} */
                const filterBody = Object.assign({}, _body.filter);
                esQuery['filter'] = [];
                if (Object.keys(filterBody).length > 0) {
                    Object.keys(filterBody).forEach(key => {
                        if (filterBody[key]) {
                            esQuery['filter'].push({ [key]: filterBody[key] });
                        }
                    });
                }
                if (esQuery['filter'].length === 0) {
                    delete esQuery['filter'];
                }
            }
            if (Object.keys(esQuery).length > 0) {
                _body.query = { bool: esQuery };
            }
        }
        if (!CommonsUtils.isEmpty(_body.aggs)) {
            /** @type {?} */
            const aggs = EsUtils.parseAggProps(_body.aggs);
            if (aggs.length > 0) {
                _body.aggs = requestBodySearch().aggs(aggs).toJSON()['aggs'];
            }
        }
        Object.keys(_body).forEach(k => {
            if (CommonsUtils.isEmpty(_body[k])) {
                delete _body[k];
            }
        });
        return _body;
    }
    /**
     * @param {?} sort
     * @return {?}
     */
    static resolveSort(sort$$1) {
        /** @type {?} */
        let sorts = {};
        if (CommonsUtils.isString(sort$$1)) {
            sorts[(/** @type {?} */ (sort$$1))] = Order.ASC;
        }
        else if (CommonsUtils.isArray(sort$$1)) {
            ((/** @type {?} */ (sort$$1))).forEach(s => {
                if (CommonsUtils.isString(s)) {
                    if (!sorts[s]) {
                        sorts[s] = Order.ASC;
                    }
                }
                else {
                    sorts = Object.assign({}, sorts, (/** @type {?} */ (s)));
                }
            });
        }
        else {
            sorts = (/** @type {?} */ (sort$$1));
        }
        return sorts;
    }
    /**
     * @param {?} qs
     * @return {?}
     */
    static getMsearchBody(qs) {
        /** @type {?} */
        const body = qs.map(q => JSON.stringify(q));
        return body.join('\n') + '\n';
    }
    /**
     * @param {?} ruleSet
     * @return {?}
     */
    static buildQueryRuleSet(ruleSet) {
        ruleSet = (!ruleSet) ? {} : ruleSet;
        return (function parse(data) {
            if (!data['condition']) {
                data['condition'] = DEFAULT_ES_QUERY_CONDITION || DEFAULT_QUERY_CONDITION;
            }
            if (['AND', 'OR'].indexOf(data['condition'].toUpperCase()) === -1) {
                throw new Error('不识别的ElasticSearch bool query 关系(AND,OR) "{0}"'
                    .replace('{0}', data['condition']));
            }
            if (!data['rules']) {
                return {};
            }
            /** @type {?} */
            const parts = {};
            parts['add'] = function (k, v) {
                if (this.hasOwnProperty(k)) {
                    this[k].push(v);
                }
                else {
                    this[k] = [v];
                }
            };
            data['rules'].forEach(function (rule) {
                /** @type {?} */
                const get_value = (aRule) => {
                    if (aRule.data && aRule.data.transform) {
                        return aRule.data.transform.call(this, aRule.value);
                    }
                    else {
                        return aRule.value;
                    }
                };
                /** @type {?} */
                const make_query = (aRule) => {
                    /** @type {?} */
                    const operator = ES_QUERY_OPERATORS[aRule.operator];
                    if (operator === undefined) {
                        throw new Error('不识别的查询操作符 "{0}"'
                            .replace('{0}', aRule.operator));
                    }
                    /** @type {?} */
                    let part = {};
                    if (operator.inputs !== 0) {
                        /** @type {?} */
                        const keyVal = {};
                        /** @type {?} */
                        const valueMapper = operator.getValue;
                        if (valueMapper) {
                            keyVal[aRule.field] = valueMapper(get_value(aRule));
                        }
                        else {
                            keyVal[aRule.field] = get_value(aRule);
                        }
                        part[operator.operator] = keyVal;
                    }
                    if (aRule.operator === 'is_null') {
                        part = { exists: { field: aRule.field } };
                    }
                    if (data['condition'] === 'NOT') {
                        return { 'bool': { 'must_not': [part] } };
                    }
                    else {
                        return part;
                    }
                };
                /** @type {?} */
                let clause;
                if (data['condition'] === 'AND') {
                    clause = 'must';
                }
                if (data['condition'] === 'NOT') {
                    clause = 'must_not';
                }
                if (data['condition'] === 'OR') {
                    clause = 'should';
                }
                if (rule['rules'] && rule['rules'].length > 0) {
                    parts['add'](clause, parse(rule));
                }
                else {
                    parts['add'](clause, make_query(rule));
                }
            });
            delete parts['add'];
            return { 'bool': parts };
        }(ruleSet));
    }
    /**
     * @param {?} aggs
     * @return {?}
     */
    static resolveAggs(aggs) {
        /** @type {?} */
        const resolved = {};
        Object.keys(aggs).forEach(key => {
            /** @type {?} */
            const agg = aggs[key];
            resolved[key] = {};
            Object.keys(agg).forEach(k => {
                if (k === 'buckets') {
                    resolved[key] = EsUtils.resolveBuckets(agg[k]);
                }
                else if (k === 'value') {
                    resolved[key] = agg[k];
                }
            });
        });
        return resolved;
    }
    /**
     * @param {?} buckets
     * @return {?}
     */
    static resolveBuckets(buckets) {
        /** @type {?} */
        const resolved = buckets.map(bucket => EsUtils.resolveBucket(bucket));
        return resolved;
    }
    /**
     * @param {?} bucket
     * @return {?}
     */
    static resolveBucket(bucket) {
        /** @type {?} */
        let resolved = {};
        Object.keys(bucket).forEach(key => {
            if (key === 'key') {
                resolved['label'] = bucket['key'];
            }
            else if (key === 'doc_count') {
                resolved['value'] = bucket['doc_count'];
            }
            else {
                if (CommonsUtils.isJson(bucket[key])) {
                    resolved = Object.assign({}, resolved, EsUtils.resolveAggs({ [key]: bucket[key] }));
                }
                else {
                    resolved[key] = bucket[key];
                }
            }
        });
        return resolved;
    }
    /**
     * @private
     * @param {?} queryBody
     * @param {?} key
     * @return {?}
     */
    static queryResolver(queryBody, key) {
        if (queryBody[key]) {
            /** @type {?} */
            let _qs = queryBody[key].filter(q => !CommonsUtils.isEmpty(q));
            if (_qs.length > 0) {
                _qs = _qs.map(q => EsUtils.parseEsbObject(q));
            }
            return (_qs.length > 0) ? _qs : undefined;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { Utils, BrowserOsUtils, ChartUtils, ColorUtils, CopierUtils, DevicesUtils, DateUtils, DataEntityUtils, ObjectUtils, createDict, copyDict, hasKey, mapValues, union$1 as union, setKey, removeKey, fromKeys, FileUtils, IdCardUtils, FormUtils, ContextUtils, DataItemUtils, CacheUtils, ConfigUtils, DialogUtils, CommonsUtils, StatesUtils, MenuUtils, DomUtils, EncodeUtils, JwtUtils, IdUtils, PinyinUtil, RegUtils, ImageUtil, PagerUtil, TreeUtils, AnnounceUtils, NotifyUtils, RxUtils, UrlUtils, TokenizerUtils, ExtractionResult, FormatStringTokenType, FormatStringToken, FormatStringTokenizer, numToText, EsUtils };

//# sourceMappingURL=er-utils.js.map