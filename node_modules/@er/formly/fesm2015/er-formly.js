import { Subject } from 'rxjs';
import { CommonsUtils, StatesUtils, TreeUtils } from '@er/utils';
import { distinctUntilChanged, map, takeUntil } from 'rxjs/operators';
import { Directive, ViewChild, ViewChildren, ViewContainerRef, ChangeDetectorRef, Component, Input, ANALYZE_FOR_ENTRY_COMPONENTS, Inject, InjectionToken, NgModule, Optional } from '@angular/core';
import { ReactiveFormsModule } from '@angular/forms';
import { PropsBindDirective, ComponentUtils, BaseFormComponent, DataUtils, ErCoreModule } from '@er/core';
import { ValidationMessageDirective, NgValidateMessages, NgValidators, ErValidateModule } from '@er/validate';
import { FieldType, FieldWrapper, FormlyConfig, FormlyModule } from '@ngx-formly/core';
import { TooltipModule } from 'primeng/primeng';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormlyPropsBindDirective extends PropsBindDirective {
    /**
     * @return {?}
     */
    get field() {
        /** @type {?} */
        const viewComponent = this.viewComponentRef;
        if (viewComponent) {
            return viewComponent.field;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.hostComponentInst) {
            this.hostComponentInst['ctx'] = Object.assign({}, this.hostComponentInst['ctx'] || {}, { field: this.field });
            this.hostComponentInst['formlyField'] = this.field;
        }
    }
}
FormlyPropsBindDirective.decorators = [
    { type: Directive, args: [{ selector: '[formlyPropsBind]' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class ErFormlyFieldType extends FieldType {
    /**
     * @return {?}
     */
    get attrs() {
        return this.field['attrs'] || {};
    }
    /**
     * @return {?}
     */
    get props() {
        return this.field['props'] || {};
    }
    /**
     * @return {?}
     */
    get context() {
        return this.field['context'] || {};
    }
    /**
     * @return {?}
     */
    get value() {
        return this.formControl.value;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set value(val) {
        this.formControl.setValue(val);
    }
    /**
     * @param {?=} key
     * @return {?}
     */
    component(key) {
        return this.form['components'] &&
            this.form['components'][key || this.field.key];
    }
    /**
     * @param {?=} key
     * @return {?}
     */
    data$(key) {
        return this.form['components'] &&
            this.form['components'][key || this.field.key] &&
            this.form['components'][key || this.field.key].data$;
    }
    /**
     * @param {?=} key
     * @return {?}
     */
    control(key) {
        return this.form.get(key);
    }
    /**
     * @param {?} key
     * @return {?}
     */
    fieldProps(key) {
        /** @type {?} */
        const props = this.field['formProps'].fields.filter(prop => prop.key === key);
        return (props && props.length === 1) ? props[0] : undefined;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        /** @type {?} */
        const _widgets = this.widgets.toArray();
        /** @type {?} */
        let component;
        if (_widgets.length === 1) {
            component = ComponentUtils.getHostComponentInst(_widgets[0]);
        }
        else if (_widgets.length > 1) {
            component = _widgets.map(widget => ComponentUtils.getHostComponentInst(widget));
        }
        if (this.validateMessage) {
            this.validateMessage.showError = this.showError || true;
        }
        if (!this.form['components']) {
            this.form['components'] = {};
        }
        this.form['components'][this.field.key] = component;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.field['props'] = this.field['props'] || {};
        if (this.defaultProps) {
            this.field['props'] = CommonsUtils.defaults({}, this.field['props'], this.defaultProps);
        }
        this.field['formlyField'] = this;
    }
}
ErFormlyFieldType.propDecorators = {
    widgets: [{ type: ViewChildren, args: [FormlyPropsBindDirective, { read: ViewContainerRef },] }],
    validateMessage: [{ type: ViewChild, args: [ValidationMessageDirective,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class ErFormlyFieldWrapper extends FieldWrapper {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormlyFormComponent extends BaseFormComponent {
    /**
     * @param {?} cd
     */
    constructor(cd) {
        super(cd);
        this.cd = cd;
        this.options = {};
        this.valueChanges$ = new Subject();
    }
    /**
     * @return {?}
     */
    get formlyOptions() {
        return Object.assign({ fieldChanges: this.valueChanges$ }, this.options);
    }
    /**
     * @return {?}
     */
    get submitTips() {
        if (!this.form.valid) {
            /** @type {?} */
            const fields = this.getFormErrorFields();
            /** @type {?} */
            const labels = [];
            fields.forEach(field => {
                /** @type {?} */
                const formlyField = this.formlyField(field);
                if (formlyField) {
                    /** @type {?} */
                    const label = formlyField.templateOptions && formlyField.templateOptions.label || field;
                    labels.push(label.replace(':', ''));
                }
            });
            return `请正确写以下信息️：${labels.join(',')}`;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        /** @type {?} */
        const valueChanges$ = this.options.fieldChanges || this.valueChanges$;
        if (this.valueChanges) {
            this.$subscriptions = valueChanges$.subscribe(event => {
                this.valueChanges(Object.assign({}, event, { formlyForm: this }));
            });
        }
    }
    /**
     * @param {?=} other
     * @return {?}
     */
    getEventContext(other) {
        return super.getEventContext({
            fields: this.fields,
            formOptions: this.options,
            formProps: this.formProps,
            formlyForm: this
        });
    }
    /**
     * @param {?} key
     * @return {?}
     */
    formlyField(key) {
        /** @type {?} */
        const props = this.fields.filter(prop => prop.key === key);
        return (props && props.length === 1) ? props[0] : undefined;
    }
}
FormlyFormComponent.decorators = [
    { type: Component, args: [{
                selector: 'er-formly-form',
                template: "<div [ngClass]=\"styleClass\" [ngStyle]=\"style\">\n  <ng-container *ngIf=\"header\">\n    <er-dyna-content [content]=\"header\"></er-dyna-content>\n  </ng-container>\n  <ng-container *ngIf=\"template(templateNames.header)\">\n    <ng-container *ngTemplateOutlet=\"template(templateNames.header);\n                                     context: getEventContext()\"></ng-container>\n  </ng-container>\n\n  <form [formGroup]=\"form\" [ngClass]=\"formStyleClass || 'mt-2'\" [ngStyle]=\"formStyle\" novalidate>\n    <formly-form [form]=\"form\"\n                 [options]=\"formlyOptions\"\n                 [(model)]=\"model\"\n                 [fields]=\"fields\"\n                 class=\"formly-form\">\n      <ng-content></ng-content>\n      <ng-container *ngTemplateOutlet=\"template(templateNames.buttons,default)\"></ng-container>\n    </formly-form>\n  </form>\n  <ng-container *ngIf=\"footer\">\n    <er-dyna-content [content]=\"footer\"></er-dyna-content>\n  </ng-container>\n  <ng-container *ngIf=\"template(templateNames.footer)\">\n    <ng-container *ngTemplateOutlet=\"template(templateNames.footer);\n                                     context: getEventContext()\"></ng-container>\n  </ng-container>\n</div>\n\n<ng-template #default>\n  <div [ngClass]=\"buttonsStyleClass\">\n    <er-button [stateKey]=\"formId\"\n               icon=\"fa fa-save\"\n               label=\"\u63D0&nbsp;&nbsp;&nbsp;\u4EA4\"\n               title=\"\u4FDD\u7559\u6570\u636E\u5230\u670D\u52A1\u7AEF\"\n               class=\"mr-2\"\n               type=\"button\"\n               [pTooltip]=\"submitTips\"\n               tooltipPosition=\"top\"\n               [tooltipDisabled]=\"form.valid\"\n               [disabled]=\"!form.valid\"\n               (onClick)=\"submit()\"\n               [styleClass]=\"submitBtnStyleClass\"\n    ></er-button>\n    <er-button icon=\"fa fa-circle-o\"\n               class=\"mr-2\"\n               label=\"\u91CD&nbsp;&nbsp;&nbsp;\u586B\"\n               title=\"\u6062\u590D\u5230\u4FEE\u6539\u524D\u7684\u72B6\u6001\"\n               [styleClass]=\"resetBtnStyleClass\"\n               (onClick)=\"resetModel()\">\n    </er-button>\n\n    <ng-container *ngFor=\"let btn of buttons\">\n      <er-button class=\"mr-2\" erPropsBind [props]=\"btn\" [context]=\"getEventContext(btn.context)\"></er-button>\n    </ng-container>\n\n  </div>\n</ng-template>\n"
            }] }
];
/** @nocollapse */
FormlyFormComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
FormlyFormComponent.propDecorators = {
    fields: [{ type: Input }],
    options: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const Components = [
    FormlyFormComponent
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DynamicWrapperComponent extends FieldWrapper {
}
DynamicWrapperComponent.decorators = [
    { type: Component, args: [{
                template: `
    <ng-container *ngIf="to['before']">
      <ng-container *ngTemplateOutlet="content"></ng-container>
    </ng-container>
    <ng-container #fieldComponent></ng-container>
    <ng-container *ngIf="to['after']">
      <ng-container *ngTemplateOutlet="content"></ng-container>
    </ng-container>
    <ng-template #content>
      <er-dyna-content [content]="to['content']"
                       [context]="to['context']"
                       [styleClass]="to['styleClass']"
                       [style]="to['style']"
      ></er-dyna-content>
    </ng-template>
  `
            }] }
];
DynamicWrapperComponent.propDecorators = {
    fieldComponent: [{ type: ViewChild, args: ['fieldComponent', { read: ViewContainerRef },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HorizontalWrapperComponent extends FieldWrapper {
}
HorizontalWrapperComponent.decorators = [
    { type: Component, args: [{
                template: `
    <div class="form-group row">
      <label [attr.for]="id" class="col-sm-2 col-form-label" *ngIf="to.label">
        <span [innerHTML]="to.label"></span>
        <span *ngIf="to.required && to['hideRequiredMarker'] !== true" class="red">*</span>
      </label>
      <div class="col-sm-10">
      
        <ng-container *ngIf="to['before'] && to['before'].content">
          <er-dyna-content [content]="to['before'].content" [context]="to['before'].context"></er-dyna-content>
        </ng-container>
        
        <ng-template #fieldComponent></ng-template>

        <div *ngIf="showError" class="invalid-feedback" [style.display]="'block'">
          <er-validate-messages [formlyField]="field"></er-validate-messages>
        </div>

        <small *ngIf="to.description" class="form-text text-muted">
          <i class="text-primary fa fa-info-circle"></i>
          <span [innerHTML]="to.description"></span>
        </small>
        
        <ng-container *ngIf="to['after'] && to['after'].content">
          <er-dyna-content [content]="to['after'].content" [context]="to['after'].context"></er-dyna-content>
        </ng-container>
      
      </div>
    </div>
  `
            }] }
];
HorizontalWrapperComponent.propDecorators = {
    fieldComponent: [{ type: ViewChild, args: ['fieldComponent', { read: ViewContainerRef },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PanelWrapperComponent extends FieldWrapper {
}
PanelWrapperComponent.decorators = [
    { type: Component, args: [{
                template: `
    <div class="card">
      <h3 class="card-header"><i [ngClass]="to['icon']"></i> <span [innerHTML]="to['header']|erSafeHtml"></span></h3>
      <div class="card-body">
        <div *ngIf="to['before']" class="card-before">
          <er-dyna-content [content]="to['before']" [context]="model"></er-dyna-content>
        </div>
        <ng-container #fieldComponent></ng-container>
        <div *ngIf="to['after']" class="card-after">
          <er-dyna-content [content]="to['after']" [context]="model"></er-dyna-content>
        </div>
      </div>
      <div *ngIf="to['footer']" class="card-footer"><span [innerHTML]="to['footer']|erSafeHtml"></span> </div>
    </div>
  `
            }] }
];
PanelWrapperComponent.propDecorators = {
    fieldComponent: [{ type: ViewChild, args: ['fieldComponent', { read: ViewContainerRef },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class VerticalWrapperComponent extends FieldWrapper {
}
VerticalWrapperComponent.decorators = [
    { type: Component, args: [{
                template: `
    <div class="form-group" [class.has-error]="showError">
      <label *ngIf="to.label && to['hideLabel'] !== true" [attr.for]="id">
       <span *ngIf="to.required && to['hideRequiredMarker'] !== true" style="color: red">*</span> {{ to.label }}
      </label>
     
      <ng-container *ngIf="to['before'] && to['before'].content">
        <er-dyna-content [content]="to['before'].content" [context]="to['before'].context"></er-dyna-content>
      </ng-container>
    
      <ng-template #fieldComponent></ng-template>
      
      <div *ngIf="showError" class="invalid-feedback" [style.display]="'block'">
        <er-validate-messages [formlyField]="field"></er-validate-messages>
      </div>

      <small *ngIf="to.description" class="form-text text-muted">
        <i class="text-primary fa fa-info-circle"></i> {{ to.description }}
      </small>

      <ng-container *ngIf="to['after'] && to['after'].content">
        <er-dyna-content [content]="to['after'].content" [context]="to['after'].context"></er-dyna-content>
      </ng-container>
      
    </div>
  `
            }] }
];
VerticalWrapperComponent.propDecorators = {
    fieldComponent: [{ type: ViewChild, args: ['fieldComponent', { read: ViewContainerRef },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const FORMLY_WRAPPER_COMPONENTS = [
    VerticalWrapperComponent,
    HorizontalWrapperComponent,
    PanelWrapperComponent,
    DynamicWrapperComponent
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const FormlyTypes = {
    array: 'array',
    group: 'group',
    dynamic: 'dynamic',
    value: 'value'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const FormlyWrappers = {
    vertical: 'vertical',
    horizontal: 'horizontal',
    panel: 'panel',
    tab: 'tab',
    dynamic: 'dynamic',
    collapse: 'collapse',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const FORMLY_VALIDATORS = [
    // {name: 'async', validation: NgAsyncValidator},
    { name: 'letter', validation: NgValidators.letter },
    { name: 'digit', validation: NgValidators.digit },
    { name: 'character', validation: NgValidators.character },
    { name: 'chinese', validation: NgValidators.chinese },
    { name: 'integer', validation: NgValidators.integer },
    { name: 'numeric', validation: NgValidators.numeric },
    { name: 'full', validation: NgValidators.fullWidth },
    { name: 'half', validation: NgValidators.halfWidth },
    { name: 'phone', validation: NgValidators.phone },
    { name: 'idCard', validation: NgValidators.idCard },
    { name: 'match', validation: NgValidators.match },
    { name: 'required', validation: NgValidators.required },
    { name: 'accept', validation: NgValidators.accept },
    { name: 'email', validation: NgValidators.email },
    { name: 'url', validation: NgValidators.url },
    { name: 'date', validation: NgValidators.date },
    { name: 'json', validation: NgValidators.json },
    { name: 'base64', validation: NgValidators.base64 },
    { name: 'creditCard', validation: NgValidators.creditCard },
    { name: 'password', validation: NgValidators.password },
    { name: 'after', validation: NgValidators.after },
    { name: 'before', validation: NgValidators.before },
    { name: 'between', validation: NgValidators.between },
    { name: 'dateFormat', validation: NgValidators.dateFormat },
    { name: 'age', validation: NgValidators.age },
    { name: 'equalTo', validation: NgValidators.equalTo },
    { name: 'notEqualTo', validation: NgValidators.notEqualTo },
    { name: 'minLength', validation: NgValidators.minLength },
    { name: 'maxLength', validation: NgValidators.maxLength },
    { name: 'min', validation: NgValidators.min },
    { name: 'max', validation: NgValidators.max },
    { name: 'pattern', validation: NgValidators.pattern },
    { name: 'rangeLength', validation: NgValidators.rangeLength },
    { name: 'range', validation: NgValidators.range },
    { name: 'gt', validation: NgValidators.gt },
    { name: 'gte', validation: NgValidators.gte },
    { name: 'lt', validation: NgValidators.lt },
    { name: 'lte', validation: NgValidators.lte },
    { name: 'minDate', validation: NgValidators.minDate },
    { name: 'maxDate', validation: NgValidators.maxDate },
    { name: 'equal', validation: NgValidators.equal },
    { name: 'notEqual', validation: NgValidators.notEqual },
    { name: 'equalTo2', validation: NgValidators.equalTo2 },
    { name: 'notEqualTo2', validation: NgValidators.notEqualTo2 }
];
/** @type {?} */
const FORMLY_VALIDATION_MESSAGES = [
    { name: 'required', message: NgValidateMessages.required },
    { name: 'maxlength', message: NgValidateMessages.maxlength },
    { name: 'minlength', message: NgValidateMessages.minlength },
    { name: 'min', message: NgValidateMessages.min },
    { name: 'max', message: NgValidateMessages.max },
    { name: 'pattern', message: NgValidateMessages.pattern },
    { name: 'letter', message: NgValidateMessages.letter },
    { name: 'digit', message: NgValidateMessages.digit },
    { name: 'character', message: NgValidateMessages.character },
    { name: 'chinese', message: NgValidateMessages.chinese },
    { name: 'integer', message: NgValidateMessages.integer },
    { name: 'number', message: NgValidateMessages.number },
    { name: 'full', message: NgValidateMessages.fullWidth },
    { name: 'half', message: NgValidateMessages.halfWidth },
    { name: 'phone', message: NgValidateMessages.phone },
    { name: 'idCard', message: NgValidateMessages.idCard },
    { name: 'age', message: NgValidateMessages.age },
    { name: 'password', message: NgValidateMessages.password },
    { name: 'dateBefore', message: NgValidateMessages.dateBefore },
    { name: 'dateAfter', message: NgValidateMessages.dateAfter },
    { name: 'dataBetween', message: NgValidateMessages.dataBetween },
    { name: 'condition', message: NgValidateMessages.condition },
    { name: 'email', message: NgValidateMessages.email },
    { name: 'not_matching', message: NgValidateMessages.not_matching },
    { name: 'unique', message: NgValidateMessages.unique },
    { name: 'rangeLength', message: NgValidateMessages.rangeLength },
    { name: 'gt', message: NgValidateMessages.gt },
    { name: 'gte', message: NgValidateMessages.gte },
    { name: 'lt', message: NgValidateMessages.lt },
    { name: 'lte', message: NgValidateMessages.lte },
    { name: 'lte', message: NgValidateMessages.lte },
    { name: 'range', message: NgValidateMessages.range },
    { name: 'url', message: NgValidateMessages.url },
    { name: 'date', message: NgValidateMessages.date },
    { name: 'minDate', message: NgValidateMessages.minDate },
    { name: 'maxDate', message: NgValidateMessages.maxDate },
    { name: 'json', message: NgValidateMessages.json },
    { name: 'base64', message: NgValidateMessages.base64 },
    { name: 'equal', message: NgValidateMessages.equal },
    { name: 'notEqual', message: NgValidateMessages.notEqual },
    { name: 'equalTo', message: NgValidateMessages.equalTo },
    { name: 'notEqualTo', message: NgValidateMessages.notEqualTo }
];
/** @type {?} */
const ER_FORMLY_CONFIG = {
    wrappers: [
        { name: FormlyWrappers.vertical, component: VerticalWrapperComponent },
        { name: FormlyWrappers.horizontal, component: HorizontalWrapperComponent },
        { name: FormlyWrappers.panel, component: PanelWrapperComponent },
        { name: FormlyWrappers.dynamic, component: DynamicWrapperComponent }
    ],
    validators: FORMLY_VALIDATORS,
    validationMessages: FORMLY_VALIDATION_MESSAGES
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormlyUtils {
    /**
     * @param {?} ctx
     * @param {?} entity
     * @param {?=} nextSeqProps
     * @return {?}
     */
    static resolveDistinctFieldValue(ctx, entity, nextSeqProps) {
        console.log(ctx);
        /** @type {?} */
        let fieldName = 'code';
        if (nextSeqProps) {
            fieldName = nextSeqProps.seqKey || 'code';
        }
        /** @type {?} */
        const currentValue = ctx.model[fieldName];
        if (!currentValue) {
            return DataUtils.getNextValue(Object.assign({}, nextSeqProps || {}, { apiEntry: entity.apiEntry })).pipe(map(result => {
                ctx.model[fieldName] = result;
                return true;
            }));
        }
        else {
            return DataUtils.checkDistinct({
                apiProps: {
                    apiEntry: entity.apiEntry,
                    query: nextSeqProps && nextSeqProps.query,
                    searchFields: fieldName,
                    queryValue: currentValue
                },
                id: ctx.model['id']
            });
        }
    }
    /**
     * @param {?} formlyForm
     * @param {?} fieldName
     * @param {?=} valueResolver
     * @return {?}
     */
    static initFieldValueFromSelectedTreeNode(formlyForm, fieldName, valueResolver) {
        /** @type {?} */
        const fieldValue = formlyForm.model && formlyForm.model[fieldName];
        if (!fieldValue) {
            /** @type {?} */
            const node = TreeUtils.getSelectedNode(formlyForm && formlyForm['tableId']);
            if (node) {
                /** @type {?} */
                let val;
                if (valueResolver) {
                    val = valueResolver(node);
                }
                else {
                    val = { code: node['code'], name: node['name'] };
                }
                formlyForm.patchModel({ [fieldName]: val });
            }
        }
    }
    /**
     * @param {?} formlyForm
     * @param {?} fieldName
     * @return {?}
     */
    static onFieldChange(formlyForm, fieldName) {
        return formlyForm.formControl(fieldName).valueChanges
            .pipe(takeUntil(formlyForm.destroyed$), distinctUntilChanged());
    }
    /**
     * @param {?} ctx
     * @return {?}
     */
    static refreshContainerNavTree(ctx) {
        /** @type {?} */
        const tableId = ctx.formlyForm.tableId;
        if (tableId) {
            /** @type {?} */
            const table = tableId && StatesUtils.getValue(tableId);
            if (table && table.component) {
                /** @type {?} */
                const container = table.component.$container;
                container.refreshTree = true;
            }
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const Directives = [
    FormlyPropsBindDirective
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormlyFieldValidatorExtension {
    /**
     * @param {?} field
     * @return {?}
     */
    onPopulate(field) {
        // console.log('FormlyFieldValidatorExtension');
        // this.initFieldValidation(field);
        // this.initFieldAsyncValidation(field);
    }
    /**
     * @private
     * @param {?} field
     * @return {?}
     */
    initFieldValidation(field) {
        if (field.validators) {
            return;
        }
        this.initPredefinedFieldValidation(field);
        if (field.validators) {
            for (const validatorName in field.validators) {
                if (validatorName !== 'validation') {
                    /** @type {?} */
                    let validator = field.validators[validatorName];
                    /** @type {?} */
                    let errorPath;
                    /** @type {?} */
                    let message;
                    if (validator && typeof validator === 'object') {
                        errorPath = validator.errorPath;
                        message = validator.message;
                        validator = validator.expression;
                    }
                    field.validators.push((control) => {
                        /** @type {?} */
                        const isValid = validator(control, field);
                        if (errorPath && field.formControl && field.formControl.get(errorPath)) {
                            if (!isValid) {
                                field.formControl.get(errorPath).setErrors(Object.assign({}, (field.formControl.get(errorPath).errors || {}), { [validatorName]: { message } }));
                            }
                            else {
                                /** @type {?} */
                                const errors = (field.formControl.get(errorPath).errors || {});
                                delete errors[validatorName];
                                field.formControl.get(errorPath).setErrors(Object.keys(errors).length === 0 ? null : errors);
                            }
                        }
                        return isValid ? null : { [validatorName]: errorPath ? { errorPath } : true };
                    });
                }
                else {
                    if (!Array.isArray(field.validators.validation)) {
                        field.validators.validation = [field.validators.validation];
                    }
                    // field.validators.validation
                    //   .forEach((validator: any) => field._validators.push(this.wrapNgValidatorFn(field, validator)));
                }
            }
        }
    }
    /**
     * @private
     * @param {?} field
     * @return {?}
     */
    initFieldAsyncValidation(field) {
        if (field.asyncValidators) {
            return;
        }
        if (field.asyncValidators) ;
    }
    /**
     * @private
     * @param {?} field
     * @return {?}
     */
    initPredefinedFieldValidation(field) {
        // const attr = '';
        //
        //   switch (attr) {
        //     case 'required':
        //       return Validators.required(control);
        //     case 'pattern':
        //       return Validators.pattern(value)(control);
        //     case 'minLength':
        //       return Validators.minLength(value)(control);
        //     case 'maxLength':
        //       return Validators.maxLength(value)(control);
        //     case 'min':
        //       return Validators.min(value)(control);
        //     case 'max':
        //       return Validators.max(value)(control);
        //   }
        //
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const Pipes = [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const Er_FORMLY_CONFIG = new InjectionToken('Er_FORMLY_CONFIG');
class ErFormlyModule {
}
ErFormlyModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    ReactiveFormsModule,
                    FormlyModule,
                    ErCoreModule,
                    ErValidateModule,
                    TooltipModule
                ],
                declarations: [
                    ...Components,
                    ...Directives,
                    ...Pipes
                ],
                exports: [
                    ...Components,
                    ...Directives,
                    ...Pipes
                ]
            },] }
];
class ErFormlyRootModule {
    /**
     * @param {?} formlyConfig
     * @param {?} erFormlyConfigOption
     */
    constructor(formlyConfig, erFormlyConfigOption) {
        if (erFormlyConfigOption) {
            formlyConfig.addConfig(erFormlyConfigOption);
        }
        if (formlyConfig.extensions.hasOwnProperty('field-validation')) ;
        if (formlyConfig.extensions.hasOwnProperty('field-expression')) ;
        formlyConfig.addConfig({
            extensions: [
                { name: 'validator', extension: new FormlyFieldValidatorExtension }
            ]
        });
    }
    /**
     * @param {?=} config
     * @return {?}
     */
    static forRoot(config = {}) {
        return {
            ngModule: ErFormlyRootModule,
            providers: [
                { provide: Er_FORMLY_CONFIG, useValue: config, multi: true },
                { provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: config, multi: true }
            ]
        };
    }
}
ErFormlyRootModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    ReactiveFormsModule,
                    ErCoreModule,
                    ErValidateModule,
                    FormlyModule.forRoot(ER_FORMLY_CONFIG)
                ],
                declarations: [
                    ...FORMLY_WRAPPER_COMPONENTS
                ]
            },] }
];
/** @nocollapse */
ErFormlyRootModule.ctorParameters = () => [
    { type: FormlyConfig },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [Er_FORMLY_CONFIG,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { ErFormlyModule, ErFormlyRootModule, ErFormlyFieldType, ErFormlyFieldWrapper, FormlyFormComponent, Components, FORMLY_WRAPPER_COMPONENTS, DynamicWrapperComponent, HorizontalWrapperComponent, PanelWrapperComponent, VerticalWrapperComponent, FormlyTypes, FormlyWrappers, ER_FORMLY_CONFIG, FormlyUtils, Directives as ɵc, FormlyPropsBindDirective as ɵb, Er_FORMLY_CONFIG as ɵa, Pipes as ɵd };

//# sourceMappingURL=er-formly.js.map