/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, Input, Optional, TemplateRef } from '@angular/core';
import { ControlContainer, FormControl } from '@angular/forms';
import { FormUtils } from '@er/utils';
import { BehaviorSubject } from 'rxjs/internal/BehaviorSubject';
import { ValidateUtils } from '../../utils';
export class ValidateMessagesComponent {
    /**
     * @param {?} controlContainer
     * @param {?} cd
     */
    constructor(controlContainer, cd) {
        this.controlContainer = controlContainer;
        this.cd = cd;
        this.showAllErrors = true;
        this.errors$ = new BehaviorSubject(undefined);
    }
    /**
     * @return {?}
     */
    getErrorMessages() {
        if (this.control.dirty && this.control.invalid) {
            /** @type {?} */
            const errorMessages = ValidateUtils.getErrorMessage(this.control.errors);
            /** @type {?} */
            const errors = this.showAllErrors ? errorMessages : this.getFirstError(errorMessages);
            this.errors$.next(this.getErrors(errors));
        }
        else {
            return this.errors$.next([]);
        }
    }
    /**
     * @param {?} errorMessages
     * @return {?}
     */
    getFirstError(errorMessages) {
        if (Object.keys(errorMessages).length > 0) {
            return errorMessages[Object.keys(errorMessages)[0]];
        }
        return '校验失败';
    }
    /**
     * @param {?} errorMessages
     * @return {?}
     */
    getErrors(errorMessages) {
        /** @type {?} */
        const lst = [];
        if (errorMessages) {
            Object.keys(errorMessages).map(key => {
                lst.push({ key, value: (this.messages && this.messages[key]) || errorMessages[key] });
            });
        }
        return lst;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.control) {
            if (this.formlyField) {
                this.control = this.formlyField.formControl;
            }
            if (!this.control && this.controlContainer) {
                /** @type {?} */
                const form = this.controlContainer.formDirective ? ((/** @type {?} */ (this.controlContainer.formDirective))).form : null;
                if (form) {
                    this.control = FormUtils.getFormControl(form, ...this.controlContainer.path, this.controlName);
                }
            }
        }
        if (this.control) {
            this.subscription = this.control.statusChanges.subscribe(() => {
                this.getErrorMessages();
            });
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
}
ValidateMessagesComponent.decorators = [
    { type: Component, args: [{
                selector: 'er-validate-messages',
                template: `
    <div *ngIf="errors$|async as errors">
      <ng-container *ngTemplateOutlet="errorMsgTpl?errorMsgTpl:defaultTpl;context:{$implicit:errors}"></ng-container>
    </div>
    <ng-template #defaultTpl let-errors>
      <div class="text-danger" [ngClass]="styleClass">
        <ul *ngFor="let error of errors " class="d-flex flex-column justify-content-start">
          <li [innerHTML]="error.value" class="my-1" style="font-size: 0.8em"></li>
        </ul>
      </div>
    </ng-template>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
ValidateMessagesComponent.ctorParameters = () => [
    { type: ControlContainer, decorators: [{ type: Optional }] },
    { type: ChangeDetectorRef }
];
ValidateMessagesComponent.propDecorators = {
    control: [{ type: Input }],
    controlName: [{ type: Input }],
    formlyField: [{ type: Input }],
    force: [{ type: Input }],
    styleClass: [{ type: Input }],
    showAllErrors: [{ type: Input }],
    messages: [{ type: Input }],
    errorMsgTpl: [{ type: ContentChild, args: [TemplateRef,] }]
};
if (false) {
    /** @type {?} */
    ValidateMessagesComponent.prototype.control;
    /** @type {?} */
    ValidateMessagesComponent.prototype.controlName;
    /** @type {?} */
    ValidateMessagesComponent.prototype.formlyField;
    /** @type {?} */
    ValidateMessagesComponent.prototype.force;
    /** @type {?} */
    ValidateMessagesComponent.prototype.styleClass;
    /** @type {?} */
    ValidateMessagesComponent.prototype.showAllErrors;
    /** @type {?} */
    ValidateMessagesComponent.prototype.messages;
    /** @type {?} */
    ValidateMessagesComponent.prototype.errorMsgTpl;
    /** @type {?} */
    ValidateMessagesComponent.prototype.errors$;
    /** @type {?} */
    ValidateMessagesComponent.prototype.subscription;
    /**
     * @type {?}
     * @private
     */
    ValidateMessagesComponent.prototype.controlContainer;
    /**
     * @type {?}
     * @private
     */
    ValidateMessagesComponent.prototype.cd;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGVyL3ZhbGlkYXRlLyIsInNvdXJjZXMiOlsibGliL2NvbXBvbmVudHMvY29udHJvbC9jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFDTCx1QkFBdUIsRUFDdkIsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxZQUFZLEVBQ1osS0FBSyxFQUdMLFFBQVEsRUFDUixXQUFXLEVBQ1osTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFDLGdCQUFnQixFQUFFLFdBQVcsRUFBcUIsTUFBTSxnQkFBZ0IsQ0FBQztBQUNqRixPQUFPLEVBQUMsU0FBUyxFQUFDLE1BQU0sV0FBVyxDQUFDO0FBRXBDLE9BQU8sRUFBQyxlQUFlLEVBQUMsTUFBTSwrQkFBK0IsQ0FBQztBQUM5RCxPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0sYUFBYSxDQUFDO0FBbUIxQyxNQUFNLE9BQU8seUJBQXlCOzs7OztJQXNCcEMsWUFBZ0MsZ0JBQWtDLEVBQVUsRUFBcUI7UUFBakUscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFrQjtRQUFVLE9BQUUsR0FBRixFQUFFLENBQW1CO1FBVnhGLGtCQUFhLEdBQUcsSUFBSSxDQUFDO1FBTTlCLFlBQU8sR0FBOEIsSUFBSSxlQUFlLENBQVcsU0FBUyxDQUFDLENBQUM7SUFLOUUsQ0FBQzs7OztJQUVELGdCQUFnQjtRQUNkLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUU7O2tCQUN4QyxhQUFhLEdBQUcsYUFBYSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQzs7a0JBQ2xFLE1BQU0sR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUFDO1lBQ3JGLElBQUksQ0FB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SUFFOUIsNkNBQTZDOztJQUU3QyxnREFBeUQ7O0lBRXpELDRDQUE4RTs7SUFFOUUsaURBQTJCOzs7OztJQUVmLHFEQUFzRDs7Ozs7SUFBRSx1Q0FBNkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIENvbXBvbmVudCxcbiAgQ29udGVudENoaWxkLFxuICBJbnB1dCxcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIE9wdGlvbmFsLFxuICBUZW1wbGF0ZVJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29udHJvbENvbnRhaW5lciwgRm9ybUNvbnRyb2wsIEZvcm1Hcm91cERpcmVjdGl2ZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtGb3JtVXRpbHN9IGZyb20gJ0Blci91dGlscyc7XG5pbXBvcnQge1N1YnNjcmlwdGlvbn0gZnJvbSAncnhqcyc7XG5pbXBvcnQge0JlaGF2aW9yU3ViamVjdH0gZnJvbSAncnhqcy9pbnRlcm5hbC9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHtWYWxpZGF0ZVV0aWxzfSBmcm9tICcuLi8uLi91dGlscyc7XG5cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnZXItdmFsaWRhdGUtbWVzc2FnZXMnLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxkaXYgKm5nSWY9XCJlcnJvcnMkfGFzeW5jIGFzIGVycm9yc1wiPlxuICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImVycm9yTXNnVHBsP2Vycm9yTXNnVHBsOmRlZmF1bHRUcGw7Y29udGV4dDp7JGltcGxpY2l0OmVycm9yc31cIj48L25nLWNvbnRhaW5lcj5cbiAgICA8L2Rpdj5cbiAgICA8bmctdGVtcGxhdGUgI2RlZmF1bHRUcGwgbGV0LWVycm9ycz5cbiAgICAgIDxkaXYgY2xhc3M9XCJ0ZXh0LWRhbmdlclwiIFtuZ0NsYXNzXT1cInN0eWxlQ2xhc3NcIj5cbiAgICAgICAgPHVsICpuZ0Zvcj1cImxldCBlcnJvciBvZiBlcnJvcnMgXCIgY2xhc3M9XCJkLWZsZXggZmxleC1jb2x1bW4ganVzdGlmeS1jb250ZW50LXN0YXJ0XCI+XG4gICAgICAgICAgPGxpIFtpbm5lckhUTUxdPVwiZXJyb3IudmFsdWVcIiBjbGFzcz1cIm15LTFcIiBzdHlsZT1cImZvbnQtc2l6ZTogMC44ZW1cIj48L2xpPlxuICAgICAgICA8L3VsPlxuICAgICAgPC9kaXY+XG4gICAgPC9uZy10ZW1wbGF0ZT5cbiAgYCxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgVmFsaWRhdGVNZXNzYWdlc0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcblxuICBASW5wdXQoKSBjb250cm9sOiBGb3JtQ29udHJvbDtcblxuICBASW5wdXQoKSBjb250cm9sTmFtZTogc3RyaW5nO1xuXG4gIEBJbnB1dCgpIGZvcm1seUZpZWxkOiBhbnk7XG5cbiAgQElucHV0KCkgZm9yY2U6IGJvb2xlYW47XG5cbiAgQElucHV0KCkgc3R5bGVDbGFzczogc3RyaW5nO1xuXG4gIEBJbnB1dCgpIHNob3dBbGxFcnJvcnMgPSB0cnVlO1xuXG4gIEBJbnB1dCgpIG1lc3NhZ2VzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuXG4gIEBDb250ZW50Q2hpbGQoVGVtcGxhdGVSZWYpIGVycm9yTXNnVHBsOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gIGVycm9ycyQ6IEJlaGF2aW9yU3ViamVjdDxzdHJpbmdbXT4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PHN0cmluZ1tdPih1bmRlZmluZWQpO1xuXG4gIHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIHByaXZhdGUgY29udHJvbENvbnRhaW5lcjogQ29udHJvbENvbnRhaW5lciwgcHJpdmF0ZSBjZDogQ2hhbmdlRGV0ZWN0b3JSZWYpIHtcbiAgfVxuXG4gIGdldEVycm9yTWVzc2FnZXMoKSB7XG4gICAgaWYgKHRoaXMuY29udHJvbC5kaXJ0eSAmJiB0aGlzLmNvbnRyb2wuaW52YWxpZCkge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlcyA9IFZhbGlkYXRlVXRpbHMuZ2V0RXJyb3JNZXNzYWdlKHRoaXMuY29udHJvbC5lcnJvcnMpO1xuICAgICAgY29uc3QgZXJyb3JzID0gdGhpcy5zaG93QWxsRXJyb3JzID8gZXJyb3JNZXNzYWdlcyA6IHRoaXMuZ2V0Rmlyc3RFcnJvcihlcnJvck1lc3NhZ2VzKTtcbiAgICAgIHRoaXMuZXJyb3JzJC5uZXh0KHRoaXMuZ2V0RXJyb3JzKGVycm9ycykpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5lcnJvcnMkLm5leHQoW10pO1xuICAgIH1cbiAgfVxuXG4gIGdldEZpcnN0RXJyb3IoZXJyb3JNZXNzYWdlcykge1xuICAgIGlmIChPYmplY3Qua2V5cyhlcnJvck1lc3NhZ2VzKS5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gZXJyb3JNZXNzYWdlc1tPYmplY3Qua2V5cyhlcnJvck1lc3NhZ2VzKVswXV07XG4gICAgfVxuICAgIHJldHVybiAn5qCh6aqM5aSx6LSlJztcbiAgfVxuXG4gIGdldEVycm9ycyhlcnJvck1lc3NhZ2VzKSB7XG4gICAgY29uc3QgbHN0ID0gW107XG4gICAgaWYgKGVycm9yTWVzc2FnZXMpIHtcbiAgICAgIE9iamVjdC5rZXlzKGVycm9yTWVzc2FnZXMpLm1hcChrZXkgPT4ge1xuICAgICAgICBsc3QucHVzaCh7a2V5LCB2YWx1ZTogKHRoaXMubWVzc2FnZXMgJiYgdGhpcy5tZXNzYWdlc1trZXldKSB8fCBlcnJvck1lc3NhZ2VzW2tleV19KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbHN0O1xuICB9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmNvbnRyb2wpIHtcbiAgICAgIGlmICh0aGlzLmZvcm1seUZpZWxkKSB7XG4gICAgICAgIHRoaXMuY29udHJvbCA9IHRoaXMuZm9ybWx5RmllbGQuZm9ybUNvbnRyb2w7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuY29udHJvbCAmJiB0aGlzLmNvbnRyb2xDb250YWluZXIpIHtcbiAgICAgICAgY29uc3QgZm9ybSA9IHRoaXMuY29udHJvbENvbnRhaW5lci5mb3JtRGlyZWN0aXZlID8gKHRoaXMuY29udHJvbENvbnRhaW5lci5mb3JtRGlyZWN0aXZlIGFzIEZvcm1Hcm91cERpcmVjdGl2ZSkuZm9ybSA6IG51bGw7XG4gICAgICAgIGlmIChmb3JtKSB7XG4gICAgICAgICAgdGhpcy5jb250cm9sID0gRm9ybVV0aWxzLmdldEZvcm1Db250cm9sKGZvcm0sIC4uLnRoaXMuY29udHJvbENvbnRhaW5lci5wYXRoLCB0aGlzLmNvbnRyb2xOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5jb250cm9sKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IHRoaXMuY29udHJvbC5zdGF0dXNDaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuZ2V0RXJyb3JNZXNzYWdlcygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxufVxuIl19