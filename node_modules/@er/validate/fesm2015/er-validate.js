import { RegPatterns } from '@er/types';
import { Subject } from 'rxjs';
import { BehaviorSubject } from 'rxjs/internal/BehaviorSubject';
import { CommonsUtils, DateUtils, FormUtils, RegUtils, IdCardUtils, CacheUtils } from '@er/utils';
import { CommonModule } from '@angular/common';
import { ChangeDetectionStrategy, Component, ContentChild, Input, Optional, TemplateRef, ChangeDetectorRef, Directive, HostListener, ComponentFactoryResolver, HostBinding, ViewContainerRef, NgModule } from '@angular/core';
import { FormGroup, Validators, FormArray, FormControl, ControlContainer, NgControl, FormsModule, ReactiveFormsModule } from '@angular/forms';
import { CustomValidators, CustomFormsModule } from 'ng2-validation';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const dateAfterValidator = function (after) {
    /** @type {?} */
    const fn = (control) => {
        /** @type {?} */
        const value = control.value;
        if (!DateUtils.isDate(value)) {
            return { 'dateAfter': { message: '错误的日期格式', value } };
        }
        /** @type {?} */
        const isAfter = CommonsUtils.isAfter(value, after);
        return isAfter ? null : { 'dateAfter': { value, after } };
    };
    return fn;
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ageValidator = function (min, max) {
    /** @type {?} */
    const fn = (control) => {
        /** @type {?} */
        const value = control.value;
        if (!value) {
            return null;
        }
        if (!DateUtils.isDate(value)) {
            return { 'age': { message: '错误的日期格式', value } };
        }
        /** @type {?} */
        const age = CommonsUtils.getAge(value);
        /** @type {?} */
        const isInValid = (min > 0 && age < min) || (max > 0 && age > max);
        return isInValid ? null : { 'age': { min, max, value } };
    };
    return fn;
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const dateBeforeValidator = function (before) {
    /** @type {?} */
    const fn = (control) => {
        /** @type {?} */
        const value = control.value;
        if (!DateUtils.isDate(value)) {
            return { 'dataBefore': { message: '错误的日期格式', value } };
        }
        /** @type {?} */
        const isBefore = CommonsUtils.isBefore(control.value, before);
        return isBefore ? null : { 'dataBefore': { value, before } };
    };
    return fn;
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const dateBetweenValidator = function (before, after) {
    /** @type {?} */
    const fn = (control) => {
        /** @type {?} */
        const value = control.value;
        if (!DateUtils.isDate(value)) {
            return { 'dataBetween': { message: '错误的日期格式', value } };
        }
        /** @type {?} */
        const isBetween = CommonsUtils.isBefore(value, before)
            && CommonsUtils.isAfter(value, after);
        return isBetween ? null : { 'dataBetween': { value, before, after } };
    };
    return fn;
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const conditionValidator = function (condition) {
    /** @type {?} */
    const fn = (control) => {
        return condition(control.value) ? null : {
            condition: { condition, value: control.value }
        };
    };
    return fn;
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const dateFormatValidator = function (dateRegPattern = RegPatterns.date_yyyymmdd) {
    /** @type {?} */
    const fn = (control) => {
        /** @type {?} */
        const value = control.value;
        /** @type {?} */
        const isValid = !value || value.match(dateRegPattern);
        return isValid ? null : { 'dateFormat': { value, 'format': dateRegPattern } };
    };
    return fn;
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const equalToValidator = function (controlName) {
    /** @type {?} */
    const fn = (control) => {
        /** @type {?} */
        let parent = control.parent;
        /** @type {?} */
        let target;
        while (parent instanceof FormGroup) {
            target = FormUtils.getFormControl(parent, controlName);
            if (target) {
                break;
            }
            parent = parent.parent;
        }
        if (target) {
            /** @type {?} */
            const value = control.value;
            /** @type {?} */
            const targetValue = target.value;
            /** @type {?} */
            const isValid = value === targetValue;
            return isValid ? null : { 'equalTo': { value, controlName } };
        }
        return null;
    };
    return fn;
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const matchValidator = function (pattern, errorKey = 'match') {
    /** @type {?} */
    const fn = (control) => {
        /** @type {?} */
        const value = control.value;
        if (CommonsUtils.isEmptyString(value)) {
            return null;
        }
        return RegUtils.test(value, pattern) ? null : { [errorKey]: { pattern, value } };
    };
    return fn;
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const notEqualToValidator = function (controlName) {
    /** @type {?} */
    const fn = (control) => {
        /** @type {?} */
        let parent = control.parent;
        /** @type {?} */
        let target;
        while (parent instanceof FormGroup) {
            target = FormUtils.getFormControl(parent, controlName);
            if (target) {
                break;
            }
            parent = parent.parent;
        }
        if (target) {
            /** @type {?} */
            const value = control.value;
            /** @type {?} */
            const targetValue = target.value;
            /** @type {?} */
            const isValid = value !== targetValue;
            return isValid ? null : { 'notEqualTo': { value, controlName } };
        }
        return null;
    };
    return fn;
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const passwordValidator = function (options) {
    if (!options) {
        options = {
            minLength: 6,
            requireLetters: true,
            requireNumbers: true
        };
    }
    /** @type {?} */
    const validator = new PasswordValidator(options);
    return (control) => {
        return validator.validate(control.value);
    };
};
class PasswordValidator {
    /**
     * @param {?} options
     */
    constructor(options) {
        this.options = options;
        this.letterMatcher = /[a-zA-Z]/;
        this.lowerCaseLetterMatcher = /[a-z]/;
        this.upperCaseLetterMatcher = /[A-Z]/;
        this.numberMatcher = /[0-9]/;
        this.specialCharactersMatcher = /[-+=_.,:;~`!@#$%^&*(){}<>\[\]"'\/\\]/;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    validate(value) {
        if (!value) {
            return null;
        }
        /** @type {?} */
        const errors = {};
        // Minimum length.
        if (this.options.minLength > 0 && value.length < this.options.minLength) {
            errors.passwordMinLengthRequired = {
                minLength: this.options.minLength
            };
        }
        // Maximum length.
        if (this.options.maxLength >= 0 && value.length > this.options.maxLength) {
            errors.passwordMaxLengthExceeded = {
                maxLength: this.options.maxLength
            };
        }
        // Letters.
        if (this.options.requireLetters && !this.letterMatcher.test(value)) {
            errors.passwordLetterRequired = true;
        }
        // Lower-case letters.
        if (this.options.requireLowerCaseLetters && !this.lowerCaseLetterMatcher.test(value)) {
            errors.passwordLowerCaseLetterRequired = true;
        }
        // Upper-case letters.
        if (this.options.requireUpperCaseLetters && !this.upperCaseLetterMatcher.test(value)) {
            errors.passwordUpperCaseLetterRequired = true;
        }
        // Numbers.
        if (this.options.requireNumbers && !this.numberMatcher.test(value)) {
            errors.passwordNumberRequired = true;
        }
        // Special characters.
        if (this.options.requireSpecialCharacters && !this.specialCharactersMatcher.test(value)) {
            errors.passwordSpecialCharacterRequired = true;
        }
        return Object.keys(errors).length > 0 ? { password: { errors, options: this.options } } : null;
    }
}
/**
 * @param {?} error
 * @return {?}
 */
function passwordValidationMessage(error) {
    /** @type {?} */
    const options = (/** @type {?} */ (error.options));
    /** @type {?} */
    let s = [];
    if (options.minLength) {
        s.push('最少' + options.minLength + '位');
    }
    if (options.maxLength) {
        s.push('最多' + options.maxLength + '位');
    }
    if (options.requireLetters) {
        s.push('包含字母');
    }
    if (options.requireLowerCaseLetters) {
        s.push('包含小写字母');
    }
    if (options.requireUpperCaseLetters) {
        s.push('包含大小字母');
    }
    if (options.requireNumbers) {
        s.push('包含数字');
    }
    if (options.requireSpecialCharacters) {
        s.push('包含非数字和字母');
    }
    return `登录密码必须:<br>${s.join('<br>')}`;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgValidators {
    /**
     * @param {?} control
     * @return {?}
     */
    static letter(control) {
        /** @type {?} */
        const value = control.value;
        if (CommonsUtils.isEmptyString(value)) {
            return null;
        }
        return RegUtils.test(value, RegPatterns.letter) ? null : { letter: true };
    }
    /**
     * @param {?} control
     * @return {?}
     */
    static character(control) {
        /** @type {?} */
        const value = control.value;
        if (CommonsUtils.isEmptyString(value)) {
            return null;
        }
        return RegUtils.test(value, RegPatterns.character) ? null : { character: true };
    }
    /**
     * @param {?} control
     * @return {?}
     */
    static ascii(control) {
        /** @type {?} */
        const value = control.value;
        if (CommonsUtils.isEmptyString(value)) {
            return null;
        }
        return RegUtils.test(value, RegPatterns.ascii) ? null : { ascii: true };
    }
    /**
     * @param {?} control
     * @return {?}
     */
    static chinese(control) {
        /** @type {?} */
        const value = control.value;
        if (CommonsUtils.isEmptyString(value)) {
            return null;
        }
        return RegUtils.test(value, RegPatterns.chinese) ? null : { chinese: true };
    }
    /**
     * @param {?} control
     * @return {?}
     */
    static digit(control) {
        /** @type {?} */
        const value = control.value;
        if (CommonsUtils.isEmptyString(value)) {
            return null;
        }
        return RegUtils.test(value, RegPatterns.digit) ? null : { digit: true };
    }
    /**
     * @param {?} control
     * @return {?}
     */
    static integer(control) {
        /** @type {?} */
        const value = control.value;
        if (CommonsUtils.isEmptyString(value)) {
            return null;
        }
        return RegUtils.test(value, RegPatterns.integer) ? null : { integer: true };
    }
    /**
     * @param {?} control
     * @return {?}
     */
    static numeric(control) {
        /** @type {?} */
        const value = control.value;
        if (CommonsUtils.isEmptyString(value)) {
            return null;
        }
        return RegUtils.test(value, RegPatterns.numeric) ? null : { numeric: true };
    }
    /**
     * @param {?} control
     * @return {?}
     */
    static phone(control) {
        /** @type {?} */
        const value = control.value;
        if (CommonsUtils.isEmptyString(value)) {
            return null;
        }
        return RegUtils.test(value, RegPatterns.phone) ? null : { phone: true };
    }
    /**
     * @param {?} control
     * @return {?}
     */
    static idCard(control) {
        /** @type {?} */
        const value = control.value;
        if (CommonsUtils.isEmptyString(value)) {
            return null;
        }
        /** @type {?} */
        const validation = IdCardUtils.test(value);
        return validation.status ? null : { idCard: true };
    }
    /**
     * @param {?} control
     * @return {?}
     */
    static ip(control) {
        /** @type {?} */
        const value = control.value;
        if (CommonsUtils.isEmptyString(value)) {
            return null;
        }
        return RegUtils.test(value, RegPatterns.ip) ? null : { ip: true };
    }
    /**
     * @param {?} control
     * @return {?}
     */
    static halfWidth(control) {
        /** @type {?} */
        const value = control.value;
        if (CommonsUtils.isEmptyString(value)) {
            return null;
        }
        return RegUtils.test(value, RegPatterns.halfWidth) ? null : { halfWidth: true };
    }
    /**
     * @param {?} control
     * @return {?}
     */
    static fullWidth(control) {
        /** @type {?} */
        const value = control.value;
        if (CommonsUtils.isEmptyString(value)) {
            return null;
        }
        return RegUtils.test(value, RegPatterns.fullWidth) ? null : { fullWidth: true };
    }
    /**
     * @param {?} pattern
     * @return {?}
     */
    static match(pattern) {
        return matchValidator(pattern);
    }
    /**
     * @param {?=} options
     * @return {?}
     */
    static password(options) {
        return passwordValidator(options);
    }
    /**
     * @param {?} before
     * @return {?}
     */
    static before(before) {
        return dateBeforeValidator(before);
    }
    /**
     * @param {?} after
     * @return {?}
     */
    static after(after) {
        return dateAfterValidator(after);
    }
    /**
     * @param {?} before
     * @param {?} after
     * @return {?}
     */
    static between(before, after) {
        return dateBetweenValidator(before, after);
    }
    /**
     * @param {?=} formatPattern
     * @return {?}
     */
    static dateFormat(formatPattern) {
        return dateFormatValidator(formatPattern);
    }
    /**
     * @param {?=} min
     * @param {?=} max
     * @return {?}
     */
    static age(min = 0, max = 0) {
        return ageValidator(min, max);
    }
    /**
     * @param {?} conditionFn
     * @return {?}
     */
    static condition(conditionFn) {
        return conditionValidator(conditionFn);
    }
    /**
     * @param {?} controlName
     * @return {?}
     */
    static equalTo(controlName) {
        return equalToValidator(controlName);
    }
    /**
     * @param {?} controlName
     * @return {?}
     */
    static notEqualTo(controlName) {
        return notEqualToValidator(controlName);
    }
    /**
     * @param {?} minlength
     * @return {?}
     */
    static minLength(minlength) {
        return Validators.minLength(minlength);
    }
    /**
     * @param {?} maxlength
     * @return {?}
     */
    static maxLength(maxlength) {
        return Validators.maxLength(maxlength);
    }
    /**
     * @param {?} minValue
     * @return {?}
     */
    static min(minValue) {
        return Validators.min(minValue);
    }
    /**
     * @param {?} maxValue
     * @return {?}
     */
    static max(maxValue) {
        return Validators.max(maxValue);
    }
    /**
     * @param {?} reg
     * @return {?}
     */
    static pattern(reg) {
        return Validators.pattern(reg);
    }
    /**
     * @param {?} minLength
     * @param {?} maxLength
     * @return {?}
     */
    static rangeLength(minLength, maxLength) {
        return CustomValidators.rangeLength([minLength, maxLength]);
    }
    /**
     * @param {?} min
     * @param {?} max
     * @return {?}
     */
    static range(min, max) {
        return CustomValidators.range([min, max]);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    static gt(value) {
        return CustomValidators.gt(value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    static gte(value) {
        return CustomValidators.gte(value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    static lt(value) {
        return CustomValidators.lt(value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    static lte(value) {
        return CustomValidators.lte(value);
    }
    /**
     * @param {?} minDate
     * @return {?}
     */
    static minDate(minDate) {
        return CustomValidators.minDate(minDate);
    }
    /**
     * @param {?} maxDate
     * @return {?}
     */
    static maxDate(maxDate) {
        return CustomValidators.maxDate(maxDate);
    }
    /**
     * @param {?} s
     * @return {?}
     */
    static equal(s) {
        return CustomValidators.equal(s);
    }
    /**
     * @param {?} s
     * @return {?}
     */
    static notEqual(s) {
        return CustomValidators.notEqual(s);
    }
    /**
     * @param {?} control
     * @return {?}
     */
    static equalTo2(control) {
        return CustomValidators.equalTo(control);
    }
    /**
     * @param {?} control
     * @return {?}
     */
    static notEqualTo2(control) {
        return CustomValidators.notEqualTo(control);
    }
}
NgValidators.required = Validators.required;
NgValidators.accept = Validators.requiredTrue;
NgValidators.email = CustomValidators.email;
NgValidators.url = CustomValidators.url;
NgValidators.date = CustomValidators.date;
NgValidators.json = CustomValidators.json;
NgValidators.base64 = CustomValidators.base64;
NgValidators.creditCard = CustomValidators.creditCard;
class NgValidateMessages {
    /**
     * @param {?} error
     * @return {?}
     */
    static maxlength(error) {
        return `长度不能大于<strong>${error.requiredLength}</strong>个字`;
    }
    /**
     * @param {?} error
     * @return {?}
     */
    static minlength(error) {
        return `长度不能少于<strong>${error.requiredLength}</strong>个字`;
    }
    /**
     * @param {?} error
     * @return {?}
     */
    static min(error) {
        return `不能小于<strong>${error.min}</strong>`;
    }
    /**
     * @param {?} error
     * @return {?}
     */
    static max(error) {
        return `不能大于<strong>${error.max}</strong>`;
    }
    /**
     * @param {?} error
     * @return {?}
     */
    static age(error) {
        return `年龄必须介于 ${error.min} ${error.max}`;
    }
    /**
     * @param {?} error
     * @return {?}
     */
    static password(error) {
        return passwordValidationMessage(error);
    }
    /**
     * @param {?} error
     * @return {?}
     */
    static dateBefore(error) {
        return `日期必须在 ${error.before}之前`;
    }
    /**
     * @param {?} error
     * @return {?}
     */
    static dateAfter(error) {
        return `日期必须在 ${error.after}之后`;
    }
    /**
     * @param {?} error
     * @return {?}
     */
    static dataBetween(error) {
        return `日期必须在 ${error.before}和${error.after}之间`;
    }
    /**
     * @param {?} error
     * @return {?}
     */
    static rangeLength(error) {
        return `长度必须大于<strong>${error.max}</strong>`;
    }
    /**
     * @param {?} error
     * @return {?}
     */
    static gt(error) {
        return `必须大于<strong>${error.max}</strong>`;
    }
    /**
     * @param {?} error
     * @return {?}
     */
    static lt(error) {
        return `不能大于<strong>${error.lt}</strong>`;
    }
    /**
     * @param {?} error
     * @return {?}
     */
    static lte(error) {
        return `不能大于<strong>${error.lte}</strong>`;
    }
    /**
     * @param {?} error
     * @return {?}
     */
    static range(error) {
        return `不能大于<strong>${error.lte}</strong>`;
    }
    /**
     * @param {?} error
     * @return {?}
     */
    static minDate(error) {
        return `日期不能小于<strong>${error.minDate}</strong>`;
    }
}
NgValidateMessages.required = '此项内容必须填写';
NgValidateMessages.pattern = '格式不符合要求';
NgValidateMessages.letter = '此项内容必须是英文字母';
NgValidateMessages.digit = '此项内容必须是数字';
NgValidateMessages.character = '此项内容必须是英文字母或数字';
NgValidateMessages.chinese = '此项内容必须是简体中文';
NgValidateMessages.integer = '此项内容必须是整数';
NgValidateMessages.number = '此项内容必须是数值';
NgValidateMessages.fullWidth = '此项内容必须是全角';
NgValidateMessages.halfWidth = '此项内容必须是半角';
NgValidateMessages.phone = '手机号码格式不符合要求';
NgValidateMessages.condition = '输入不符合要求';
NgValidateMessages.email = '无效的email地址';
NgValidateMessages.idCard = '无效的身份证号';
NgValidateMessages.not_matching = '密码不匹配';
NgValidateMessages.unique = '该值已经存在';
NgValidateMessages.gte = '输入不符合要求';
NgValidateMessages.url = '地址格式不符合要求';
NgValidateMessages.date = '日期格式不符合要求';
NgValidateMessages.maxDate = '输入不符合要求';
NgValidateMessages.json = '输入不符合要求';
NgValidateMessages.base64 = '输入不符合要求';
NgValidateMessages.equal = '两次输入不一致';
NgValidateMessages.notEqual = '两次输入不能一致';
NgValidateMessages.equalTo = '两次输入不一致';
NgValidateMessages.notEqualTo = '两次输入不能一致';
NgValidateMessages.duplicated = '当前值已经存在，不能重复';
NgValidateMessages.exists = '当前值已经存在，不能使用';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ValidateUtils {
    /**
     * @param {?} form
     * @param {?=} messages
     * @param {?=} formlyfield
     * @return {?}
     */
    static getFormErrors(form, messages, formlyfield) {
        /** @type {?} */
        const errors = {};
        if (form instanceof FormControl) {
            return (ValidateUtils.getControlErrors((/** @type {?} */ (form)), messages, formlyfield));
        }
        else if (form instanceof FormGroup) {
            Object.keys(form.controls).map(name => errors[name] = (ValidateUtils.getFormErrors((/** @type {?} */ (form.controls[name])), messages, formlyfield)));
        }
        else if (form instanceof FormArray) {
            /** @type {?} */
            const err = [];
            ((/** @type {?} */ (form.controls[name]))).controls.forEach(control => err.push((ValidateUtils.getFormErrors(control, messages, formlyfield))));
            return err;
        }
        return errors;
    }
    /**
     * @param {?} control
     * @param {?=} messages
     * @param {?=} formlyfield
     * @return {?}
     */
    static getControlErrors(control, messages, formlyfield) {
        return ValidateUtils.getErrorMessage(control.errors, messages, formlyfield);
    }
    /**
     * @param {?} errors
     * @param {?=} messages
     * @param {?=} formlyfield
     * @return {?}
     */
    static getErrorMessage(errors, messages, formlyfield) {
        if (!errors) {
            return {};
        }
        /** @type {?} */
        const errorMessages = {};
        Object.keys(errors).forEach(key => {
            /** @type {?} */
            let message;
            if (formlyfield) {
                if (formlyfield.validators && formlyfield.validators[key] && formlyfield.validators[key].message) {
                    message = formlyfield.validators[key].message;
                }
                else if (formlyfield.asyncValidators && formlyfield.asyncValidators[key] && formlyfield.asyncValidators[key].message) {
                    message = formlyfield.asyncValidators[key].message;
                }
            }
            if (!message) {
                if (messages && messages.hasOwnProperty(key)) {
                    message = messages[key];
                }
                else if (NgValidateMessages.hasOwnProperty(key)) {
                    message = NgValidateMessages[key];
                }
                else {
                    message = key;
                }
            }
            if (typeof message === 'string') {
                errorMessages[key] = message;
            }
            else if (typeof message === 'function') {
                errorMessages[key] = message.apply(this, [errors[key], formlyfield]);
            }
        });
        return errorMessages;
    }
    /**
     * @param {?} error
     * @param {?=} context
     * @return {?}
     */
    static dynaValidationMessageFn(error, context) {
        /** @type {?} */
        let values = [];
        if (CommonsUtils.isJson(error) && context.errorProps) {
            if (Array.isArray(context.errorProps)) {
                context.errorProps.forEach(key => values.push(error[key]));
            }
            else {
                values.push(error[context.errorProps]);
            }
        }
        else {
            /** @type {?} */
            const dyna = CommonsUtils.get(context, 'validation.dyna', []);
            /** @type {?} */
            const info = CommonsUtils.find(dyna, { key: context.errorKey });
            if (info) {
                values = info['args'] || [];
            }
        }
        return CommonsUtils.templateStr(context.format, values);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormValidateMessagesComponent {
    /**
     * @param {?} controlContainer
     */
    constructor(controlContainer) {
        this.controlContainer = controlContainer;
        this.errors$ = new Subject();
    }
    /**
     * @return {?}
     */
    checkFormValidate() {
        if (this.form.invalid) {
            alert();
            this.errors$.next(ValidateUtils.getFormErrors(this.form, this.messages, this.fields));
        }
        else {
            this.errors$.next(undefined);
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.form && this.controlContainer) {
            this.form = this.controlContainer.formDirective ? ((/** @type {?} */ (this.controlContainer.formDirective))).form : null;
        }
        if (this.form) {
            this.subscription = this.form.statusChanges
                .subscribe(() => {
                this.checkFormValidate();
            });
        }
    }
    /**
     * @param {?} errors
     * @return {?}
     */
    errorKeys(errors) {
        return Object.keys(errors);
    }
    /**
     * @param {?} error
     * @return {?}
     */
    errorMsg(error) {
        return CommonsUtils.getText(error);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
}
FormValidateMessagesComponent.decorators = [
    { type: Component, args: [{
                selector: 'er-form-validate-messages',
                template: "<div *ngIf=\"errors$|async as errors\">\n  <ng-container *ngTemplateOutlet=\"errorMsgTpl?errorMsgTpl:defaultTpl;context:{$implicit:errors}\"></ng-container>\n</div>\n\n<ng-template #defaultTpl let-errors>\n  <div class=\"text-danger\" [ngClass]=\"styleClass\">\n    <ul *ngFor=\"let key of errorKeys(errors)\" class=\"d-flex flex-column justify-content-start\">\n     <li class=\"my-2\">{{key}}</li>\n    </ul>\n  </div>\n</ng-template>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
FormValidateMessagesComponent.ctorParameters = () => [
    { type: ControlContainer, decorators: [{ type: Optional }] }
];
FormValidateMessagesComponent.propDecorators = {
    form: [{ type: Input }],
    messages: [{ type: Input }],
    fields: [{ type: Input }],
    styleClass: [{ type: Input }],
    errorMsgTpl: [{ type: ContentChild, args: [TemplateRef,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ValidateMessagesComponent {
    /**
     * @param {?} controlContainer
     * @param {?} cd
     */
    constructor(controlContainer, cd) {
        this.controlContainer = controlContainer;
        this.cd = cd;
        this.showAllErrors = true;
        this.errors$ = new BehaviorSubject(undefined);
    }
    /**
     * @return {?}
     */
    getErrorMessages() {
        if (this.control.dirty && this.control.invalid) {
            /** @type {?} */
            const errorMessages = ValidateUtils.getErrorMessage(this.control.errors);
            /** @type {?} */
            const errors = this.showAllErrors ? errorMessages : this.getFirstError(errorMessages);
            this.errors$.next(this.getErrors(errors));
        }
        else {
            return this.errors$.next([]);
        }
    }
    /**
     * @param {?} errorMessages
     * @return {?}
     */
    getFirstError(errorMessages) {
        if (Object.keys(errorMessages).length > 0) {
            return errorMessages[Object.keys(errorMessages)[0]];
        }
        return '校验失败';
    }
    /**
     * @param {?} errorMessages
     * @return {?}
     */
    getErrors(errorMessages) {
        /** @type {?} */
        const lst = [];
        if (errorMessages) {
            Object.keys(errorMessages).map(key => {
                lst.push({ key, value: (this.messages && this.messages[key]) || errorMessages[key] });
            });
        }
        return lst;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.control) {
            if (this.formlyField) {
                this.control = this.formlyField.formControl;
            }
            if (!this.control && this.controlContainer) {
                /** @type {?} */
                const form = this.controlContainer.formDirective ? ((/** @type {?} */ (this.controlContainer.formDirective))).form : null;
                if (form) {
                    this.control = FormUtils.getFormControl(form, ...this.controlContainer.path, this.controlName);
                }
            }
        }
        if (this.control) {
            this.subscription = this.control.statusChanges.subscribe(() => {
                this.getErrorMessages();
            });
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
}
ValidateMessagesComponent.decorators = [
    { type: Component, args: [{
                selector: 'er-validate-messages',
                template: `
    <div *ngIf="errors$|async as errors">
      <ng-container *ngTemplateOutlet="errorMsgTpl?errorMsgTpl:defaultTpl;context:{$implicit:errors}"></ng-container>
    </div>
    <ng-template #defaultTpl let-errors>
      <div class="text-danger" [ngClass]="styleClass">
        <ul *ngFor="let error of errors " class="d-flex flex-column justify-content-start">
          <li [innerHTML]="error.value" class="my-1" style="font-size: 0.8em"></li>
        </ul>
      </div>
    </ng-template>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
ValidateMessagesComponent.ctorParameters = () => [
    { type: ControlContainer, decorators: [{ type: Optional }] },
    { type: ChangeDetectorRef }
];
ValidateMessagesComponent.propDecorators = {
    control: [{ type: Input }],
    controlName: [{ type: Input }],
    formlyField: [{ type: Input }],
    force: [{ type: Input }],
    styleClass: [{ type: Input }],
    showAllErrors: [{ type: Input }],
    messages: [{ type: Input }],
    errorMsgTpl: [{ type: ContentChild, args: [TemplateRef,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ValidateOnBlurMessageDirective {
    /**
     * @param {?} model
     */
    constructor(model) {
        this.model = model;
    }
    /**
     * @return {?}
     */
    get control() {
        if (this.model && this.model.control) {
            return this.model.control;
        }
        else {
            return undefined;
        }
    }
    /**
     * @return {?}
     */
    onFocus() {
        if (this.control) {
            this.validators = this.control.validator;
            this.asyncValidators = this.control.asyncValidator;
            this.control.clearAsyncValidators();
            this.control.clearValidators();
        }
    }
    /**
     * @return {?}
     */
    onBlur() {
        if (this.control) {
            this.control.setAsyncValidators(this.asyncValidators);
            this.control.setValidators(this.validators);
            this.control.updateValueAndValidity();
        }
    }
}
ValidateOnBlurMessageDirective.decorators = [
    { type: Directive, args: [{
                selector: '[erValidateOnBlur]'
            },] }
];
/** @nocollapse */
ValidateOnBlurMessageDirective.ctorParameters = () => [
    { type: NgControl, decorators: [{ type: Optional }] }
];
ValidateOnBlurMessageDirective.propDecorators = {
    onFocus: [{ type: HostListener, args: ['focus',] }],
    onBlur: [{ type: HostListener, args: ['blur',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/* tslint:disable:directive-selector */
class ValidationMessageDirective {
    /**
     * @param {?} componentFactoryResolver
     * @param {?} viewContainerRef
     * @param {?} ngControl
     */
    constructor(componentFactoryResolver, viewContainerRef, ngControl) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.viewContainerRef = viewContainerRef;
        this.ngControl = ngControl;
        this.showError = true;
        this.enableValidation = true;
    }
    /**
     * @return {?}
     */
    get control() {
        if (this.ngControl && this.ngControl.control) {
            return this.ngControl.control;
        }
        else {
            return undefined;
        }
    }
    /**
     * @return {?}
     */
    get isValid() {
        if (!this.showError || (!this.ngControl && this.ngControl.control == null)) {
            return false;
        }
        return this.ngControl && this.ngControl.control && this.ngControl.control.valid;
    }
    /**
     * @return {?}
     */
    get isInvalid() {
        if (!this.showError || (!this.ngControl && this.ngControl.control == null)) {
            return false;
        }
        return this.ngControl && this.ngControl.control && this.ngControl.control.invalid;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (!this.ngControl || !this.enableValidation) {
            return;
        }
        /** @type {?} */
        const attrs = this.viewContainerRef.element.nativeElement.attributes;
        if (attrs) {
            /** @type {?} */
            const tag = !!attrs.getNamedItem('noerror');
            if (this.showError && tag) {
                this.showError = false;
                return;
            }
        }
        this.componentFactory = CacheUtils.get('$componentFactory', 'ValidateMessagesComponentFactory');
        if (!this.componentFactory) {
            this.componentFactory = this.componentFactoryResolver.resolveComponentFactory(ValidateMessagesComponent);
            CacheUtils.put('$componentFactory', 'validationMessagesComponentFactory', this.componentFactory);
        }
        /** @type {?} */
        const className = this.viewContainerRef.element.nativeElement.parentElement.className;
        if (className.indexOf('input-group') >= 0) ;
        this.componentRef = this.viewContainerRef.createComponent(this.componentFactory);
        ((/** @type {?} */ (this.componentRef.instance))).messages = this.messages;
        ((/** @type {?} */ (this.componentRef.instance))).control = (/** @type {?} */ (this.control));
    }
}
ValidationMessageDirective.decorators = [
    { type: Directive, args: [{
                selector: '[erValidate]'
            },] }
];
/** @nocollapse */
ValidationMessageDirective.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: ViewContainerRef },
    { type: NgControl, decorators: [{ type: Optional }] }
];
ValidationMessageDirective.propDecorators = {
    messages: [{ type: Input }],
    showError: [{ type: Input }],
    enableValidation: [{ type: Input }],
    isValid: [{ type: HostBinding, args: ['class.er-valid',] }],
    isInvalid: [{ type: HostBinding, args: ['class.er-invalid',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/* tslint:disable:directive-selector */
class ValidateStateDirective {
    /**
     * @param {?} componentFactoryResolver
     * @param {?} viewContainerRef
     * @param {?} ngControl
     */
    constructor(componentFactoryResolver, viewContainerRef, ngControl) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.viewContainerRef = viewContainerRef;
        this.ngControl = ngControl;
        this.showError = true;
        this.enableValidation = true;
    }
    /**
     * @return {?}
     */
    get control() {
        if (this.ngControl && this.ngControl.control) {
            return this.ngControl.control;
        }
        else {
            return undefined;
        }
    }
    /**
     * @return {?}
     */
    get isValid() {
        if (!this.showError || (!this.ngControl && this.ngControl.control == null)) {
            return false;
        }
        return this.ngControl && this.ngControl.control && this.ngControl.control.valid;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (!this.ngControl || !this.enableValidation) {
            return;
        }
        /** @type {?} */
        const attrs = this.viewContainerRef.element.nativeElement.attributes;
        if (attrs) {
            /** @type {?} */
            const tag = !!attrs.getNamedItem('noerror');
            if (this.showError && tag) {
                this.showError = false;
                return;
            }
        }
    }
}
ValidateStateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[formControlName],[formControl],[ngModel]'
            },] }
];
/** @nocollapse */
ValidateStateDirective.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: ViewContainerRef },
    { type: NgControl, decorators: [{ type: Optional }] }
];
ValidateStateDirective.propDecorators = {
    messages: [{ type: Input }],
    showError: [{ type: Input }],
    enableValidation: [{ type: Input }],
    isValid: [{ type: HostBinding, args: ['class.er-valid',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const directives = [
    ValidationMessageDirective,
    ValidateStateDirective,
    ValidateOnBlurMessageDirective
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ErValidateModule {
}
ErValidateModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    CustomFormsModule
                ],
                declarations: [
                    ValidateMessagesComponent,
                    FormValidateMessagesComponent,
                    ...directives
                ],
                exports: [
                    FormsModule,
                    ReactiveFormsModule,
                    ValidateMessagesComponent,
                    FormValidateMessagesComponent,
                    ...directives
                ],
                entryComponents: [
                    ValidateMessagesComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { ErValidateModule, NgValidators, NgValidateMessages, FormValidateMessagesComponent, ValidateMessagesComponent, ValidateUtils, ValidationMessageDirective, ValidateStateDirective, ValidateOnBlurMessageDirective, directives, ValidateMessagesComponent as ɵl, FormValidateMessagesComponent as ɵm, dateAfterValidator as ɵe, ageValidator as ɵh, dateBeforeValidator as ɵd, dateBetweenValidator as ɵf, conditionValidator as ɵi, dateFormatValidator as ɵg, equalToValidator as ɵj, matchValidator as ɵc, notEqualToValidator as ɵk, passwordValidationMessage as ɵb, passwordValidator as ɵa };

//# sourceMappingURL=er-validate.js.map