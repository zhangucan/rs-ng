{
  "version": 3,
  "file": "stomp-ng2-stompjs.umd.min.js",
  "sources": [
    "ng://@stomp/ng2-stompjs/node_modules/tslib/tslib.es6.js",
    "ng://@stomp/ng2-stompjs/out/src/stomp-r.service.ts",
    "ng://@stomp/ng2-stompjs/out/src/stomp.config.ts",
    "ng://@stomp/ng2-stompjs/out/src/stomp.service.ts"
  ],
  "sourcesContent": [
    "/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n",
    "import { first, filter, share } from 'rxjs/operators';\nimport { Injectable } from '@angular/core';\nimport { BehaviorSubject ,  Observable ,  Observer ,  Subject ,  Subscription } from 'rxjs';\n\nimport { StompConfig } from './stomp.config';\n\nimport * as Stomp from '@stomp/stompjs';\nimport { Frame, StompSubscription } from '@stomp/stompjs';\nimport { StompHeaders } from './stomp-headers';\nimport { StompState } from './stomp-state';\n\n/**\n * Angular2 STOMP Raw Service using @stomp/stomp.js\n *\n * You will only need the public properties and\n * methods listed unless you are an advanced user. This service handles subscribing to a\n * message queue using the stomp.js library, and returns\n * values via the ES6 Observable specification for\n * asynchronous value streaming by wiring the STOMP\n * messages into an observable.\n *\n * If you will like to pass the configuration as a dependency,\n * please use StompService class.\n */\n@Injectable()\nexport class StompRService {\n  /**\n   * State of the STOMPService\n   *\n   * It is a BehaviorSubject and will emit current status immediately. This will typically get\n   * used to show current status to the end user.\n   */\n  public state: BehaviorSubject<StompState>;\n\n  /**\n   * Will trigger when connection is established. Use this to carry out initialization.\n   * It will trigger every time a (re)connection occurs. If it is already connected\n   * it will trigger immediately. You can safely ignore the value, as it will always be\n   * StompState.CONNECTED\n   */\n  public connectObservable: Observable<StompState>;\n\n  /**\n   * Provides headers from most recent connection to the server as return by the CONNECTED\n   * frame.\n   * If the STOMP connection has already been established it will trigger immediately.\n   * It will additionally trigger in event of reconnection, the value will be set of headers from\n   * the recent server response.\n   */\n  public serverHeadersObservable: Observable<StompHeaders>;\n\n  private _serverHeadersBehaviourSubject: BehaviorSubject<null | StompHeaders>;\n\n  /**\n   * Will emit all messages to the default queue (any message that are not handled by a subscription)\n   */\n  public defaultMessagesObservable: Subject<Stomp.Message>;\n\n  /**\n   * Will emit all receipts\n   */\n  public receiptsObservable: Subject<Stomp.Frame>;\n\n  /**\n   * Will trigger when an error occurs. This Subject can be used to handle errors from\n   * the stomp broker.\n   */\n  public errorSubject: Subject<string | Stomp.Message>;\n\n  /**\n   * Internal array to hold locally queued messages when STOMP broker is not connected.\n   */\n  protected queuedMessages: { queueName: string, message: string, headers: StompHeaders }[] = [];\n\n  /**\n   * Configuration\n   */\n  private _config: StompConfig;\n\n  /**\n   * STOMP Client from @stomp/stomp.js\n   */\n  protected client: Stomp.Client;\n\n  /**\n   * Constructor\n   *\n   * See README and samples for configuration examples\n   */\n  public constructor() {\n    this.state = new BehaviorSubject<StompState>(StompState.CLOSED);\n\n    this.connectObservable = this.state.pipe(\n      filter((currentState: StompState) => {\n        return currentState === StompState.CONNECTED;\n      })\n    );\n\n    // Setup sending queuedMessages\n    this.connectObservable.subscribe(() => {\n      this.sendQueuedMessages();\n    });\n\n    this._serverHeadersBehaviourSubject = new BehaviorSubject<null | StompHeaders>(null);\n\n    this.serverHeadersObservable = this._serverHeadersBehaviourSubject.pipe(\n      filter((headers: null | StompHeaders) => {\n        return headers !== null;\n      })\n    );\n\n    this.errorSubject = new Subject();\n  }\n\n  /** Set configuration */\n  set config(value: StompConfig) {\n    this._config = value;\n  }\n\n  /** It will initialize STOMP Client. */\n  protected initStompClient(): void {\n    // disconnect if connected\n    this.disconnect();\n\n    // url takes precedence over socketFn\n    if (typeof(this._config.url) === 'string') {\n      this.client = Stomp.client(this._config.url);\n    } else {\n      this.client = Stomp.over(this._config.url);\n    }\n\n    // Configure client heart-beating\n    this.client.heartbeat.incoming = this._config.heartbeat_in;\n    this.client.heartbeat.outgoing = this._config.heartbeat_out;\n\n    // Auto reconnect\n    this.client.reconnect_delay = this._config.reconnect_delay;\n\n    if (!this._config.debug) {\n      this.debug = function () {\n      };\n    }\n    // Set function to debug print messages\n    this.client.debug = this.debug;\n\n    // Default messages\n    this.setupOnReceive();\n\n    // Receipts\n    this.setupReceipts();\n  }\n\n\n  /**\n   * It will connect to the STOMP broker.\n   */\n  public initAndConnect(): void {\n    this.initStompClient();\n\n    if (!this._config.headers) {\n      this._config.headers = {};\n    }\n\n    // Attempt connection, passing in a callback\n    this.client.connect(\n      this._config.headers,\n      this.on_connect,\n      this.on_error\n    );\n\n    this.debug('Connecting...');\n    this.state.next(StompState.TRYING);\n  }\n\n\n  /**\n   * It will disconnect from the STOMP broker.\n   */\n  public disconnect(): void {\n\n    // Disconnect if connected. Callback will set CLOSED state\n    if (this.client) {\n      if (!this.client.connected) {\n        // Nothing to do\n        this.state.next(StompState.CLOSED);\n        return;\n      }\n\n      // Notify observers that we are disconnecting!\n      this.state.next(StompState.DISCONNECTING);\n\n      this.client.disconnect(\n        () => this.state.next(StompState.CLOSED)\n      );\n    }\n  }\n\n  /**\n   * It will return `true` if STOMP broker is connected and `false` otherwise.\n   */\n  public connected(): boolean {\n    return this.state.getValue() === StompState.CONNECTED;\n  }\n\n  /**\n   * It will send a message to a named destination. The message must be `string`.\n   *\n   * The message will get locally queued if the STOMP broker is not connected. It will attempt to\n   * publish queued messages as soon as the broker gets connected.\n   *\n   * @param queueName\n   * @param message\n   * @param headers\n   */\n  public publish(queueName: string, message: string, headers: StompHeaders = {}): void {\n    if (this.connected()) {\n      this.client.send(queueName, headers, message);\n    } else {\n      this.debug(`Not connected, queueing ${message}`);\n      this.queuedMessages.push({queueName: <string>queueName, message: <string>message, headers: headers});\n    }\n  }\n\n  /** It will send queued messages. */\n  protected sendQueuedMessages(): void {\n    const queuedMessages = this.queuedMessages;\n    this.queuedMessages = [];\n\n    this.debug(`Will try sending queued messages ${queuedMessages}`);\n\n    for (const queuedMessage of queuedMessages) {\n      this.debug(`Attempting to send ${queuedMessage}`);\n      this.publish(queuedMessage.queueName, queuedMessage.message, queuedMessage.headers);\n    }\n  }\n\n  /**\n   * It will subscribe to server message queues\n   *\n   * This method can be safely called even if the STOMP broker is not connected.\n   * If the underlying STOMP connection drops and reconnects, it will resubscribe automatically.\n   *\n   * If a header field 'ack' is not explicitly passed, 'ack' will be set to 'auto'. If you\n   * do not understand what it means, please leave it as is.\n   *\n   * Note that when working with temporary queues where the subscription request\n   * creates the\n   * underlying queue, mssages might be missed during reconnect. This issue is not specific\n   * to this library but the way STOMP brokers are designed to work.\n   *\n   * @param queueName\n   * @param headers\n   */\n  public subscribe(queueName: string, headers: StompHeaders = {}): Observable<Stomp.Message> {\n\n    /* Well the logic is complicated but works beautifully. RxJS is indeed wonderful.\n     *\n     * We need to activate the underlying subscription immediately if Stomp is connected. If not it should\n     * subscribe when it gets next connected. Further it should re establish the subscription whenever Stomp\n     * successfully reconnects.\n     *\n     * Actual implementation is simple, we filter the BehaviourSubject 'state' so that we can trigger whenever Stomp is\n     * connected. Since 'state' is a BehaviourSubject, if Stomp is already connected, it will immediately trigger.\n     *\n     * The observable that we return to caller remains same across all reconnects, so no special handling needed at\n     * the message subscriber.\n     */\n    this.debug(`Request to subscribe ${queueName}`);\n\n    // By default auto acknowledgement of messages\n    if (!headers['ack']) {\n      headers['ack'] = 'auto';\n    }\n\n    const coldObservable = Observable.create(\n      (messages: Observer<Stomp.Message>) => {\n        /*\n         * These variables will be used as part of the closure and work their magic during unsubscribe\n         */\n        let stompSubscription: StompSubscription;\n\n        let stompConnectedSubscription: Subscription;\n\n        stompConnectedSubscription = this.connectObservable\n          .subscribe(() => {\n            this.debug(`Will subscribe to ${queueName}`);\n            stompSubscription = this.client.subscribe(queueName, (message: Stomp.Message) => {\n                messages.next(message);\n              },\n              headers);\n          });\n\n        return () => { /* cleanup function, will be called when no subscribers are left */\n          this.debug(`Stop watching connection state (for ${queueName})`);\n          stompConnectedSubscription.unsubscribe();\n\n          if (this.state.getValue() === StompState.CONNECTED) {\n            this.debug(`Will unsubscribe from ${queueName} at Stomp`);\n            stompSubscription.unsubscribe();\n          } else {\n            this.debug(`Stomp not connected, no need to unsubscribe from ${queueName} at Stomp`);\n          }\n        };\n      });\n\n    /**\n     * Important - convert it to hot Observable - otherwise, if the user code subscribes\n     * to this observable twice, it will subscribe twice to Stomp broker. (This was happening in the current example).\n     * A long but good explanatory article at https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339\n     */\n    return coldObservable.pipe(share());\n  }\n\n  /**\n   * It will handle messages received in the default queue. Messages that would not be handled otherwise\n   * get delivered to the default queue.\n   */\n  protected setupOnReceive(): void {\n    this.defaultMessagesObservable = new Subject();\n\n    this.client.onreceive = (message: Stomp.Message) => {\n      this.defaultMessagesObservable.next(message);\n    };\n  }\n\n  /**\n   * It will emit all receipts.\n   */\n  protected setupReceipts(): void {\n    this.receiptsObservable = new Subject();\n\n    this.client.onreceipt = (frame: Stomp.Frame) => {\n      this.receiptsObservable.next(frame);\n    };\n  }\n\n  /**\n   * Wait for receipt, this indicates that server has carried out the related operation\n   */\n  public waitForReceipt(receiptId: string, callback: (frame: Stomp.Frame) => void): void {\n    this.receiptsObservable.pipe(\n      filter((frame: Stomp.Frame) => {\n        return frame.headers['receipt-id'] === receiptId;\n      }),\n      first()\n    ).subscribe((frame: Stomp.Frame) => {\n      callback(frame);\n    });\n  }\n\n  /**\n   * Callback Functions\n   *\n   * Note the method signature: () => preserves lexical scope\n   * if we need to use this.x inside the function\n   */\n  protected debug = (args: any): void => {\n    console.log(new Date(), args);\n  }\n\n  /** Callback run on successfully connecting to server */\n  protected on_connect = (frame: Frame) => {\n\n    this.debug('Connected');\n\n    this._serverHeadersBehaviourSubject.next(frame.headers);\n\n    // Indicate our connected state to observers\n    this.state.next(StompState.CONNECTED);\n  }\n\n  /** Handle errors from stomp.js */\n  protected on_error = (error: string | Stomp.Message) => {\n\n    // Trigger the error subject\n    this.errorSubject.next(error);\n\n    if (typeof error === 'object') {\n      error = (<Stomp.Message>error).body;\n    }\n\n    this.debug(`Error: ${error}`);\n\n    // Check for dropped connection and try reconnecting\n    if (!this.client.connected) {\n      // Reset state indicator\n      this.state.next(StompState.CLOSED);\n    }\n  }\n}\n",
    "import { StompHeaders } from './stomp-headers';\nimport { Injectable } from '@angular/core';\n/**\n * Represents a configuration object for the\n * STOMPService to connect to.\n */\n\n@Injectable()\nexport class StompConfig {\n  /**\n   * Server URL to connect to. Please refer to your STOMP broker documentation for details.\n   *\n   * Example: ws://127.0.0.1:15674/ws (for a RabbitMQ default setup running on localhost)\n   *\n   * Alternatively this parameter can be a function that returns an object similar to WebSocket\n   * (typically SockJS instance).\n   *\n   * Example:\n   *\n   * () => {\n   *   return new SockJS('http://127.0.0.1:15674/stomp');\n   * }\n   */\n  url: string | (() => any);\n\n  /**\n   * Headers\n   * Typical keys: login: string, passcode: string.\n   * host:string will neeed to be passed for virtual hosts in RabbitMQ\n   */\n  headers: StompHeaders;\n\n  /** How often to incoming heartbeat?\n   * Interval in milliseconds, set to 0 to disable\n   *\n   * Typical value 0 - disabled\n   */\n  heartbeat_in: number;\n\n  /**\n   * How often to outgoing heartbeat?\n   * Interval in milliseconds, set to 0 to disable\n   *\n   * Typical value 20000 - every 20 seconds\n   */\n  heartbeat_out: number;\n\n  /**\n   * Wait in milliseconds before attempting auto reconnect\n   * Set to 0 to disable\n   *\n   * Typical value 5000 (5 seconds)\n   */\n  reconnect_delay: number;\n\n  /** Enable client debugging? */\n  debug: boolean;\n}\n",
    "import { Injectable } from '@angular/core';\n\nimport { StompConfig } from './stomp.config';\n\nimport { StompRService } from './stomp-r.service';\n\n/**\n * Angular2 STOMP Service using @stomp/stomp.js\n *\n * @description This service handles subscribing to a\n * message queue using the stomp.js library, and returns\n * values via the ES6 Observable specification for\n * asynchronous value streaming by wiring the STOMP\n * messages into an observable.\n *\n * If you want to manually configure and initialize the service\n * please use StompRService\n */\n@Injectable()\nexport class StompService extends StompRService {\n\n  /**\n   * Constructor\n   *\n   * See README and samples for configuration examples\n   */\n  public constructor(config: StompConfig) {\n    super();\n\n    this.config = config;\n    this.initAndConnect();\n  }\n}\n"
  ],
  "names": [
    "extendStatics",
    "Object",
    "setPrototypeOf",
    "__proto__",
    "Array",
    "d",
    "b",
    "p",
    "hasOwnProperty",
    "StompRService",
    "this",
    "queuedMessages",
    "debug",
    "args",
    "console",
    "log",
    "Date",
    "on_connect",
    "frame",
    "_this",
    "_serverHeadersBehaviourSubject",
    "next",
    "headers",
    "state",
    "StompState",
    "CONNECTED",
    "on_error",
    "error",
    "errorSubject",
    "body",
    "client",
    "connected",
    "CLOSED",
    "BehaviorSubject",
    "connectObservable",
    "pipe",
    "filter",
    "currentState",
    "subscribe",
    "sendQueuedMessages",
    "serverHeadersObservable",
    "Subject",
    "defineProperty",
    "prototype",
    "set",
    "value",
    "_config",
    "initStompClient",
    "disconnect",
    "Stomp.client",
    "url",
    "Stomp.over",
    "heartbeat",
    "incoming",
    "heartbeat_in",
    "outgoing",
    "heartbeat_out",
    "reconnect_delay",
    "setupOnReceive",
    "setupReceipts",
    "initAndConnect",
    "connect",
    "TRYING",
    "DISCONNECTING",
    "getValue",
    "publish",
    "queueName",
    "message",
    "send",
    "push",
    "queuedMessages_1",
    "o",
    "m",
    "Symbol",
    "iterator",
    "i",
    "call",
    "length",
    "done",
    "tslib_1.__values",
    "queuedMessages_1_1",
    "queuedMessage",
    "Observable",
    "create",
    "messages",
    "stompSubscription",
    "stompConnectedSubscription",
    "unsubscribe",
    "share",
    "defaultMessagesObservable",
    "onreceive",
    "receiptsObservable",
    "onreceipt",
    "waitForReceipt",
    "receiptId",
    "callback",
    "first",
    "type",
    "Injectable",
    "StompConfig",
    "StompService",
    "_super",
    "config",
    "__",
    "constructor",
    "tslib_1.__extends"
  ],
  "mappings": "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"
}
