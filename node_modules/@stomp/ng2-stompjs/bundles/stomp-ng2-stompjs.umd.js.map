{
  "version": 3,
  "file": "stomp-ng2-stompjs.umd.js",
  "sources": [
    "ng://@stomp/ng2-stompjs/out/src/stomp.service.ts",
    "ng://@stomp/ng2-stompjs/out/src/stomp.config.ts",
    "ng://@stomp/ng2-stompjs/out/src/stomp-r.service.ts",
    "ng://@stomp/ng2-stompjs/node_modules/tslib/tslib.es6.js"
  ],
  "sourcesContent": [
    "import { Injectable } from '@angular/core';\n\nimport { StompConfig } from './stomp.config';\n\nimport { StompRService } from './stomp-r.service';\n\n/**\n * Angular2 STOMP Service using @stomp/stomp.js\n *\n * @description This service handles subscribing to a\n * message queue using the stomp.js library, and returns\n * values via the ES6 Observable specification for\n * asynchronous value streaming by wiring the STOMP\n * messages into an observable.\n *\n * If you want to manually configure and initialize the service\n * please use StompRService\n */\n@Injectable()\nexport class StompService extends StompRService {\n\n  /**\n   * Constructor\n   *\n   * See README and samples for configuration examples\n   */\n  public constructor(config: StompConfig) {\n    super();\n\n    this.config = config;\n    this.initAndConnect();\n  }\n}\n",
    "import { StompHeaders } from './stomp-headers';\nimport { Injectable } from '@angular/core';\n/**\n * Represents a configuration object for the\n * STOMPService to connect to.\n */\n\n@Injectable()\nexport class StompConfig {\n  /**\n   * Server URL to connect to. Please refer to your STOMP broker documentation for details.\n   *\n   * Example: ws://127.0.0.1:15674/ws (for a RabbitMQ default setup running on localhost)\n   *\n   * Alternatively this parameter can be a function that returns an object similar to WebSocket\n   * (typically SockJS instance).\n   *\n   * Example:\n   *\n   * () => {\n   *   return new SockJS('http://127.0.0.1:15674/stomp');\n   * }\n   */\n  url: string | (() => any);\n\n  /**\n   * Headers\n   * Typical keys: login: string, passcode: string.\n   * host:string will neeed to be passed for virtual hosts in RabbitMQ\n   */\n  headers: StompHeaders;\n\n  /** How often to incoming heartbeat?\n   * Interval in milliseconds, set to 0 to disable\n   *\n   * Typical value 0 - disabled\n   */\n  heartbeat_in: number;\n\n  /**\n   * How often to outgoing heartbeat?\n   * Interval in milliseconds, set to 0 to disable\n   *\n   * Typical value 20000 - every 20 seconds\n   */\n  heartbeat_out: number;\n\n  /**\n   * Wait in milliseconds before attempting auto reconnect\n   * Set to 0 to disable\n   *\n   * Typical value 5000 (5 seconds)\n   */\n  reconnect_delay: number;\n\n  /** Enable client debugging? */\n  debug: boolean;\n}\n",
    "import { first, filter, share } from 'rxjs/operators';\nimport { Injectable } from '@angular/core';\nimport { BehaviorSubject ,  Observable ,  Observer ,  Subject ,  Subscription } from 'rxjs';\n\nimport { StompConfig } from './stomp.config';\n\nimport * as Stomp from '@stomp/stompjs';\nimport { Frame, StompSubscription } from '@stomp/stompjs';\nimport { StompHeaders } from './stomp-headers';\nimport { StompState } from './stomp-state';\n\n/**\n * Angular2 STOMP Raw Service using @stomp/stomp.js\n *\n * You will only need the public properties and\n * methods listed unless you are an advanced user. This service handles subscribing to a\n * message queue using the stomp.js library, and returns\n * values via the ES6 Observable specification for\n * asynchronous value streaming by wiring the STOMP\n * messages into an observable.\n *\n * If you will like to pass the configuration as a dependency,\n * please use StompService class.\n */\n@Injectable()\nexport class StompRService {\n  /**\n   * State of the STOMPService\n   *\n   * It is a BehaviorSubject and will emit current status immediately. This will typically get\n   * used to show current status to the end user.\n   */\n  public state: BehaviorSubject<StompState>;\n\n  /**\n   * Will trigger when connection is established. Use this to carry out initialization.\n   * It will trigger every time a (re)connection occurs. If it is already connected\n   * it will trigger immediately. You can safely ignore the value, as it will always be\n   * StompState.CONNECTED\n   */\n  public connectObservable: Observable<StompState>;\n\n  /**\n   * Provides headers from most recent connection to the server as return by the CONNECTED\n   * frame.\n   * If the STOMP connection has already been established it will trigger immediately.\n   * It will additionally trigger in event of reconnection, the value will be set of headers from\n   * the recent server response.\n   */\n  public serverHeadersObservable: Observable<StompHeaders>;\n\n  private _serverHeadersBehaviourSubject: BehaviorSubject<null | StompHeaders>;\n\n  /**\n   * Will emit all messages to the default queue (any message that are not handled by a subscription)\n   */\n  public defaultMessagesObservable: Subject<Stomp.Message>;\n\n  /**\n   * Will emit all receipts\n   */\n  public receiptsObservable: Subject<Stomp.Frame>;\n\n  /**\n   * Will trigger when an error occurs. This Subject can be used to handle errors from\n   * the stomp broker.\n   */\n  public errorSubject: Subject<string | Stomp.Message>;\n\n  /**\n   * Internal array to hold locally queued messages when STOMP broker is not connected.\n   */\n  protected queuedMessages: { queueName: string, message: string, headers: StompHeaders }[] = [];\n\n  /**\n   * Configuration\n   */\n  private _config: StompConfig;\n\n  /**\n   * STOMP Client from @stomp/stomp.js\n   */\n  protected client: Stomp.Client;\n\n  /**\n   * Constructor\n   *\n   * See README and samples for configuration examples\n   */\n  public constructor() {\n    this.state = new BehaviorSubject<StompState>(StompState.CLOSED);\n\n    this.connectObservable = this.state.pipe(\n      filter((currentState: StompState) => {\n        return currentState === StompState.CONNECTED;\n      })\n    );\n\n    // Setup sending queuedMessages\n    this.connectObservable.subscribe(() => {\n      this.sendQueuedMessages();\n    });\n\n    this._serverHeadersBehaviourSubject = new BehaviorSubject<null | StompHeaders>(null);\n\n    this.serverHeadersObservable = this._serverHeadersBehaviourSubject.pipe(\n      filter((headers: null | StompHeaders) => {\n        return headers !== null;\n      })\n    );\n\n    this.errorSubject = new Subject();\n  }\n\n  /** Set configuration */\n  set config(value: StompConfig) {\n    this._config = value;\n  }\n\n  /** It will initialize STOMP Client. */\n  protected initStompClient(): void {\n    // disconnect if connected\n    this.disconnect();\n\n    // url takes precedence over socketFn\n    if (typeof(this._config.url) === 'string') {\n      this.client = Stomp.client(this._config.url);\n    } else {\n      this.client = Stomp.over(this._config.url);\n    }\n\n    // Configure client heart-beating\n    this.client.heartbeat.incoming = this._config.heartbeat_in;\n    this.client.heartbeat.outgoing = this._config.heartbeat_out;\n\n    // Auto reconnect\n    this.client.reconnect_delay = this._config.reconnect_delay;\n\n    if (!this._config.debug) {\n      this.debug = function () {\n      };\n    }\n    // Set function to debug print messages\n    this.client.debug = this.debug;\n\n    // Default messages\n    this.setupOnReceive();\n\n    // Receipts\n    this.setupReceipts();\n  }\n\n\n  /**\n   * It will connect to the STOMP broker.\n   */\n  public initAndConnect(): void {\n    this.initStompClient();\n\n    if (!this._config.headers) {\n      this._config.headers = {};\n    }\n\n    // Attempt connection, passing in a callback\n    this.client.connect(\n      this._config.headers,\n      this.on_connect,\n      this.on_error\n    );\n\n    this.debug('Connecting...');\n    this.state.next(StompState.TRYING);\n  }\n\n\n  /**\n   * It will disconnect from the STOMP broker.\n   */\n  public disconnect(): void {\n\n    // Disconnect if connected. Callback will set CLOSED state\n    if (this.client) {\n      if (!this.client.connected) {\n        // Nothing to do\n        this.state.next(StompState.CLOSED);\n        return;\n      }\n\n      // Notify observers that we are disconnecting!\n      this.state.next(StompState.DISCONNECTING);\n\n      this.client.disconnect(\n        () => this.state.next(StompState.CLOSED)\n      );\n    }\n  }\n\n  /**\n   * It will return `true` if STOMP broker is connected and `false` otherwise.\n   */\n  public connected(): boolean {\n    return this.state.getValue() === StompState.CONNECTED;\n  }\n\n  /**\n   * It will send a message to a named destination. The message must be `string`.\n   *\n   * The message will get locally queued if the STOMP broker is not connected. It will attempt to\n   * publish queued messages as soon as the broker gets connected.\n   *\n   * @param queueName\n   * @param message\n   * @param headers\n   */\n  public publish(queueName: string, message: string, headers: StompHeaders = {}): void {\n    if (this.connected()) {\n      this.client.send(queueName, headers, message);\n    } else {\n      this.debug(`Not connected, queueing ${message}`);\n      this.queuedMessages.push({queueName: <string>queueName, message: <string>message, headers: headers});\n    }\n  }\n\n  /** It will send queued messages. */\n  protected sendQueuedMessages(): void {\n    const queuedMessages = this.queuedMessages;\n    this.queuedMessages = [];\n\n    this.debug(`Will try sending queued messages ${queuedMessages}`);\n\n    for (const queuedMessage of queuedMessages) {\n      this.debug(`Attempting to send ${queuedMessage}`);\n      this.publish(queuedMessage.queueName, queuedMessage.message, queuedMessage.headers);\n    }\n  }\n\n  /**\n   * It will subscribe to server message queues\n   *\n   * This method can be safely called even if the STOMP broker is not connected.\n   * If the underlying STOMP connection drops and reconnects, it will resubscribe automatically.\n   *\n   * If a header field 'ack' is not explicitly passed, 'ack' will be set to 'auto'. If you\n   * do not understand what it means, please leave it as is.\n   *\n   * Note that when working with temporary queues where the subscription request\n   * creates the\n   * underlying queue, mssages might be missed during reconnect. This issue is not specific\n   * to this library but the way STOMP brokers are designed to work.\n   *\n   * @param queueName\n   * @param headers\n   */\n  public subscribe(queueName: string, headers: StompHeaders = {}): Observable<Stomp.Message> {\n\n    /* Well the logic is complicated but works beautifully. RxJS is indeed wonderful.\n     *\n     * We need to activate the underlying subscription immediately if Stomp is connected. If not it should\n     * subscribe when it gets next connected. Further it should re establish the subscription whenever Stomp\n     * successfully reconnects.\n     *\n     * Actual implementation is simple, we filter the BehaviourSubject 'state' so that we can trigger whenever Stomp is\n     * connected. Since 'state' is a BehaviourSubject, if Stomp is already connected, it will immediately trigger.\n     *\n     * The observable that we return to caller remains same across all reconnects, so no special handling needed at\n     * the message subscriber.\n     */\n    this.debug(`Request to subscribe ${queueName}`);\n\n    // By default auto acknowledgement of messages\n    if (!headers['ack']) {\n      headers['ack'] = 'auto';\n    }\n\n    const coldObservable = Observable.create(\n      (messages: Observer<Stomp.Message>) => {\n        /*\n         * These variables will be used as part of the closure and work their magic during unsubscribe\n         */\n        let stompSubscription: StompSubscription;\n\n        let stompConnectedSubscription: Subscription;\n\n        stompConnectedSubscription = this.connectObservable\n          .subscribe(() => {\n            this.debug(`Will subscribe to ${queueName}`);\n            stompSubscription = this.client.subscribe(queueName, (message: Stomp.Message) => {\n                messages.next(message);\n              },\n              headers);\n          });\n\n        return () => { /* cleanup function, will be called when no subscribers are left */\n          this.debug(`Stop watching connection state (for ${queueName})`);\n          stompConnectedSubscription.unsubscribe();\n\n          if (this.state.getValue() === StompState.CONNECTED) {\n            this.debug(`Will unsubscribe from ${queueName} at Stomp`);\n            stompSubscription.unsubscribe();\n          } else {\n            this.debug(`Stomp not connected, no need to unsubscribe from ${queueName} at Stomp`);\n          }\n        };\n      });\n\n    /**\n     * Important - convert it to hot Observable - otherwise, if the user code subscribes\n     * to this observable twice, it will subscribe twice to Stomp broker. (This was happening in the current example).\n     * A long but good explanatory article at https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339\n     */\n    return coldObservable.pipe(share());\n  }\n\n  /**\n   * It will handle messages received in the default queue. Messages that would not be handled otherwise\n   * get delivered to the default queue.\n   */\n  protected setupOnReceive(): void {\n    this.defaultMessagesObservable = new Subject();\n\n    this.client.onreceive = (message: Stomp.Message) => {\n      this.defaultMessagesObservable.next(message);\n    };\n  }\n\n  /**\n   * It will emit all receipts.\n   */\n  protected setupReceipts(): void {\n    this.receiptsObservable = new Subject();\n\n    this.client.onreceipt = (frame: Stomp.Frame) => {\n      this.receiptsObservable.next(frame);\n    };\n  }\n\n  /**\n   * Wait for receipt, this indicates that server has carried out the related operation\n   */\n  public waitForReceipt(receiptId: string, callback: (frame: Stomp.Frame) => void): void {\n    this.receiptsObservable.pipe(\n      filter((frame: Stomp.Frame) => {\n        return frame.headers['receipt-id'] === receiptId;\n      }),\n      first()\n    ).subscribe((frame: Stomp.Frame) => {\n      callback(frame);\n    });\n  }\n\n  /**\n   * Callback Functions\n   *\n   * Note the method signature: () => preserves lexical scope\n   * if we need to use this.x inside the function\n   */\n  protected debug = (args: any): void => {\n    console.log(new Date(), args);\n  }\n\n  /** Callback run on successfully connecting to server */\n  protected on_connect = (frame: Frame) => {\n\n    this.debug('Connected');\n\n    this._serverHeadersBehaviourSubject.next(frame.headers);\n\n    // Indicate our connected state to observers\n    this.state.next(StompState.CONNECTED);\n  }\n\n  /** Handle errors from stomp.js */\n  protected on_error = (error: string | Stomp.Message) => {\n\n    // Trigger the error subject\n    this.errorSubject.next(error);\n\n    if (typeof error === 'object') {\n      error = (<Stomp.Message>error).body;\n    }\n\n    this.debug(`Error: ${error}`);\n\n    // Check for dropped connection and try reconnecting\n    if (!this.client.connected) {\n      // Reset state indicator\n      this.state.next(StompState.CLOSED);\n    }\n  }\n}\n",
    "/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n"
  ],
  "names": [
    "Injectable",
    "tslib_1.__extends",
    "first",
    "filter",
    "Subject",
    "share",
    "Observable",
    "tslib_1.__values",
    "Stomp.over",
    "Stomp.client",
    "BehaviorSubject"
  ],
  "mappings": "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"
}
