/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectorRef, ComponentFactoryResolver, Injectable, KeyValueDiffers, } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { changesFromRecord, createNewChange, noop } from './util';
/**
 * @record
 */
export function IoInitOptions() { }
if (false) {
    /** @type {?|undefined} */
    IoInitOptions.prototype.trackOutputChanges;
}
/** @type {?} */
const recordToChanges = changesFromRecord({ isFirstChanges: true });
/** @type {?} */
const recordToNewChanges = changesFromRecord({ onlyNewChanges: true });
export class IoService {
    /**
     * @param {?} _differs
     * @param {?} _cfr
     */
    constructor(_differs, _cfr) {
        this._differs = _differs;
        this._cfr = _cfr;
        this.checkInit = this.failInit;
        this._lastComponentInst = null;
        this._inputsDiffer = this._differs.find({}).create();
        this._compFactory = null;
        this._outputsShouldDisconnect$ = new Subject();
        this._outputsChanged = (/**
         * @return {?}
         */
        () => false);
    }
    /**
     * @private
     * @return {?}
     */
    get _compRef() {
        return this._compInjector.componentRef;
    }
    /**
     * @private
     * @return {?}
     */
    get _componentInst() {
        return this._compRef ? this._compRef.instance : null;
    }
    /**
     * @private
     * @return {?}
     */
    get _componentInstChanged() {
        if (this._lastComponentInst !== this._componentInst) {
            this._lastComponentInst = this._componentInst;
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @private
     * @return {?}
     */
    get _compCdr() {
        return this._compRef ? this._compRef.injector.get(ChangeDetectorRef) : null;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._disconnectOutputs();
    }
    /**
     * @param {?} componentInjector
     * @param {?=} options
     * @return {?}
     */
    init(componentInjector, options = {}) {
        this.checkInit = componentInjector ? noop : this.failInit;
        this._compInjector = componentInjector;
        if (options.trackOutputChanges) {
            /** @type {?} */
            const outputsDiffer = this._differs.find({}).create();
            this._outputsChanged = (/**
             * @param {?} outputs
             * @return {?}
             */
            outputs => !!outputsDiffer.diff(outputs));
        }
    }
    /**
     * @param {?} inputs
     * @param {?} outputs
     * @param {?} inputsChanged
     * @param {?} outputsChanged
     * @return {?}
     */
    update(inputs, outputs, inputsChanged, outputsChanged) {
        this.checkInit();
        this.updateIO(inputs, outputs);
        /** @type {?} */
        const compChanged = this._componentInstChanged;
        if (compChanged || inputsChanged) {
            /** @type {?} */
            const inputsChanges = this._getInputsChanges(this._inputs);
            if (inputsChanges) {
                this._updateInputChanges(inputsChanges);
            }
            this.updateInputs(compChanged || !this._lastInputChanges);
        }
        if (compChanged || outputsChanged) {
            this.bindOutputs();
        }
    }
    /**
     * @return {?}
     */
    maybeUpdate() {
        this.checkInit();
        if (this._componentInstChanged) {
            this.updateInputs(true);
            this.bindOutputs();
            return;
        }
        if (this._outputsChanged(this._outputs)) {
            this.bindOutputs();
        }
        if (!this._inputs) {
            return;
        }
        /** @type {?} */
        const inputsChanges = this._getInputsChanges(this._inputs);
        if (inputsChanges) {
            /** @type {?} */
            const isNotFirstChange = !!this._lastInputChanges;
            this._updateInputChanges(inputsChanges);
            if (isNotFirstChange) {
                this.updateInputs();
            }
        }
    }
    /**
     * @private
     * @param {?} inputs
     * @param {?} outputs
     * @return {?}
     */
    updateIO(inputs, outputs) {
        this._inputs = inputs;
        this._outputs = outputs;
    }
    /**
     * @private
     * @param {?=} isFirstChange
     * @return {?}
     */
    updateInputs(isFirstChange = false) {
        if (isFirstChange) {
            this._updateCompFactory();
        }
        /** @type {?} */
        const compInst = this._componentInst;
        /** @type {?} */
        let inputs = this._inputs;
        if (!inputs || !compInst) {
            return;
        }
        inputs = this._resolveInputs(inputs);
        Object.keys(inputs).forEach((/**
         * @param {?} p
         * @return {?}
         */
        p => (compInst[p] = inputs[p])));
        // Mark component for check to re-render with new inputs
        if (this._compCdr) {
            this._compCdr.markForCheck();
        }
        this.notifyOnInputChanges(this._lastInputChanges, isFirstChange);
    }
    /**
     * @private
     * @return {?}
     */
    bindOutputs() {
        this._disconnectOutputs();
        /** @type {?} */
        const compInst = this._componentInst;
        /** @type {?} */
        let outputs = this._outputs;
        if (!outputs || !compInst) {
            return;
        }
        outputs = this._resolveOutputs(outputs);
        Object.keys(outputs)
            .filter((/**
         * @param {?} p
         * @return {?}
         */
        p => compInst[p]))
            .forEach((/**
         * @param {?} p
         * @return {?}
         */
        p => compInst[p]
            .pipe(takeUntil(this._outputsShouldDisconnect$))
            .subscribe(outputs[p])));
    }
    /**
     * @private
     * @param {?=} changes
     * @param {?=} forceFirstChanges
     * @return {?}
     */
    notifyOnInputChanges(changes = {}, forceFirstChanges) {
        // Exit early if component not interested to receive changes
        if (!this._componentInst.ngOnChanges) {
            return;
        }
        if (forceFirstChanges) {
            changes = this._collectFirstChanges();
        }
        this._componentInst.ngOnChanges(changes);
    }
    /**
     * @private
     * @return {?}
     */
    _disconnectOutputs() {
        this._outputsShouldDisconnect$.next();
    }
    /**
     * @private
     * @param {?} inputs
     * @return {?}
     */
    _getInputsChanges(inputs) {
        return this._inputsDiffer.diff(this._inputs);
    }
    /**
     * @private
     * @param {?} differ
     * @return {?}
     */
    _updateInputChanges(differ) {
        this._lastInputChanges = this._collectChangesFromDiffer(differ);
    }
    /**
     * @private
     * @return {?}
     */
    _collectFirstChanges() {
        /** @type {?} */
        const changes = (/** @type {?} */ ({}));
        /** @type {?} */
        const inputs = this._inputs;
        Object.keys(inputs).forEach((/**
         * @param {?} prop
         * @return {?}
         */
        prop => (changes[prop] = createNewChange(inputs[prop]))));
        return this._resolveChanges(changes);
    }
    /**
     * @private
     * @param {?} differ
     * @return {?}
     */
    _collectChangesFromDiffer(differ) {
        /** @type {?} */
        const changes = (/** @type {?} */ ({}));
        differ.forEachAddedItem(recordToChanges(changes));
        differ.forEachItem(recordToNewChanges(changes));
        return this._resolveChanges(changes);
    }
    /**
     * @private
     * @return {?}
     */
    _resolveCompFactory() {
        try {
            try {
                return this._cfr.resolveComponentFactory(this._compRef.componentType);
            }
            catch (e) {
                // Fallback if componentType does not exist (happens on NgComponentOutlet)
                return this._cfr.resolveComponentFactory(this._compRef.instance.constructor);
            }
        }
        catch (e) {
            // Factory not available - bailout
            return null;
        }
    }
    /**
     * @private
     * @return {?}
     */
    _updateCompFactory() {
        this._compFactory = this._resolveCompFactory();
    }
    /**
     * @private
     * @param {?} inputs
     * @return {?}
     */
    _resolveInputs(inputs) {
        if (!this._compFactory) {
            return inputs;
        }
        return this._remapIO(inputs, this._compFactory.inputs);
    }
    /**
     * @private
     * @param {?} outputs
     * @return {?}
     */
    _resolveOutputs(outputs) {
        if (!this._compFactory) {
            return outputs;
        }
        return this._remapIO(outputs, this._compFactory.outputs);
    }
    /**
     * @private
     * @param {?} changes
     * @return {?}
     */
    _resolveChanges(changes) {
        if (!this._compFactory) {
            return changes;
        }
        return this._remapIO(changes, this._compFactory.inputs);
    }
    /**
     * @private
     * @param {?} io
     * @param {?} mapping
     * @return {?}
     */
    _remapIO(io, mapping) {
        /** @type {?} */
        const newIO = {};
        Object.keys(io).forEach((/**
         * @param {?} key
         * @return {?}
         */
        key => {
            /** @type {?} */
            const newKey = this._findPropByTplInMapping(key, mapping) || key;
            newIO[newKey] = io[key];
        }));
        return newIO;
    }
    /**
     * @private
     * @param {?} tplName
     * @param {?} mapping
     * @return {?}
     */
    _findPropByTplInMapping(tplName, mapping) {
        for (const map of mapping) {
            if (map.templateName === tplName) {
                return map.propName;
            }
        }
        return null;
    }
    /**
     * @private
     * @return {?}
     */
    failInit() {
        throw Error('IoService: ComponentInjector was not set! Please call init() method!');
    }
}
IoService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
IoService.ctorParameters = () => [
    { type: KeyValueDiffers },
    { type: ComponentFactoryResolver }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    IoService.prototype.checkInit;
    /**
     * @type {?}
     * @private
     */
    IoService.prototype._lastComponentInst;
    /**
     * @type {?}
     * @private
     */
    IoService.prototype._lastInputChanges;
    /**
     * @type {?}
     * @private
     */
    IoService.prototype._inputsDiffer;
    /**
     * @type {?}
     * @private
     */
    IoService.prototype._compFactory;
    /**
     * @type {?}
     * @private
     */
    IoService.prototype._outputsShouldDisconnect$;
    /**
     * @type {?}
     * @private
     */
    IoService.prototype._inputs;
    /**
     * @type {?}
     * @private
     */
    IoService.prototype._outputs;
    /**
     * @type {?}
     * @private
     */
    IoService.prototype._compInjector;
    /**
     * @type {?}
     * @private
     */
    IoService.prototype._outputsChanged;
    /**
     * @type {?}
     * @private
     */
    IoService.prototype._differs;
    /**
     * @type {?}
     * @private
     */
    IoService.prototype._cfr;
}
//# sourceMappingURL=io.service.js.map