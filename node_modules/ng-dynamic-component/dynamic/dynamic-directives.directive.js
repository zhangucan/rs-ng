/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, EventEmitter, Host, Inject, Injector, Input, IterableDiffers, Optional, Output, ViewContainerRef, } from '@angular/core';
import { COMPONENT_INJECTOR } from './component-injector';
import { ComponentOutletInjectorDirective } from './component-outlet-injector.directive';
import { IoFactoryService } from './io-factory.service';
import { getCtorType } from './util';
import { WindowRefService } from './window-ref.service';
/**
 * @record
 * @template T
 */
export function DynamicDirectiveDef() { }
if (false) {
    /** @type {?} */
    DynamicDirectiveDef.prototype.type;
    /** @type {?|undefined} */
    DynamicDirectiveDef.prototype.inputs;
    /** @type {?|undefined} */
    DynamicDirectiveDef.prototype.outputs;
}
/**
 * @template T
 * @param {?} type
 * @param {?=} inputs
 * @param {?=} outputs
 * @return {?}
 */
export function dynamicDirectiveDef(type, inputs, outputs) {
    return { type, inputs, outputs };
}
/**
 * @record
 * @template T
 */
export function DirectiveRef() { }
if (false) {
    /** @type {?} */
    DirectiveRef.prototype.instance;
    /** @type {?} */
    DirectiveRef.prototype.type;
    /** @type {?} */
    DirectiveRef.prototype.injector;
    /** @type {?} */
    DirectiveRef.prototype.hostComponent;
    /** @type {?} */
    DirectiveRef.prototype.hostView;
    /** @type {?} */
    DirectiveRef.prototype.location;
    /** @type {?} */
    DirectiveRef.prototype.changeDetectorRef;
    /** @type {?} */
    DirectiveRef.prototype.onDestroy;
}
export class DynamicDirectivesDirective {
    /**
     * @param {?} injector
     * @param {?} iterableDiffers
     * @param {?} ioFactoryService
     * @param {?} windowRef
     * @param {?} componentInjectorType
     * @param {?} componentOutletInjector
     */
    constructor(injector, iterableDiffers, ioFactoryService, windowRef, componentInjectorType, componentOutletInjector) {
        this.injector = injector;
        this.iterableDiffers = iterableDiffers;
        this.ioFactoryService = ioFactoryService;
        this.windowRef = windowRef;
        this.componentInjectorType = componentInjectorType;
        this.componentOutletInjector = componentOutletInjector;
        this.ndcDynamicDirectivesCreated = new EventEmitter();
        this.componentInjector = this.injector.get(this.componentInjectorType, null);
        this.dirRef = new Map();
        this.dirIo = new Map();
        this.dirsDiffer = this.iterableDiffers
            .find([])
            .create((/**
         * @param {?} _
         * @param {?} def
         * @return {?}
         */
        (_, def) => def.type));
    }
    /**
     * @private
     * @return {?}
     */
    get directives() {
        return (this.ndcDynamicDirectives || this.ngComponentOutletNdcDynamicDirectives);
    }
    /**
     * @private
     * @return {?}
     */
    get compInjector() {
        return this.componentOutletInjector || this.componentInjector;
    }
    /**
     * @private
     * @return {?}
     */
    get componentRef() {
        return this.compInjector.componentRef;
    }
    /**
     * @private
     * @return {?}
     */
    get compInstance() {
        return this.componentRef && this.componentRef.instance;
    }
    /**
     * @private
     * @return {?}
     */
    get isCompChanged() {
        if (this.lastCompInstance !== this.compInstance) {
            this.lastCompInstance = this.compInstance;
            return true;
        }
        return false;
    }
    /**
     * @private
     * @return {?}
     */
    get hostInjector() {
        return this.componentRef.injector;
    }
    /**
     * @private
     * @return {?}
     */
    get hostVcr() {
        return this.componentRef['_viewRef']['_viewContainerRef'];
    }
    /**
     * @private
     * @return {?}
     */
    get reflect() {
        return ((/** @type {?} */ (this.windowRef.nativeWindow))).Reflect;
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this.maybeDestroyDirectives()) {
            return;
        }
        /** @type {?} */
        const dirsChanges = this.dirsDiffer.diff(this.directives);
        if (!dirsChanges) {
            return this.updateDirectives();
        }
        this.processDirChanges(dirsChanges);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroyAllDirectives();
    }
    /**
     * @private
     * @return {?}
     */
    maybeDestroyDirectives() {
        if (this.isCompChanged || !this.componentRef) {
            this.dirsDiffer.diff([]);
            this.destroyAllDirectives();
        }
        return !this.componentRef;
    }
    /**
     * @private
     * @param {?} changes
     * @return {?}
     */
    processDirChanges(changes) {
        changes.forEachRemovedItem((/**
         * @param {?} __0
         * @return {?}
         */
        ({ item }) => this.destroyDirective(item)));
        /** @type {?} */
        const createdDirs = [];
        changes.forEachAddedItem((/**
         * @param {?} __0
         * @return {?}
         */
        ({ item }) => createdDirs.push(this.initDirective(item))));
        if (createdDirs.length) {
            this.ndcDynamicDirectivesCreated.emit(createdDirs.filter(Boolean));
        }
    }
    /**
     * @private
     * @return {?}
     */
    updateDirectives() {
        this.directives.forEach((/**
         * @param {?} dir
         * @return {?}
         */
        dir => this.updateDirective(dir)));
    }
    /**
     * @private
     * @param {?} dirDef
     * @return {?}
     */
    updateDirective(dirDef) {
        /** @type {?} */
        const io = this.dirIo.get(dirDef.type);
        io.update(dirDef.inputs, dirDef.outputs, false, false);
        io.maybeUpdate();
    }
    /**
     * @private
     * @param {?} dirDef
     * @return {?}
     */
    initDirective(dirDef) {
        if (this.dirRef.has(dirDef.type)) {
            return;
        }
        /** @type {?} */
        const instance = this.createDirective(dirDef.type);
        /** @type {?} */
        const dir = {
            instance,
            type: dirDef.type,
            injector: this.hostInjector,
            hostComponent: this.componentRef.instance,
            hostView: this.componentRef.hostView,
            location: this.componentRef.location,
            changeDetectorRef: this.componentRef.changeDetectorRef,
            onDestroy: this.componentRef.onDestroy,
        };
        this.initDirIO(dir, dirDef.inputs, dirDef.outputs);
        this.callInitHooks(instance);
        this.dirRef.set(dir.type, dir);
        return dir;
    }
    /**
     * @private
     * @return {?}
     */
    destroyAllDirectives() {
        this.dirRef.forEach((/**
         * @param {?} dir
         * @return {?}
         */
        dir => this.destroyDirRef(dir)));
        this.dirRef.clear();
        this.dirIo.clear();
    }
    /**
     * @private
     * @param {?} dirDef
     * @return {?}
     */
    destroyDirective(dirDef) {
        this.destroyDirRef(this.dirRef.get(dirDef.type));
        this.dirRef.delete(dirDef.type);
        this.dirIo.delete(dirDef.type);
    }
    /**
     * @private
     * @param {?} dir
     * @param {?=} inputs
     * @param {?=} outputs
     * @return {?}
     */
    initDirIO(dir, inputs, outputs) {
        /** @type {?} */
        const io = this.ioFactoryService.create();
        io.init({ componentRef: this.dirToCompDef(dir) }, { trackOutputChanges: true });
        io.update(inputs, outputs, !!inputs, !!outputs);
        this.dirIo.set(dir.type, io);
    }
    /**
     * @private
     * @param {?} dir
     * @return {?}
     */
    dirToCompDef(dir) {
        return Object.assign({}, this.componentRef, { destroy: this.componentRef.destroy, onDestroy: this.componentRef.onDestroy, injector: this.componentRef.injector, instance: dir.instance, componentType: dir.type });
    }
    /**
     * @private
     * @param {?} dir
     * @return {?}
     */
    destroyDirRef(dir) {
        /** @type {?} */
        const io = this.dirIo.get(dir.type);
        io.ngOnDestroy();
        if ('ngOnDestroy' in dir.instance) {
            dir.instance.ngOnDestroy();
        }
    }
    /**
     * @private
     * @template T
     * @param {?} dirType
     * @return {?}
     */
    createDirective(dirType) {
        /** @type {?} */
        const ctorParams = getCtorType(dirType, this.reflect);
        /** @type {?} */
        const resolvedParams = ctorParams.map((/**
         * @param {?} p
         * @return {?}
         */
        p => this.resolveDep(p)));
        return new dirType(...resolvedParams);
    }
    /**
     * @private
     * @param {?} dep
     * @return {?}
     */
    resolveDep(dep) {
        return this.maybeResolveVCR(dep) || this.hostInjector.get(dep);
    }
    /**
     * @private
     * @param {?} dep
     * @return {?}
     */
    maybeResolveVCR(dep) {
        if (dep === ViewContainerRef) {
            return this.hostVcr;
        }
    }
    /**
     * @private
     * @param {?} obj
     * @return {?}
     */
    callInitHooks(obj) {
        this.callHook(obj, 'ngOnInit');
        this.callHook(obj, 'ngDoCheck');
        this.callHook(obj, 'ngAfterContentInit');
        this.callHook(obj, 'ngAfterContentChecked');
        this.callHook(obj, 'ngAfterViewInit');
        this.callHook(obj, 'ngAfterViewChecked');
    }
    /**
     * @private
     * @param {?} obj
     * @param {?} hook
     * @param {?=} args
     * @return {?}
     */
    callHook(obj, hook, args = []) {
        if (obj[hook]) {
            obj[hook](...args);
        }
    }
}
DynamicDirectivesDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ndcDynamicDirectives],[ngComponentOutletNdcDynamicDirectives]',
            },] },
];
/** @nocollapse */
DynamicDirectivesDirective.ctorParameters = () => [
    { type: Injector },
    { type: IterableDiffers },
    { type: IoFactoryService },
    { type: WindowRefService },
    { type: undefined, decorators: [{ type: Inject, args: [COMPONENT_INJECTOR,] }] },
    { type: ComponentOutletInjectorDirective, decorators: [{ type: Host }, { type: Optional }] }
];
DynamicDirectivesDirective.propDecorators = {
    ndcDynamicDirectives: [{ type: Input }],
    ngComponentOutletNdcDynamicDirectives: [{ type: Input }],
    ndcDynamicDirectivesCreated: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    DynamicDirectivesDirective.prototype.ndcDynamicDirectives;
    /** @type {?} */
    DynamicDirectivesDirective.prototype.ngComponentOutletNdcDynamicDirectives;
    /** @type {?} */
    DynamicDirectivesDirective.prototype.ndcDynamicDirectivesCreated;
    /**
     * @type {?}
     * @private
     */
    DynamicDirectivesDirective.prototype.componentInjector;
    /**
     * @type {?}
     * @private
     */
    DynamicDirectivesDirective.prototype.lastCompInstance;
    /**
     * @type {?}
     * @private
     */
    DynamicDirectivesDirective.prototype.dirRef;
    /**
     * @type {?}
     * @private
     */
    DynamicDirectivesDirective.prototype.dirIo;
    /**
     * @type {?}
     * @private
     */
    DynamicDirectivesDirective.prototype.dirsDiffer;
    /**
     * @type {?}
     * @private
     */
    DynamicDirectivesDirective.prototype.injector;
    /**
     * @type {?}
     * @private
     */
    DynamicDirectivesDirective.prototype.iterableDiffers;
    /**
     * @type {?}
     * @private
     */
    DynamicDirectivesDirective.prototype.ioFactoryService;
    /**
     * @type {?}
     * @private
     */
    DynamicDirectivesDirective.prototype.windowRef;
    /**
     * @type {?}
     * @private
     */
    DynamicDirectivesDirective.prototype.componentInjectorType;
    /**
     * @type {?}
     * @private
     */
    DynamicDirectivesDirective.prototype.componentOutletInjector;
}
//# sourceMappingURL=dynamic-directives.directive.js.map